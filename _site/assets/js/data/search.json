[ { "title": "创建自定义Springboot starter", "url": "/HYCBlog/posts/springboot-starter-id/", "categories": "Blogging, javaweb", "tags": "web", "date": "2021-01-14 10:11:00 +0800", "snippet": "以redis为例，创建一个自定义的Springboot starter。首先创建一个工程，命名为redis-spring-boot-starter。添加Jar包依赖：Redisson提供了在Java中操作Redis的功能，并且基于Redis的特性封装了很多可直接使用的场景，比如分布式锁。&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.redisson&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;redisson-all&amp;lt;/artifactId&amp;gt..." }, { "title": "Leetcode：树专题整理", "url": "/HYCBlog/posts/leetcode-tree/", "categories": "Blogging, leetcode", "tags": "算法题解", "date": "2021-01-08 16:21:00 +0800", "snippet": "二叉树遍历***114.二叉树展开为链表给定一个二叉树，原地将它展开为一个单链表。第一题采用逆后序遍历，用一个指针指向上一个节点，然后将当前节点的right指向上一个节点，并把left置空。class Solution { TreeNode pre = null; public void flatten(TreeNode root) { if(root != null){ flatten(root.right); flatten(root.left); if(pre != null){ ..." }, { "title": "JVM in Go Style", "url": "/HYCBlog/posts/jvm-in-Go-style/", "categories": "Blogging, java", "tags": "jvm", "date": "2021-01-04 20:50:00 +0800", "snippet": "目录：1 命令行工具1.1 准备工作1.2 Java命令1.3 编写命令行工具1.4 测试命令行工具2 搜索class文件1 命令行工具1.1 准备工作操作系统：macOS 10.15.7java version： “1.8.0_201”go version： go1.15.3 darwin/amd641.1.1/2 安装JDK和Go省略了安装的步骤。go 命令行希望所有的Go源代码都被放在一个工作空间中。所谓工作空间，实际上就是一个目录结构，这个目录结构包含三个子目录。 .src目录中是Go语言的源代码 .pkg目录中是编译好的包对象文件 .bin目录是链接好的可执行文件只有sr..." }, { "title": "JVM 类文件结构", "url": "/HYCBlog/posts/java-classfile-structure/", "categories": "Blogging, java", "tags": "jvm", "date": "2020-12-19 15:50:00 +0800", "snippet": "Class文件是一组以8个字节为基础单位的二进制流，各个数据项严格按照顺序紧凑地排列在文件之中，中间没有添加任何分隔符。当遇到需要占用8个字节以上空间的数据项时，则会以大端格式（Big-Endian）存储（高位在前）。根据《Java虚拟机规范》的规定，Class文件格式采用一种类似于C语言结构体的伪结构来存储数 据，这种伪结构中只有两种数据类型：“无符号数”和“表”。无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个 字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符 值。表是由多个无符号数或者其他表作为..." }, { "title": "Java源码分析之HashMap", "url": "/HYCBlog/posts/java-hashmap/", "categories": "Blogging, 容器", "tags": "Java源码学习", "date": "2020-11-24 20:30:00 +0800", "snippet": "类前注释关键点： HashMap和HashTable大致相当，只不过HashMap是非线程安全的，并且允许空值。HashMap集合内的元素顺序是无法保证的，可能会改变。 如果哈希函数将元素正确分散在存储桶中，get和put操作只花费常量时间。迭代整个集合，花费的时间为桶的数量 x 键值对的数量。如果需要对此集合进行迭代操作，那么一定不要把桶的数量初始化地太大，或者装载因子设地太低。 如前所述，HashMap有两个参数会影响其实例的性能：（1）initail capacity和load factor。capacity表示哈希表中桶的数量；load fa..." }, { "title": "Java并发 并发队列原理剖析", "url": "/HYCBlog/posts/java-concurrency-queue/", "categories": "Blogging, java", "tags": "concurrency", "date": "2020-11-04 21:16:00 +0800", "snippet": "JDK 中提供了一系列场景的并发安全队列。总的来说，按照实现方式的不同可分为阻塞队列和非阻塞队列，前者使用锁实现，而后者则使用 CAS 非阻塞算法实现。1. ConcurrentLinkedQueue原理探究1.1 ConcurrentLinkedQueue原理介绍 offer操作 public boolean offer(E e) { //e为空就抛出空指针异常 checkNotNull(e); //构造Node节点，在构造函数内部调用unsafe.putObject final Node&amp;lt;E&amp;gt; n..." }, { "title": "JavaWeb SSM+Maven实现简单的秒杀系统", "url": "/HYCBlog/posts/javaweb-seckill/", "categories": "Blogging, javaweb", "tags": "web", "date": "2020-11-03 19:44:00 +0800", "snippet": "参考自：https://github.com/codingXiaxw/seckill1. 业务流程描述用户成功秒杀商品，系统需要做的事：1、减库存；2、记录用户的购买明细。（1.谁购买成功了。2.购买成功的时间/有效期。3.付款/发货信息）为什么我们的系统需要事务:1.用户成功秒杀商品我们记录了其购买明细却没有减库存，导致超卖。2.减了库存却没有记录用户的购买明细，导致少卖。如何在保证事务的情况下，实现高并发？2.环境搭建2.1 添加依赖单元测试、日志、数据库相关依赖、servlet web相关、mybatis、Spring核心依赖、Spring-dao、spring-web依赖 &a..." }, { "title": "Leetcode题解:Hot 100!", "url": "/HYCBlog/posts/leetcode-solution_hot_100/", "categories": "Blogging, leetcode", "tags": "算法题解", "date": "2020-10-23 13:51:00 +0800", "snippet": "目录1.两数之和2.两数相加4. 寻找两个正序数组的中位数5.最长回文子串10. 正则表达式匹配11.盛最多水的容器15.三数之和17.电话号码的字母组合19.删除链表的倒数第N个节点20.有效的括号21.合并两个有序链表22.括号生成31.下一个排列32. 最长有效括号33.搜索旋转排序数组34.[重要]在排序数组中查找元素的第一个和最后一个位置39.组合总和42. 接雨水46. 全排列48.旋转图像49.字母异位词分组53.最大子序和55. 跳跃游戏62.不同路径64.最小路径和70. 爬楼梯72. 编辑距离75.颜色分类76. 最小覆盖子串78.子集79.单词搜索84. 柱状图中最..." }, { "title": "用Docker搭建一套Redis Sentinel集群", "url": "/HYCBlog/posts/redis-sentinel/", "categories": "Blogging, web", "tags": "redis", "date": "2020-10-12 20:51:00 +0800", "snippet": "集群配置：一个主节点(master)、两个从节点(slave)、三个哨兵(sentinel)。以下步骤省略： 安装docker； 拉取redis镜像；1.获取并修改redis配置文件$ wget http://download.redis.io/redis-stable/redis.conf #官方提供的配置文件样例拷贝这个文件3份，一份为master配置文件，其他两份为slave配置文件。1.1配置master文件# 注释这一行，表示Redis可以接受任意ip的连接# bind 127.0.0.1 # 关闭保护模式protected-mode no # 让redis服务后台运行da..." }, { "title": "Java的四个元注解", "url": "/HYCBlog/posts/java-meta-annotation/", "categories": "Blogging, java", "tags": "java", "date": "2020-09-25 10:17:00 +0800", "snippet": " @Target 描述注解的使用范围，即被修饰的注解可以用在什么地方。 注解可以用于修饰 packages、types（类、接口、枚举、注解类）、类成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch参数） public enum ElementType { TYPE, // 类、接口、枚举类 FIELD, // 成员变量（包括：枚举常量） METHOD, // 成员方法 PARAMETER, // 方法..." }, { "title": "Leetcode题解", "url": "/HYCBlog/posts/leetcode-solutions/", "categories": "Blogging, leetcode", "tags": "算法题解", "date": "2020-09-23 08:29:00 +0800", "snippet": "目录5.最长回文子串16.最接近三数之和17.电话号码的字母组合18.四数之和19.删除链表的倒数第N个节点24.两两交换链表中的节点37.解数独39.组合总和140.组合总和243.字符串相乘47.全排列50.Pow(x, n)51.N 皇后52.N皇后 II[tag]57.插入区间60.第k个排列[tag]62.不同路径63.含障碍物网格中的不同路径67.二进制求和75.颜色分类77.组合[tag:字典序]79.单词搜索93. 恢复IP地址94.二叉树的中序遍历96. 不同的二叉搜索树98.验证二叉搜索树100. 相同的树103. 二叉树的锯齿形层序遍历106.从中序与后序遍历序列构..." }, { "title": "并查集", "url": "/HYCBlog/posts/algorithm-union-find/", "categories": "Blogging, Algorithms", "tags": "Algorithms", "date": "2020-09-17 14:14:00 +0800", "snippet": " 作用：用于图快速查找祖先的数据结构。简单实现class UnionFind{ int[] pre; public UnionFind(int n){ pre = new int[n]; //初始化并查集，初始时，所有节点都是孤立的，即有n个连通分支 for(int i = 0; i &amp;lt; n; ++i){ pre[i] = i; } } //找到一个节点对应的连通分支的根节点，即pre[x] = x的节点 //顺带做了路径压缩，最后把x的父节点修改为了根节点 pu..." }, { "title": "处理大数：剑指 Offer 14- II. 剪绳子 II", "url": "/HYCBlog/posts/leetcode-hard_0/", "categories": "Blogging, leetcode", "tags": "算法题解", "date": "2020-09-16 21:14:00 +0800", "snippet": "这题做了很久，做不出来，看题解也看了好久，难点在于证明过程，以及如何对大数求余。这题单独列出来，需要多看看，否则下次碰到了还是不会。题目描述给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&amp;gt;1并且m&amp;gt;1），每段绳子的长度记为 k[0],k[1]…k[m - 1] 。请问 k[0]k[1]…*k[m - 1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。示例 1：..." }, { "title": "Java源码分析之ArrayList", "url": "/HYCBlog/posts/java-ArrayList-srccode-analyze/", "categories": "Blogging, 容器", "tags": "Java源码学习", "date": "2020-09-16 18:27:00 +0800", "snippet": "类前注释先看源码开始的一大段注释，基本上把ArrayList的功能和实现介绍了一下：/**Resizable-array implementation of the List interface. Implementsall optional list operations, and permits all elements, includingnull. In addition to implementing the List interface,this class provides methods to manipulate the size of the array that..." }, { "title": "Java访问控制", "url": "/HYCBlog/posts/java-access-control/", "categories": "Blogging, java", "tags": "java", "date": "2020-09-12 18:39:00 +0800", "snippet": " 父类引用只能调用父类中定义的方法和变量。 对于父类中定义的方法，如果子类中重写了该方法，那么父类类型的引用将会调用子类中的这个方法，这就是动态连接。还有一种特殊情形，当子类重写了父类的某个方法时，子类的父类引用调用了一个父类的其他方法，这个方法中调用了被重写的父类方法，那么执行的结果会是被重写过后的父类方法，并不会执行原来的父类方法。具体示例如下： class Father{ public void func1(){ func2(); } //这是父类中的func2()方法，因为下面的子类中重写了该方法所以在父类类型的引用中调用时，这个方法将..." }, { "title": "VO/DTO/DO/PO/POJO/JavaBean的区别", "url": "/HYCBlog/posts/web-object-concepte/", "categories": "Blogging, javaweb", "tags": "web", "date": "2020-09-09 19:25:00 +0800", "snippet": " VOVO（View Object）：视图对象，用于展示层，作用是把某个指定wb页面（或组件）的所有数据封装起来。 DTODTO（Data Transfer Object）：数据传输对象，这个概念来源于J2EE的设计模式，原来的目的是为了EJB的分布式应用提供粗粒度的数据实体，以减少分布式调用的次数，从而提高分布式调用的性能和降低网络负载。也可泛指为展示层与服务层之间的数据传输对象。 DODO（Domain Object）：领域对象，就是从现实世界中抽象出来的有形或无形的业务实体。 POPO（Persistent Object）：持久化对象，它跟持久层（通常是关系型数据库）的数据..." }, { "title": "Docker：一些练习", "url": "/HYCBlog/posts/web-docker_3/", "categories": "Blogging, docker", "tags": "web", "date": "2020-09-07 19:39:00 +0800", "snippet": " Docker 部署 Nginx#docker pull nginx# docker run -d --name nginx01 -p 2300:80 nginx #运行nginx，将容器的80端口映射到宿主机的2300端口3dc65265a4822ac3d635ad26d008521a4ab5b0d9aa9ec880f9cd4b6339a62d7c# curl localhost:2300 #测试&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html&amp;gt;&amp;lt;head&amp;gt;&amp;lt;title&amp;gt;Welco..." }, { "title": "Docker：入门", "url": "/HYCBlog/posts/web-docker_2/", "categories": "Blogging, docker", "tags": "web", "date": "2020-09-07 19:38:00 +0800", "snippet": "Docker安装 环境准备CentOS 7 环境查看#系统内核是 3.10以上的# uname -r3.10.0-514.26.2.el7.x86_64#系统版本# cat /etc/os-release NAME=&quot;CentOS Linux&quot;VERSION=&quot;7 (Core)&quot;ID=&quot;centos&quot;ID_LIKE=&quot;rhel fedora&quot;VERSION_ID=&quot;7&quot;PRETTY_NAME=&quot;CentOS Linux 7 (Core)&quot;ANSI_COLOR=&qu..." }, { "title": "Docker：概述", "url": "/HYCBlog/posts/web-docker_1/", "categories": "Blogging, docker", "tags": "web", "date": "2020-09-07 19:37:00 +0800", "snippet": " 核心思想：隔离。Docker 是一个开放源代码软件，是一个开放平台，用于开发应用、交付（shipping）应用、运行应用。 Docker允许用户将基础设施（Infrastructure）中的应用单独分割出来，形成更小的颗粒（容器），从而提高交付软件的速度。Docker容器与虚拟机类似，但二者在原理上不同。容器是将操作系统层虚拟化，虚拟机则是虚拟化硬件，因此容器更具有便携性、高效地利用服务器。 容器更多的用于表示 软件的一个标准化单元。由于容器的标准化，因此它可以无视基础设施（Infrastructure）的差异，部署到任何一个地方。另外，Docker也为容器提供更强的业界的隔离兼容。..." }, { "title": "数据库：脏读、幻读和不可重复读", "url": "/HYCBlog/posts/web-database-bad-Read/", "categories": "Blogging, database", "tags": "web", "date": "2020-09-06 09:36:00 +0800", "snippet": "数据库事务的特征 A Atomicity 原子性事务是一个原子性质的操作单元，事务里面对数据库的操作要么都执行，要么都不执行。 C Consistent 一致性在事务开始之前和完成之后，数据库都必须保持一致状态，必须保证数据库的完整性。拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。 I Isolation 隔离性数据库允许多个并发事务同时对数据进行操作，隔离性保证各个事务相互独立，一个事务处理的中间状态对其他事务是不可见的。 D Durable 持久性一个食物..." }, { "title": "Spring：声明式事务控制", "url": "/HYCBlog/posts/web-javaweb-spring_7/", "categories": "Blogging, javaweb", "tags": "web", "date": "2020-09-05 21:44:00 +0800", "snippet": "基于XML 配置事务管理器 配置事务的通知 此时需要导入事务的约束：tx和aop名称空间和约束 使用tx:advice标签配置事务通知 ​ 属性： ​ id：给事务通知起一个唯一标识 ​ transaction-manager：给事务通知提供一个事务管理器引用 配置AOP中的通用切入点表达式 建立事务通知和切入点表达式的对应关系 配置事务的属性 在事务的通知tx:advice标签内部配置 ​ isolation：指定事务的隔离级别，默认值为default，表示使用数据库的默认隔..." }, { "title": "Spring：Spring中的JdbcTemplate", "url": "/HYCBlog/posts/web-javaweb-spring_6/", "categories": "Blogging, javaweb", "tags": "web", "date": "2020-09-05 21:43:00 +0800", "snippet": "概述是Spring框架中提供的一个对象，是对原始Jdbc API对象的简单封装。Spring框架为我们提供了很多的操作模版类。* 操作关系型数据的： JdbcTemplate HibernateTemplate* 操作nosql数据库的： RedisTemplate* 操作消息队列的： JmsTemplateJdbcTemplate实现CRUD操作Account的封装策略Spring以帮我们写好BeanPropertyRowMapper&amp;lt;Account&amp;gt;(Account.class)，无需自己实现package com.yucaihuang.jdbcT..." }, { "title": "Spring：AOP（面向切面编程）", "url": "/HYCBlog/posts/web-javaweb-spring_5/", "categories": "Blogging, javaweb", "tags": "web", "date": "2020-09-05 21:42:00 +0800", "snippet": "AOP：Aspect Oriented Programming，意为面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发效率。简单的说，就是AOP把程序中重复的代码抽取出来，在需要执行的时候，使用动态代理的技术，在不修改源码的基础上，对已有的方法进行增强。事务控制下的转账功能实现定义和事物管理相关的工具类：/** * 和事务管理相关的工具类，它包含了：开启事务，提交事务，回滚事务和释放连接 */@Component(&quot;transacti..." }, { "title": "Spring：IOC（控制反转）", "url": "/HYCBlog/posts/web-javaweb-spring_4/", "categories": "Blogging, javaweb", "tags": "web", "date": "2020-09-05 21:41:00 +0800", "snippet": "IoC把创建对象的权利交给框架。它包括依赖注入（Dependency Injection）和依赖查找（Dependency Lookup）。作用：削减计算机程序的耦合（解除代码中的依赖关系）spring基于xml的IOC环境搭建和入门在pom.xml中导入坐标： &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-context&amp;l..." }, { "title": "Spring：工厂模式解耦", "url": "/HYCBlog/posts/web-javaweb-spring_3/", "categories": "Blogging, javaweb", "tags": "web", "date": "2020-09-05 21:40:00 +0800", "snippet": "问题代码IAccountDao.java:/** * 账户的持久层接口 */public interface IAccountDao { void saveAccount();}AccountDaoImpl.java:/** * 账户的持久层实现类 */public class AccountDaoImpl implements IAccountDao { public void saveAccount() { System.out.println(&quot;账户已保存&quot;); }}IAccountService.java:/** * 账户业务层..." }, { "title": "Spring：程序的耦合和解耦", "url": "/HYCBlog/posts/web-javaweb-spring_2/", "categories": "Blogging, javaweb", "tags": "web", "date": "2020-09-05 21:39:00 +0800", "snippet": "#package com.yucaihuang.jdbc;import java.sql.*;/** * 程序耦合 * 耦合：程序间的依赖关系，包括：类之间的依赖、方法间的依赖 * 解耦：降低程序间的依赖关系 * 实际开发中，应该做到：编译期不依赖，运行时才依赖 * 解耦的思路： * 第一步：使用反射来创建对象，而避免使用new关键字 * 第二步：通过读取配置文件，来获取要创建的对象的全限定类名 */public class JdbcDemo1 { public static void main(String[] args) throws SQLExce..." }, { "title": "Spring：概述", "url": "/HYCBlog/posts/web-javaweb-spring_1/", "categories": "Blogging, javaweb", "tags": "web", "date": "2020-09-05 21:38:00 +0800", "snippet": "Spring是分层的Java SE/EE应用full-stack轻量级开源框架，以IoC（Inverse Of Control: 反转控制）和AOP（Aspect Oriented Programming: 面向切面编程）为内核，提供了展现层Spring MVC和持久层Spring JDBC以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库。Spring的优势1. 方便接耦，简化开发2. AOP 编程的支持3. 声明式事务的支持4. 方便程序的测试5. 方便程序的测试6. 方便集成各种优秀框架7. 降低JavaEE API的使用难度8. 源码是经典学习范..." }, { "title": "Mybatis：mybatis注解开发", "url": "/HYCBlog/posts/web-javaweb-mybatis_11/", "categories": "Blogging, javaweb", "tags": "web", "date": "2020-09-04 19:27:00 +0800", "snippet": "环境搭建 定义实体类User.java 配置SqlMapConfig.xml文件，jdbcConfig.properties文件以及log4j.properties文件： jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/eesy_mybatisjdbc.username=rootjdbc.password=qazwsxedc7410 ### 设置###log4j.rootLogger = debug,CONSOLE,LOGFILE log4j.log..." }, { "title": "Mybatis：mybatis中的缓存", "url": "/HYCBlog/posts/web-javaweb-mybatis_10/", "categories": "Blogging, javaweb", "tags": "web", "date": "2020-09-04 19:26:00 +0800", "snippet": "Mybatis中的缓存一级缓存指的是mybatis中SqlSession对象的缓存。当我们执行查询之后，查询的结果会同时存入SqlSession为我们提供的一块区域中。该区域的结构是一个Map。当我们再次查询同样的数据，mybatis会先去sqlSession中查询是否命中，命中的话直接拿出来用。当SqlSession对象消失时，mybatis的一级缓存也就消失了。当调用sqlSession的修改，添加，删除，commit()，close()等方法时，就会清空一级缓存。二级缓存指的是Mybatis中SqlSeesionFactory对象的缓存。由同一个SqlSessionFactory对..." }, { "title": "Mybatis：延迟加载和立即加载", "url": "/HYCBlog/posts/web-javaweb-mybatis_9/", "categories": "Blogging, javaweb", "tags": "web", "date": "2020-09-04 19:25:00 +0800", "snippet": "延迟加载和立即加载问题：在一对多中，当我们有一个用户，它有100个账户。​ 在查询用户的时候，要不要把关联的账户查出来？​ 在查询用户时，用户下的账户信息应该是在需要被使用时，查询出来。​ 在查询账户的时候，要不要把关联的用户查出来？​ 在查询账户时，账户的所属用户信息应该一起被查询出来。延迟加载（一对多，多对多）在真正使用数据时，才发起查询，不用的时候不查询。按需加载（懒加载）在IUserDao.xml文件的resultMap属性中配置collection：&amp;lt;collection property=&quot;accounts&quot; ofType=&..." }, { "title": "Mybatis：一对一、一对多、多对多操作", "url": "/HYCBlog/posts/web-javaweb-mybatis_8/", "categories": "Blogging, javaweb", "tags": "web", "date": "2020-09-04 19:24:00 +0800", "snippet": "完成account的一对一操作通过写account的子类实现定义account子类：package com.hyc.domain;public class AccountUser extends Account{ private String username; private String address; public String getUsername() { return username; } public void setUsername(String username) { this.username = user..." }, { "title": "Mybatis：多表关联查询", "url": "/HYCBlog/posts/web-javaweb-mybatis_7/", "categories": "Blogging, javaweb", "tags": "web", "date": "2020-09-04 19:23:00 +0800", "snippet": "mybatis中的多表查询：表之间的关系有几种： 一对多 用户和订单就是一对多 多对一 订单和用户就是多对一 一对一 一个人只能有一个身份ID 多对多 一个学生可以对应多个老师，一个老师也可以对应多个学生 特例：如果拿出每一个订单，他都只能属于一个用户，所以mybatis就把多对一看成了一对一。示例：用户和账户步骤：1. 建立两张表：用户表，账户表 让用户表和账户表之间具备一对多的关系：需要使用外键再账户表中添加。2. 建立两个实体类：用户实体类和账户实体类 让用户和账户的实体类能体现出来一对多的关系3. 建立两个配置文件 用户的配置文件 账户的配置文件4. 实现配置 当我们查..." }, { "title": "Mybatis：映射文件的SQL深入", "url": "/HYCBlog/posts/web-javaweb-mybatis_6/", "categories": "Blogging, javaweb", "tags": "web", "date": "2020-09-04 19:22:00 +0800", "snippet": "mybatis中的动态sql语句if标签&amp;lt;select id=&quot;findUserByCondition&quot; parameterType=&quot;user&quot; resultType=&quot;user&quot;&amp;gt;-- 在sql语句里的内容不区分大小写，但是如果不属于sql语句的内容，就需要找实体类的属性名 select * from user where 1=1 &amp;lt;if test=&quot;username != null&quot;&amp;gt; ..." }, { "title": "Mybatis：连接池以及事务控制", "url": "/HYCBlog/posts/web-javaweb-mybatis_5/", "categories": "Blogging, javaweb", "tags": "web", "date": "2020-09-04 19:21:00 +0800", "snippet": "连接池概念连接池就是用于存储连接的一个容器，容器其实就是一个集合对象，该集合必须是线程安全的，不能两个线程拿到统一连接，集合必须实现队列的特性：先进先出。在实际开发中都会使用连接池，可以减少我们获取连接所消耗的时间。mybatis中的连接池mybatis连接池提供了3种方式的配置：配置的位置：主配置文件SqlMapConfig.xml中的dataSource标签，type属性就是表示采用何种连接池方式。type属性的取值：1. POOLED 采用传统的javax.sql.DataSource规范中的连接池 mybatis中有针对此规范的实现2. UNPOOLED 采用传统的获取连接的..." }, { "title": "Mybatis：Properties/TypeAliases/Package", "url": "/HYCBlog/posts/web-javaweb-mybatis_4/", "categories": "Blogging, javaweb", "tags": "web", "date": "2020-09-04 19:20:00 +0800", "snippet": "Properties配置properties可以在标签内部配置连接数据库的信息，也可以通过属性引用外部配置文件信息。在资源路径下新建外部配置文件jdbcConfig.properties:jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/eesy_mybatisjdbc.username=rootjdbc.password=qazwsxedc7410在SqlMapConfig.xml文件中配置properties标签：&amp;lt;configuration&amp;gt; &amp;lt;..." }, { "title": "Mybatis：CRUD", "url": "/HYCBlog/posts/web-javaweb-mybatis_3/", "categories": "Blogging, javaweb", "tags": "web", "date": "2020-09-04 19:19:00 +0800", "snippet": "保存操作在用户Dao接口中定义saveUser抽象方法，用于保存用户：package com.hyc.dao;import com.hyc.domain.User;import org.apache.ibatis.annotations.Select;import java.util.List;/** * 用户的持久层接口 */public interface IUserDao { /** * 查询所有操作 * @return */// @Select(&quot;select * from user&quot;)// List&amp;lt;U..." }, { "title": "Mybatis：入门", "url": "/HYCBlog/posts/web-javaweb-mybatis_2/", "categories": "Blogging, javaweb", "tags": "web", "date": "2020-09-04 19:18:00 +0800", "snippet": "入门案例public class MybatisTest { public static void main(String[] args) throws IOException { //1.读取配置文件 InputStream in = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;); //2.创建SqlSessionFactory工厂 SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuil..." }, { "title": "Mybatis：环境搭建", "url": "/HYCBlog/posts/web-javaweb-mybatis_1/", "categories": "Blogging, javaweb", "tags": "web", "date": "2020-09-04 19:17:00 +0800", "snippet": " 创建maven工程并导入坐标： &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.mybatis&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mybatis&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.4.6&amp;lt;/version&amp;gt; ..." }, { "title": "Manacher算法：线性时间内找到最大回文子串", "url": "/HYCBlog/posts/algorithm-manacher/", "categories": "Blogging, Algorithms", "tags": "Algorithms", "date": "2020-08-29 13:49:00 +0800", "snippet": "5.最长回文子串给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。示例 1：输入: &quot;babad&quot;输出: &quot;bab&quot;注意: &quot;aba&quot; 也是一个有效答案。示例 2：输入: &quot;cbbd&quot;输出: &quot;bb&quot;求解这个问题的方法有很多：动态规划、中心扩散、KMP等。今天主要分析Manacher算法。Manacher算法本质上还是中心扩散法，但是它使用了类似于KMP算法的技巧，可以减少重复判断。第一步：添加分隔符对原始字符串进行预处理，在首尾以及每个字符之间插入分..." }, { "title": "从算法到源码：PriorityQueue源码学习", "url": "/HYCBlog/posts/priority-queue-src-code-analyze/", "categories": "Blogging, 容器", "tags": "Java源码学习", "date": "2020-08-28 21:03:00 +0800", "snippet": "剑指 Offer 41. 数据流中的中位数如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。例如，[2,3,4] 的中位数是 3[2,3] 的中位数是 (2 + 3) / 2 = 2.5设计一个支持以下两种操作的数据结构： void addNum(int num) - 从数据流中添加一个整数到数据结构中。 double findMedian() - 返回目前所有元素的中位数。示例 1：输入：[&quot;MedianFinder&quot;,&quo..." }, { "title": "centOS误删系统自带python", "url": "/HYCBlog/posts/web-delete-system-python-in-centos/", "categories": "Blogging, web", "tags": "web", "date": "2020-08-26 21:14:00 +0800", "snippet": "解决centOS误删系统自带python后，yum不可用的问题前几天手贱，为了装python3把系统自带的2.7给删了，今天才发现yum用不了了…报如下错误：上网查了发现，是因为yum依赖了系统自带的python，于是我就去找了2.7.5的python包，安装了之后还是报上面的错…试着在2.7.5下import yum，发现不存在这个模块。所以只能去下载源码包安装了。第一步首先卸载python:rpm -qa|grep python|xargs rpm -e --allmatches --nodepswhereis python|xargs rm -fr再卸载yum:rpm -qa|gr..." }, { "title": "内网渗透：记一次局域网arp劫持测试", "url": "/HYCBlog/posts/security-arp-hijack/", "categories": "Blogging, kali内网渗透", "tags": "security", "date": "2020-08-25 20:40:00 +0800", "snippet": "攻击前准备： 一台Kali虚拟机作为attacker 一台win7虚拟机作为victim win7虚拟机开桥接模式，模拟以太网连接。 用到的主要命令： arpspoofdriftnet Step1：扫描局域网内主机netdiscover -r 192.168.199.0/24 #扫描范围观察结果，推断出网关IP为192.168.199.1，目标主机地址为192.168.199.169。具体如何推断出目标主机的IP，可以从电脑型号以及当前的活跃情况推断。其实大多数attacker不会在乎自己攻击的是哪个特定主机，会在能力范..." }, { "title": "2020秋招企业笔试题", "url": "/HYCBlog/posts/enterprise-test/", "categories": "Blogging, 企业笔试", "tags": "算法题解", "date": "2020-08-24 21:10:00 +0800", "snippet": "京东-2020-8-6统计在N到M之间的回文素数有多少个0&amp;lt;=N&amp;lt;M&amp;lt;=1000000把在N和M之间的数去掉一个数字后，是否还是回文素数？是的话统计它的总数解法import java.util.Scanner;public class Main { final static int maxn = 1000000 + 10; // 素数 static boolean[] isp = new boolean[maxn]; static int[] pow = new int[10]; static void init()..." }, { "title": "URL包含中文，请求资源404", "url": "/HYCBlog/posts/web-url-with-chinese-string/", "categories": "Blogging, web", "tags": "web", "date": "2020-08-24 15:40:00 +0800", "snippet": "在本地时，项目路径内，中文解析均正确。但是放到服务器上后，http请求解析出现乱码。如下：当url路径包含中文的时候，浏览器会自动采用UTF-8对路径进行编码，而服务器（本例中是tomcat，不同服务器的实际可能有差异，但原理差不多）默认是采用ISO-8859-1来对url路径进行解码，此时往往会出现404，如以上例子所述。所以需要在服务端的配置文件中指定编码： 在tomcat中配置，server.xml设置URIEncoding=”UTF-8” &amp;lt;Connector connectionTimeout=&quot;20000&quot; port=&quo..." }, { "title": "剑指offer题解", "url": "/HYCBlog/posts/point-to-offers/", "categories": "Blogging, 剑指offer", "tags": "算法题解", "date": "2020-08-24 15:00:00 +0800", "snippet": "剑指 Offer 03. 数组中重复的数字找出数组中重复的数字。在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。示例 1：输入：[2, 3, 1, 0, 2, 5, 3]输出：2 或 3 限制：2 &amp;lt;= n &amp;lt;= 100000###集合class Solution { public int findRepeatNumber(int[] nums) { Set&amp;lt;Integer&amp;gt; ..." } ]
