<!DOCTYPE html><html lang="en" > <!-- The Head v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Leetcode题解:Hot 100! | 黄玉才的博客</title><meta name="generator" content="Jekyll v4.1.1" /><meta property="og:title" content="Leetcode题解:Hot 100!" /><meta name="author" content="Kol Huang" /><meta property="og:locale" content="en_US" /><meta name="description" content="目录" /><meta property="og:description" content="目录" /><link rel="canonical" href="www.yucaihuang.com/HYCBlog/posts/leetcode-solution_hot_100/" /><meta property="og:url" content="www.yucaihuang.com/HYCBlog/posts/leetcode-solution_hot_100/" /><meta property="og:site_name" content="黄玉才的博客" /><meta property="og:image" content="www.yucaihuang.com/HYCBlog/HYCBlog/assets/img/leetcode/leetcode_cover.jpg" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2020-10-23T13:51:00+08:00" /><meta name="twitter:card" content="summary_large_image" /><meta property="twitter:image" content="www.yucaihuang.com/HYCBlog/HYCBlog/assets/img/leetcode/leetcode_cover.jpg" /><meta property="twitter:title" content="Leetcode题解:Hot 100!" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@Kol Huang" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"image":"www.yucaihuang.com/HYCBlog/HYCBlog/assets/img/leetcode/leetcode_cover.jpg","mainEntityOfPage":{"@type":"WebPage","@id":"www.yucaihuang.com/HYCBlog/posts/leetcode-solution_hot_100/"},"url":"www.yucaihuang.com/HYCBlog/posts/leetcode-solution_hot_100/","author":{"@type":"Person","name":"Kol Huang"},"description":"目录","dateModified":"2020-10-23T13:51:00+08:00","datePublished":"2020-10-23T13:51:00+08:00","headline":"Leetcode题解:Hot 100!","@type":"BlogPosting","@context":"https://schema.org"}</script> <!-- The Favicons for Web, Android, Microsoft, and iOS (iPhone and iPad) Apps Generated by: https://www.favicon-generator.org/ v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2019 Cotes Chung Published under the MIT license --><link rel="shortcut icon" href="/HYCBlog/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/HYCBlog/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/HYCBlog/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/HYCBlog/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/HYCBlog/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/HYCBlog/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/HYCBlog/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/HYCBlog/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/HYCBlog/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/HYCBlog/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/HYCBlog/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/HYCBlog/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/HYCBlog/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/HYCBlog/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/HYCBlog/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/HYCBlog/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/HYCBlog/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/HYCBlog/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/HYCBlog/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/HYCBlog/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="preload" as="style" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"> <!-- CSS selector for site. Chirpy v2.3 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT Licensed --><link rel="preload" as="style" href="/HYCBlog/assets/css/post.css"><link rel="stylesheet" href="/HYCBlog/assets/css/post.css"><link rel="preload" as="style" href="/HYCBlog/assets/css/lib/bootstrap-toc.min.css"><link rel="stylesheet" href="/HYCBlog/assets/css/lib/bootstrap-toc.min.css" /><link rel="preload" as="script" href="https://cdn.jsdelivr.net/npm/jquery@3.4.1" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"> <script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4.0.0/dist/js/bootstrap.min.js" async></script> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-176388509-1"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-176388509-1'); </script> <!-- JS selector for site. Chirpy v2.3 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT Licensed --> <script src="/HYCBlog/assets/js/post.min.js" async></script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" async></script> <script src="/HYCBlog/app.js" defer></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column"> <!-- The Side Bar v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><div id="nav-wrapper"><div id="profile-wrapper" class="d-flex flex-column"><div id="avatar" class="d-flex justify-content-center"> <a href="http://www.yucaihuang.com" alt="avatar"> <img src="/HYCBlog/assets/img/daliy/avatar.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="profile-text mt-3"><div class="site-title"> <a href="/HYCBlog/">黄玉才的博客</a></div><div class="site-subtitle font-italic">把开源的变成自己的，把自己的变成祖传的!</div></div></div><ul class="nav flex-column"><li class="nav-item d-flex justify-content-center "> <a href="/HYCBlog/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/HYCBlog/tabs/categories/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/HYCBlog/tabs/tags/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/HYCBlog/tabs/archives/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/HYCBlog/tabs/about/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></li></ul></div><div class="sidebar-bottom d-flex flex-wrap justify-content-around mt-4"> <span id="mode-toggle-wrapper"> <!-- Switch the mode between dark and light. v2.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <i class="mode-toggle fas fa-sun" dark-mode-invisible></i> <i class="mode-toggle fas fa-moon" light-mode-invisible></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.mode != null) { if (this.mode == ModeToggle.DARK_MODE) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.mode != null) { if (self.mode == ModeToggle.DARK_MODE) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightkMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightkMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span> <span class="icon-border"></span> <a href="https://github.com/KolinHuang" target="_blank"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/twitter_username" target="_blank"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:window.open('mailto:' + ['yc_huang97','163.com'].join('@'))" > <i class="fas fa-envelope"></i> </a></div></div><!-- The Top Bar v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/HYCBlog/"> Posts </a> </span> <span>Leetcode题解:Hot 100!</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"> <!-- Refactor the HTML structure. --> <!-- Suroundding the markdown table with '<div class="table-wrapper">. and '</div>' --> <!-- Fixed kramdown code highlight rendering: https://github.com/penibelst/jekyll-compress-html/issues/101 https://github.com/penibelst/jekyll-compress-html/issues/71#issuecomment-188144901 --><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Leetcode题解:Hot 100!</h1><div class="post-meta text-muted d-flex flex-column"><div> Posted <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Fri, Oct 23, 2020, 1:51 PM +0800" > Oct 23 <i class="unloaded">2020-10-23T13:51:00+08:00</i> </span> by <span class="author"> Kol Huang</div><div> Updated <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Tue, Nov 3, 2020, 2:11 PM +0800" > Nov 3 <i class="unloaded">2020-11-03T14:11:48+08:00</i> </span></div></div><div class="post-content"> <img src="/HYCBlog/assets/img/leetcode/leetcode_cover.jpg" class="post-preview-img"><h2 id="目录">目录</h2><p><a href="#jump1">1.两数之和</a></p><p><a href="#jump2">2.两数相加</a></p><p><a href="#jump5">5.最长回文子串</a></p><p><a href="#jump17">17.电话号码的字母组合</a></p><p><a href="#jump19">19.删除链表的倒数第N个节点</a></p><p><a href="#jump20">20.有效的括号</a></p><p><a href="#jump33">33.搜索旋转排序数组</a></p><p><a href="#jump39">39.组合总和</a></p><p><a href="#jump48">48.旋转图像</a></p><p><a href="jump62">62.不同路径</a></p><p><a href="jump75">75.颜色分类</a></p><p><a href="jump78">78.子集</a></p><p><a href="#jump79">79.单词搜索</a></p><p><a href="#jump94">94.二叉树的中序遍历</a></p><p><a href="#jump96">96. 不同的二叉搜索树</a></p><p><a href="#jump98">98.验证二叉搜索树</a></p><p><a href="#jump101">101.对称二叉树</a></p><p><a href="#jump136">136.只出现一次的数字</a></p><p><a href="#jump141">141.环形链表</a></p><p><a href="#jump142">142.环形链表II</a></p><p><a href="#jump148">148.排序链表</a></p><p><a href="#jump215">215.数组中的第k大元素</a></p><p><a href="#jump226">226.翻转二叉树</a></p><p><a href="jump234">234.回文链表</a></p><p><a href="#jump239">239.滑动窗口最大值</a></p><p><a href="#jump240">240.搜索二维矩阵 II</a></p><p><a href="#jump309">309.最佳买卖股票时机含冷冻期</a></p><p><a href="#jump337">337. 打家劫舍 3</a></p><p><a href="#jump347">347.前 K 个高频元素</a></p><p><a href="#jump406">406.根据身高重建队列</a></p><p><a href="jump416">416.分割等和子集</a></p><p><a href="jump494">494.目标和</a></p><p><a href="#jump538">538.把二叉搜索树转换为累加树</a></p><p><a href="#jump560">560.和为K的子数组</a></p><p><a href="#jump581">581.最短无序连续子数组</a></p><p><a href="#jump617">617.合并二叉树</a></p><p><a href="#jump621">621.任务调度器</a></p><p><a href="#jump647">647.回文子串</a></p><p><span id="jump1"></span></p><h2 id="1两数之和">1.两数之和</h2><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p><p>示例:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">给定</span> <span class="n">nums</span> <span class="o">=</span> <span class="o">[</span><span class="mi">2</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">11</span><span class="o">,</span> <span class="mi">15</span><span class="o">],</span> <span class="n">target</span> <span class="o">=</span> <span class="mi">9</span>

<span class="n">因为</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">7</span> <span class="o">=</span> <span class="mi">9</span>
<span class="n">所以返回</span> <span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">]</span>
</pre></table></code></div></div><p>哈希法</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">twoSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>

        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">hashTable</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>

        <span class="c1">//遍历每个nums[i]</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="c1">//查询哈希表中是否存在target-nums[i]项，如果存在就找到了答案</span>
            <span class="k">if</span><span class="o">(</span><span class="n">hashTable</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">target</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">])){</span>
                <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">hashTable</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">target</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]),</span><span class="n">i</span><span class="o">};</span>
            <span class="o">}</span>
            <span class="c1">//否则将nums[i]放入哈希表</span>
            <span class="n">hashTable</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span><span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="2两数相加">2.两数相加</h2><p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p><p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p><p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p>示例：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="o">(</span><span class="mi">2</span> <span class="o">-&gt;</span> <span class="mi">4</span> <span class="o">-&gt;</span> <span class="mi">3</span><span class="o">)</span> <span class="o">+</span> <span class="o">(</span><span class="mi">5</span> <span class="o">-&gt;</span> <span class="mi">6</span> <span class="o">-&gt;</span> <span class="mi">4</span><span class="o">)</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">7</span> <span class="o">-&gt;</span> <span class="mi">0</span> <span class="o">-&gt;</span> <span class="mi">8</span>
<span class="n">原因</span><span class="err">：</span><span class="mi">342</span> <span class="o">+</span> <span class="mi">465</span> <span class="o">=</span> <span class="mi">807</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">addTwoNumbers</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">l1</span><span class="o">,</span> <span class="nc">ListNode</span> <span class="n">l2</span><span class="o">)</span> <span class="o">{</span>
    
        <span class="kt">int</span> <span class="n">carry</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="nc">ListNode</span> <span class="n">head</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
        <span class="nc">ListNode</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>

        <span class="c1">//当两个链表都还没到尾部时，按位相加</span>
        <span class="k">while</span><span class="o">(</span><span class="n">l1</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">l2</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="nc">ListNode</span> <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">();</span>
            <span class="c1">//有进位</span>
            <span class="k">if</span><span class="o">(</span><span class="n">l1</span><span class="o">.</span><span class="na">val</span> <span class="o">+</span> <span class="n">l2</span><span class="o">.</span><span class="na">val</span> <span class="o">+</span> <span class="n">carry</span> <span class="o">&gt;</span> <span class="mi">9</span><span class="o">){</span>
                <span class="n">node</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">l1</span><span class="o">.</span><span class="na">val</span> <span class="o">+</span> <span class="n">l2</span><span class="o">.</span><span class="na">val</span> <span class="o">+</span> <span class="n">carry</span> <span class="o">-</span> <span class="mi">10</span><span class="o">;</span>
                <span class="n">carry</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="c1">//无进位</span>
                <span class="n">node</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">l1</span><span class="o">.</span><span class="na">val</span> <span class="o">+</span> <span class="n">l2</span><span class="o">.</span><span class="na">val</span> <span class="o">+</span> <span class="n">carry</span><span class="o">;</span>
                <span class="n">carry</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">cur</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">l1</span> <span class="o">=</span> <span class="n">l1</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">l2</span> <span class="o">=</span> <span class="n">l2</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">//当l1还有剩余的位时</span>
        <span class="k">while</span><span class="o">(</span><span class="n">l1</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="nc">ListNode</span> <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">();</span>
            <span class="c1">//如果有进位</span>
            <span class="k">if</span><span class="o">(</span><span class="n">carry</span> <span class="o">==</span> <span class="mi">1</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">l1</span><span class="o">.</span><span class="na">val</span> <span class="o">+</span> <span class="n">carry</span> <span class="o">&gt;</span> <span class="mi">9</span><span class="o">){</span>
                    
                    <span class="n">node</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
                    <span class="n">carry</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
                <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                    
                    <span class="n">node</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">l1</span><span class="o">.</span><span class="na">val</span> <span class="o">+</span> <span class="n">carry</span><span class="o">;</span>
                    <span class="n">carry</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="c1">//如果没有进位</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="n">node</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">l1</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">cur</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">l1</span> <span class="o">=</span> <span class="n">l1</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">//同样处理l2</span>
        <span class="k">while</span><span class="o">(</span><span class="n">l2</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="nc">ListNode</span> <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">();</span>
            <span class="k">if</span><span class="o">(</span><span class="n">carry</span> <span class="o">==</span> <span class="mi">1</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">l2</span><span class="o">.</span><span class="na">val</span> <span class="o">+</span> <span class="n">carry</span> <span class="o">&gt;</span> <span class="mi">9</span><span class="o">){</span>
                    
                    <span class="n">node</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
                    <span class="n">carry</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
                <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                    
                    <span class="n">node</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">l2</span><span class="o">.</span><span class="na">val</span> <span class="o">+</span> <span class="n">carry</span><span class="o">;</span>
                    <span class="n">carry</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="k">else</span><span class="o">{</span>
                <span class="n">node</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">l2</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">cur</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">l2</span> <span class="o">=</span> <span class="n">l2</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">//最后还有一个进位，就增加一个节点，值为1</span>
        <span class="k">if</span><span class="o">(</span><span class="n">carry</span> <span class="o">==</span> <span class="mi">1</span><span class="o">){</span>
            <span class="nc">ListNode</span> <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
            <span class="n">cur</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>


    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>官方的简便写法：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">addTwoNumbers</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">l1</span><span class="o">,</span> <span class="nc">ListNode</span> <span class="n">l2</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ListNode</span> <span class="n">head</span> <span class="o">=</span> <span class="kc">null</span><span class="o">,</span> <span class="n">tail</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">carry</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">l1</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">l2</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">n1</span> <span class="o">=</span> <span class="n">l1</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">?</span> <span class="n">l1</span><span class="o">.</span><span class="na">val</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
            <span class="kt">int</span> <span class="n">n2</span> <span class="o">=</span> <span class="n">l2</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">?</span> <span class="n">l2</span><span class="o">.</span><span class="na">val</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
            <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">n1</span> <span class="o">+</span> <span class="n">n2</span> <span class="o">+</span> <span class="n">carry</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">head</span> <span class="o">=</span> <span class="n">tail</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="n">sum</span> <span class="o">%</span> <span class="mi">10</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">tail</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="n">sum</span> <span class="o">%</span> <span class="mi">10</span><span class="o">);</span>
                <span class="n">tail</span> <span class="o">=</span> <span class="n">tail</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">carry</span> <span class="o">=</span> <span class="n">sum</span> <span class="o">/</span> <span class="mi">10</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">l1</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">l1</span> <span class="o">=</span> <span class="n">l1</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">l2</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">l2</span> <span class="o">=</span> <span class="n">l2</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">carry</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">tail</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="n">carry</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">head</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump5"></span></p><h2 id="5最长回文子串">5.最长回文子串</h2><p><a href="HYCBlog/posts/algorithm-manacher">点这里跳转</a></p><p><span id="jump17"></span></p><h2 id="17电话号码的字母组合">17.电话号码的字母组合</h2><p>给定一个仅包含数字 <code class="language-plaintext highlighter-rouge">2-9</code> 的字符串，返回所有它能表示的字母组合。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p>示例:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="s">"23"</span>
<span class="n">输出</span><span class="err">：</span><span class="o">[</span><span class="s">"ad"</span><span class="o">,</span> <span class="s">"ae"</span><span class="o">,</span> <span class="s">"af"</span><span class="o">,</span> <span class="s">"bd"</span><span class="o">,</span> <span class="s">"be"</span><span class="o">,</span> <span class="s">"bf"</span><span class="o">,</span> <span class="s">"cd"</span><span class="o">,</span> <span class="s">"ce"</span><span class="o">,</span> <span class="s">"cf"</span><span class="o">].</span>
</pre></table></code></div></div><p>说明: 尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。</p><h3 id="回溯法">回溯法</h3><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
    <span class="nc">String</span> <span class="n">s</span><span class="o">;</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">res</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="nf">letterCombinations</span><span class="o">(</span><span class="nc">String</span> <span class="n">digits</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">digits</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>    <span class="k">return</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="c1">//先建立数字和字符串的映射关系</span>
        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span><span class="s">"abc"</span><span class="o">);</span>
        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span><span class="s">"def"</span><span class="o">);</span>
        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span><span class="s">"ghi"</span><span class="o">);</span>
        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span><span class="s">"jkl"</span><span class="o">);</span>
        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="mi">6</span><span class="o">,</span><span class="s">"mno"</span><span class="o">);</span>
        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="mi">7</span><span class="o">,</span><span class="s">"pqrs"</span><span class="o">);</span>
        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="mi">8</span><span class="o">,</span><span class="s">"tuv"</span><span class="o">);</span>
        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="mi">9</span><span class="o">,</span><span class="s">"wxyz"</span><span class="o">);</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">digits</span><span class="o">;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="c1">//取出第一个数字对应的字符串</span>
        <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'0'</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">num</span><span class="o">);</span>
        <span class="c1">//以字符串的第i位字符作为根节点，开始回溯</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s1</span><span class="o">.</span><span class="na">length</span><span class="o">();++</span><span class="n">i</span><span class="o">){</span>
            <span class="nc">StringBuffer</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuffer</span><span class="o">();</span>
            <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">s1</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
            <span class="n">backtrack</span><span class="o">(</span><span class="n">sb</span><span class="o">,</span><span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">backtrack</span><span class="o">(</span><span class="nc">StringBuffer</span> <span class="n">sb</span><span class="o">,</span> <span class="kt">int</span> <span class="n">cur</span><span class="o">){</span>
        <span class="c1">//若已访问到根节点，就将这个字符串记录到res中</span>
        <span class="k">if</span><span class="o">(</span><span class="n">sb</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">())</span>
            <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">cur</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'0'</span><span class="o">;</span>
            <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">num</span><span class="o">);</span>
            <span class="c1">//回溯</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">s1</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">s1</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">));</span>
                <span class="n">backtrack</span><span class="o">(</span><span class="n">sb</span><span class="o">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>
                <span class="n">sb</span><span class="o">.</span><span class="na">delete</span><span class="o">(</span><span class="n">sb</span><span class="o">.</span><span class="na">length</span><span class="o">()-</span><span class="mi">1</span><span class="o">,</span><span class="n">sb</span><span class="o">.</span><span class="na">length</span><span class="o">());</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump19"></span></p><h2 id="19删除链表的倒数第n个节点">19.删除链表的倒数第N个节点</h2><p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p><p>示例：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nl">给定一个链表:</span> <span class="mi">1</span><span class="o">-&gt;</span><span class="mi">2</span><span class="o">-&gt;</span><span class="mi">3</span><span class="o">-&gt;</span><span class="mi">4</span><span class="o">-&gt;</span><span class="mi">5</span><span class="o">,</span> <span class="n">和</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">2</span><span class="o">.</span>

<span class="n">当删除了倒数第二个节点后</span><span class="err">，</span><span class="n">链表变为</span> <span class="mi">1</span><span class="o">-&gt;</span><span class="mi">2</span><span class="o">-&gt;</span><span class="mi">3</span><span class="o">-&gt;</span><span class="mi">5</span><span class="o">.</span>
</pre></table></code></div></div><p>说明：</p><ul><li>给定的 n 保证是有效的。</li></ul><p>进阶：</p><ul><li>你能尝试使用一趟扫描实现吗？</li></ul><p>双指针移动，先让一个指针移动n位，再让两个指针同时移动，这样当后一个指针到头时，前一个指针就指向倒数第n个节点。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">removeNthFromEnd</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>  <span class="k">return</span> <span class="n">head</span><span class="o">;</span>
      	<span class="c1">//用一个伪头节点降低代码复杂度</span>
        <span class="nc">ListNode</span> <span class="n">fake_head</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(-</span><span class="mi">1</span><span class="o">);</span>
        <span class="n">fake_head</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
      	<span class="c1">//指向需要被删除节点的前一个节点</span>
        <span class="nc">ListNode</span> <span class="n">pre</span> <span class="o">=</span> <span class="n">fake_head</span><span class="o">;</span>
      	<span class="c1">//指向需要被删除的节点</span>
        <span class="nc">ListNode</span> <span class="n">left</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="nc">ListNode</span> <span class="n">right</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">n</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">){</span>
              	<span class="c1">//先让right指针移动n位</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">right</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                <span class="n">n</span><span class="o">--;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="n">pre</span> <span class="o">=</span> <span class="n">pre</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">right</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
      	<span class="c1">//删除节点</span>
        <span class="n">pre</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
      	<span class="c1">//help GC </span>
        <span class="n">left</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">fake_head</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump20"></span></p><h2 id="20有效的括号">20.有效的括号</h2><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p><p>有效字符串需满足：</p><p>左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。</p><p>示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="s">"()"</span>
<span class="nl">输出:</span> <span class="kc">true</span>
</pre></table></code></div></div><p>示例 2:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="s">"()[]{}"</span>
<span class="nl">输出:</span> <span class="kc">true</span>
</pre></table></code></div></div><p>示例 3:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="s">"(]"</span>
<span class="nl">输出:</span> <span class="kc">false</span>
</pre></table></code></div></div><p>示例 4:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="s">"([)]"</span>
<span class="nl">输出:</span> <span class="kc">false</span>
</pre></table></code></div></div><p>示例 5:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="s">"{[]}"</span>
<span class="nl">输出:</span> <span class="kc">true</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isValid</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>

        <span class="k">if</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>

        <span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Stack</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="sc">'('</span> <span class="o">||</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="sc">'{'</span> <span class="o">||</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="sc">'['</span><span class="o">)</span>
                <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
            <span class="k">else</span><span class="o">{</span>
                <span class="k">if</span><span class="o">(</span><span class="n">stack</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
                    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
                <span class="nc">Character</span> <span class="n">c</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
                <span class="k">if</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="sc">')'</span> <span class="o">&amp;&amp;</span> <span class="n">c</span> <span class="o">!=</span> <span class="sc">'('</span><span class="o">)</span>
                    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
                <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="sc">'}'</span> <span class="o">&amp;&amp;</span> <span class="n">c</span> <span class="o">!=</span> <span class="sc">'{'</span><span class="o">)</span>
                    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
                <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="sc">']'</span> <span class="o">&amp;&amp;</span> <span class="n">c</span> <span class="o">!=</span> <span class="sc">'['</span><span class="o">)</span>
                    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">stack</span><span class="o">.</span><span class="na">size</span><span class="o">()==</span><span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump33"></span></p><h2 id="33搜索旋转排序数组">33.搜索旋转排序数组</h2><p>给你一个升序排列的整数数组 nums ，和一个整数 target 。</p><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。（例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] ）。</p><p>请你在数组中搜索 target ，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。</p><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">nums</span> <span class="o">=</span> <span class="o">[</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">],</span> <span class="n">target</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">4</span>
</pre></table></code></div></div><p>示例 2：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">nums</span> <span class="o">=</span> <span class="o">[</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">],</span> <span class="n">target</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">输出</span><span class="err">：</span><span class="o">-</span><span class="mi">1</span>
</pre></table></code></div></div><p>示例 3：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">nums</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">],</span> <span class="n">target</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">输出</span><span class="err">：</span><span class="o">-</span><span class="mi">1</span>
</pre></table></code></div></div><p>提示：</p><ul><li>1 &lt;= nums.length &lt;= 5000</li><li>-10^4 &lt;= nums[i] &lt;= 10^4</li><li>nums 中的每个值都 独一无二</li><li>nums 肯定会在某个点上旋转</li><li>-10^4 &lt;= target &lt;= 10^4</li></ul><p>二分法，判断target和nums[mid]在分段函数的位置来更新l和r指针。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">search</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">l</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="o">(</span><span class="n">r</span> <span class="o">-</span> <span class="n">l</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">l</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">==</span> <span class="n">target</span><span class="o">)</span> <span class="k">return</span> <span class="n">mid</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="o">){</span>
              	<span class="c1">//二者都在左分段</span>
                <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">]){</span>
                    <span class="n">l</span> <span class="o">=</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
                <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                  	<span class="c1">//二者都在右分段</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">target</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">]){</span>
                        <span class="n">l</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>    
                    <span class="c1">//mid在右分段，target在左分段</span>
                    <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                        <span class="n">r</span> <span class="o">=</span> <span class="n">mid</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]){</span>
                    <span class="n">r</span> <span class="o">=</span> <span class="n">mid</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>
                <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">target</span> <span class="o">&gt;=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">]){</span>
                        <span class="n">r</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
                    <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                        <span class="n">l</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump39"></span></p><h2 id="39组合总和">39.组合总和</h2><p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p><p>candidates 中的数字可以无限制重复被选取。</p><p>说明：</p><ul><li><p>所有数字（包括 target）都是正整数。</p></li><li><p>解集不能包含重复的组合。</p></li></ul><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">candidates</span> <span class="o">=</span> <span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">7</span><span class="o">],</span> <span class="n">target</span> <span class="o">=</span> <span class="mi">7</span><span class="o">,</span>
<span class="n">所求解集为</span><span class="err">：</span>
<span class="o">[</span>
  <span class="o">[</span><span class="mi">7</span><span class="o">],</span>
  <span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span>
<span class="o">]</span>
</pre></table></code></div></div><p>示例 2：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">candidates</span> <span class="o">=</span> <span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">5</span><span class="o">],</span> <span class="n">target</span> <span class="o">=</span> <span class="mi">8</span><span class="o">,</span>
<span class="n">所求解集为</span><span class="err">：</span>
<span class="o">[</span>
  <span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">],</span>
  <span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">3</span><span class="o">],</span>
  <span class="o">[</span><span class="mi">3</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span>
<span class="o">]</span>
</pre></table></code></div></div><h3 id="回溯">回溯</h3><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">target</span><span class="o">;</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">res</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">combinationSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">candidates</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">if</span><span class="o">(</span><span class="n">candidates</span><span class="o">.</span><span class="na">length</span><span class="o">==</span><span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">target</span> <span class="o">=</span> <span class="n">target</span><span class="o">;</span>
        <span class="n">dfs</span><span class="o">(</span><span class="n">candidates</span><span class="o">,</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(),</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">candidates</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">,</span> <span class="kt">int</span> <span class="n">sum</span><span class="o">,</span><span class="kt">int</span> <span class="n">cur</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">sum</span> <span class="o">&gt;</span> <span class="n">target</span><span class="o">){</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span><span class="o">(</span><span class="n">sum</span> <span class="o">==</span> <span class="n">target</span><span class="o">){</span>
            <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">ans</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(</span><span class="n">list</span><span class="o">);</span>
            <span class="k">if</span><span class="o">(!</span><span class="n">res</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">ans</span><span class="o">))</span>
                <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">ans</span><span class="o">);</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">cur</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">candidates</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">candidates</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="n">dfs</span><span class="o">(</span><span class="n">candidates</span><span class="o">,</span><span class="n">list</span><span class="o">,</span><span class="n">sum</span> <span class="o">+</span> <span class="n">candidates</span><span class="o">[</span><span class="n">i</span><span class="o">],</span><span class="n">i</span><span class="o">);</span>
            <span class="n">list</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">()-</span><span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump48"></span></p><h2 id="48旋转图像">48.旋转图像</h2><p>给定一个 n × n 的二维矩阵表示一个图像。</p><p>将图像顺时针旋转 90 度。</p><p>说明：</p><p>你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。</p><p>示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="n">给定</span> <span class="n">matrix</span> <span class="o">=</span> 
<span class="o">[</span>
  <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">],</span>
  <span class="o">[</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">],</span>
  <span class="o">[</span><span class="mi">7</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="mi">9</span><span class="o">]</span>
<span class="o">],</span>

<span class="n">原地旋转输入矩阵</span><span class="err">，</span><span class="nl">使其变为:</span>
<span class="o">[</span>
  <span class="o">[</span><span class="mi">7</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">1</span><span class="o">],</span>
  <span class="o">[</span><span class="mi">8</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">2</span><span class="o">],</span>
  <span class="o">[</span><span class="mi">9</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span>
<span class="o">]</span>
</pre></table></code></div></div><p>示例 2:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="n">给定</span> <span class="n">matrix</span> <span class="o">=</span>
<span class="o">[</span>
  <span class="o">[</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span><span class="mi">11</span><span class="o">],</span>
  <span class="o">[</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span><span class="mi">10</span><span class="o">],</span>
  <span class="o">[</span><span class="mi">13</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">],</span>
  <span class="o">[</span><span class="mi">15</span><span class="o">,</span><span class="mi">14</span><span class="o">,</span><span class="mi">12</span><span class="o">,</span><span class="mi">16</span><span class="o">]</span>
<span class="o">],</span> 

<span class="n">原地旋转输入矩阵</span><span class="err">，</span><span class="nl">使其变为:</span>
<span class="o">[</span>
  <span class="o">[</span><span class="mi">15</span><span class="o">,</span><span class="mi">13</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">5</span><span class="o">],</span>
  <span class="o">[</span><span class="mi">14</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">1</span><span class="o">],</span>
  <span class="o">[</span><span class="mi">12</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">9</span><span class="o">],</span>
  <span class="o">[</span><span class="mi">16</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span><span class="mi">10</span><span class="o">,</span><span class="mi">11</span><span class="o">]</span>
<span class="o">]</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">rotate</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">matrix</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//先转置，再按列交换</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>
                <span class="n">matrix</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">[</span><span class="n">j</span><span class="o">][</span><span class="n">i</span><span class="o">];</span>
                <span class="n">matrix</span><span class="o">[</span><span class="n">j</span><span class="o">][</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>
                <span class="n">matrix</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">n</span> <span class="o">-</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>
                <span class="n">matrix</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">n</span> <span class="o">-</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump62"></span></p><h2 id="62不同路径">62.不同路径</h2><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>问总共有多少条不同的路径？</p><p>示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">3</span><span class="o">,</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">2</span>
<span class="nl">输出:</span> <span class="mi">3</span>
<span class="nl">解释:</span>
<span class="n">从左上角开始</span><span class="err">，</span><span class="n">总共有</span> <span class="mi">3</span> <span class="n">条路径可以到达右下角</span><span class="err">。</span>

<span class="mi">1</span><span class="o">.</span> <span class="n">向右</span> <span class="o">-&gt;</span> <span class="n">向右</span> <span class="o">-&gt;</span> <span class="n">向下</span>
<span class="mi">2</span><span class="o">.</span> <span class="n">向右</span> <span class="o">-&gt;</span> <span class="n">向下</span> <span class="o">-&gt;</span> <span class="n">向右</span>
<span class="mi">3</span><span class="o">.</span> <span class="n">向下</span> <span class="o">-&gt;</span> <span class="n">向右</span> <span class="o">-&gt;</span> <span class="n">向右</span>
</pre></table></code></div></div><p>示例 2:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">7</span><span class="o">,</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">3</span>
<span class="nl">输出:</span> <span class="mi">28</span>
</pre></table></code></div></div><p>提示：</p><ul><li>1 &lt;= m, n &lt;= 100</li><li>题目数据保证答案小于等于 2 * 10 ^ 9</li></ul><p>简单的动态规划</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">uniquePaths</span><span class="o">(</span><span class="kt">int</span> <span class="n">m</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//dp[i][j]表示，走到第(i,j)个网格有几种方法</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
      
        <span class="c1">//初始条件</span>
        <span class="c1">//当j = 1时，只能由dp[i-1][j]向下走一步而来</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
            <span class="n">dp</span><span class="o">[</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">//当i = 1时，只能由dp[i][j-1]向右走一步而来</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">//dp[i][j]的值可能由dp[i-1][j]向下走一步，或者dp[i][j-1]向右走一步而来</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">+</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">m</span><span class="o">][</span><span class="n">n</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump75"></span></p><h2 id="75颜色分类">75.颜色分类</h2><p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p><p>注意: 不能使用代码库中的排序函数来解决这道题。</p><p>示例:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">]</span>
<span class="nl">输出:</span> <span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">]</span>
</pre></table></code></div></div><p>进阶：</p><ul><li>一个直观的解决方案是使用计数排序的两趟扫描算法。 首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。</li><li>你能想出一个仅使用常数空间的一趟扫描算法吗？</li></ul><p>计数排序</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">sortColors</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>    <span class="n">a</span><span class="o">++;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>    <span class="n">b</span><span class="o">++;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="mi">2</span><span class="o">)</span>    <span class="n">c</span><span class="o">++;</span>
        <span class="o">}</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">a</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">){</span>
                <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
                <span class="n">a</span><span class="o">--;</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">b</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">){</span>
                <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
                <span class="n">b</span><span class="o">--;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
                <span class="n">c</span><span class="o">--;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>    
<span class="o">}</span>
</pre></table></code></div></div><p>一趟partition，把0都放到左边，1都放到右边，数字2放完之后，这个位置还需要被遍历一次，所以<code class="language-plaintext highlighter-rouge">i--</code>。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">sortColors</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">low</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">high</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">low</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">high</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
                <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">low</span><span class="o">];</span>
                <span class="n">nums</span><span class="o">[</span><span class="n">low</span><span class="o">++]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
                <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="mi">2</span><span class="o">){</span>
                  	<span class="c1">//交换过来的数字不确定，所以需要再判断一次这个位置</span>
                    <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">--]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">high</span><span class="o">];</span>
                    <span class="n">nums</span><span class="o">[</span><span class="n">high</span><span class="o">--]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>   
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump78"></span></p><h2 id="78子集">78.子集</h2><p>给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</p><p>说明：解集不能包含重复的子集。</p><p>示例:</p><p>输入: nums = [1,2,3] 输出:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="o">[</span>
  <span class="o">[</span><span class="mi">3</span><span class="o">],</span>
  <span class="o">[</span><span class="mi">1</span><span class="o">],</span>
  <span class="o">[</span><span class="mi">2</span><span class="o">],</span>
  <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">],</span>
  <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">],</span>
  <span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">],</span>
  <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">],</span>
  <span class="o">[]</span>
<span class="o">]</span>
</pre></table></code></div></div><p>回溯的典型题。只需要遍历所有长度的子集，然后回溯长度为<code class="language-plaintext highlighter-rouge">len</code>的子集的所有可能性即可。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>

    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">res</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">subsets</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="c1">//控制子集的长度</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">len</span> <span class="o">&lt;=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">len</span><span class="o">){</span>
            <span class="n">dfs</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span><span class="n">len</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;());</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>


    <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span><span class="kt">int</span> <span class="n">len</span><span class="o">,</span> <span class="kt">int</span> <span class="n">cur</span><span class="o">,</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">cur</span> <span class="o">==</span> <span class="n">len</span><span class="o">){</span>
            <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(</span><span class="n">list</span><span class="o">));</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">//回溯添加长度为len的子集</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">cur</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="n">dfs</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span><span class="n">len</span><span class="o">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span><span class="n">list</span><span class="o">);</span>
            <span class="n">list</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">()-</span><span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump79"></span></p><h2 id="79单词搜索">79.单词搜索</h2><p>给定一个二维网格和一个单词，找出该单词是否存在于网格中。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><p>示例:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="n">board</span> <span class="o">=</span>
<span class="o">[</span>
  <span class="o">[</span><span class="sc">'A'</span><span class="o">,</span><span class="sc">'B'</span><span class="o">,</span><span class="sc">'C'</span><span class="o">,</span><span class="sc">'E'</span><span class="o">],</span>
  <span class="o">[</span><span class="sc">'S'</span><span class="o">,</span><span class="sc">'F'</span><span class="o">,</span><span class="sc">'C'</span><span class="o">,</span><span class="sc">'S'</span><span class="o">],</span>
  <span class="o">[</span><span class="sc">'A'</span><span class="o">,</span><span class="sc">'D'</span><span class="o">,</span><span class="sc">'E'</span><span class="o">,</span><span class="sc">'E'</span><span class="o">]</span>
<span class="o">]</span>

<span class="n">给定</span> <span class="n">word</span> <span class="o">=</span> <span class="s">"ABCCED"</span><span class="o">,</span> <span class="n">返回</span> <span class="kc">true</span>
<span class="n">给定</span> <span class="n">word</span> <span class="o">=</span> <span class="s">"SEE"</span><span class="o">,</span> <span class="n">返回</span> <span class="kc">true</span>
<span class="n">给定</span> <span class="n">word</span> <span class="o">=</span> <span class="s">"ABCB"</span><span class="o">,</span> <span class="n">返回</span> <span class="kc">false</span>
</pre></table></code></div></div><p>提示：</p><ul><li>board 和 word 中只包含大写和小写英文字母。</li><li>1 &lt;= board.length &lt;= 200</li><li>1 &lt;= board[i].length &lt;= 200</li><li>1 &lt;= word.length &lt;= 10^3</li></ul><p>深搜</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="c1">//boolean flag;</span>
    <span class="kt">boolean</span><span class="o">[][]</span> <span class="n">visited</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">exist</span><span class="o">(</span><span class="kt">char</span><span class="o">[][]</span> <span class="n">board</span><span class="o">,</span> <span class="nc">String</span> <span class="n">word</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">board</span><span class="o">.</span><span class="na">length</span><span class="o">][</span><span class="n">board</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">board</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">board</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">board</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="n">word</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="mi">0</span><span class="o">)){</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">dfs</span><span class="o">(</span><span class="n">board</span><span class="o">,</span><span class="n">i</span><span class="o">,</span><span class="n">j</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="n">word</span><span class="o">)){</span>
                        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
                    <span class="o">}</span>
                  <span class="c1">//if(flag)	return true;</span>
                <span class="o">}</span>
                    
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kt">boolean</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">char</span><span class="o">[][]</span> <span class="n">board</span><span class="o">,</span> <span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">,</span> <span class="kt">int</span> <span class="n">cur</span> <span class="o">,</span><span class="nc">String</span> <span class="n">word</span><span class="o">){</span>
        <span class="c1">//</span>
        <span class="k">if</span><span class="o">(</span><span class="n">board</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]</span> <span class="o">!=</span> <span class="n">word</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">cur</span><span class="o">)){</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span><span class="o">(</span><span class="n">cur</span> <span class="o">==</span> <span class="n">word</span><span class="o">.</span><span class="na">length</span><span class="o">()-</span><span class="mi">1</span><span class="o">){</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
          	<span class="c1">//flag = true;</span>
        <span class="o">}</span>
        <span class="n">visited</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">direction</span> <span class="o">=</span> <span class="o">{</span><span class="err">\</span><span class="o">{</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">},{</span><span class="mi">0</span><span class="o">,-</span><span class="mi">1</span><span class="o">},{</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">},{-</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">}</span><span class="err">\</span><span class="o">};</span>

        <span class="c1">//向四个方向搜索，若找到答案就返回true</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">new_x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">direction</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>
            <span class="kt">int</span> <span class="n">new_y</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">direction</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>
            
            <span class="c1">//新位置的合法性判别</span>
            <span class="k">if</span><span class="o">(</span><span class="n">new_x</span> <span class="o">&lt;</span> <span class="n">board</span><span class="o">.</span><span class="na">length</span> <span class="o">&amp;&amp;</span> <span class="n">new_y</span> <span class="o">&lt;</span><span class="n">board</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span> <span class="o">&amp;&amp;</span> <span class="n">new_x</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">new_y</span> <span class="o">&gt;=</span> <span class="mi">0</span>
            <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">visited</span><span class="o">[</span><span class="n">new_x</span><span class="o">][</span><span class="n">new_y</span><span class="o">]){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">dfs</span><span class="o">(</span><span class="n">board</span><span class="o">,</span><span class="n">new_x</span><span class="o">,</span><span class="n">new_y</span><span class="o">,</span><span class="n">cur</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span><span class="n">word</span><span class="o">)){</span>
                    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
                <span class="o">}</span>
              	<span class="c1">//dfs(board,new_x,new_y,cur+1,word);</span>
              	<span class="c1">//if(flag) break;</span>
            <span class="o">}</span>
                
        <span class="o">}</span>
        <span class="c1">//回溯</span>
        <span class="n">visited</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump94"></span></p><h2 id="94二叉树的中序遍历">94.二叉树的中序遍历</h2><p>给定一个二叉树，返回它的中序 遍历。</p><p>示例:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="kc">null</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span>
   <span class="mi">1</span>
    <span class="err">\</span>
     <span class="mi">2</span>
    <span class="o">/</span>
   <span class="mi">3</span>

<span class="nl">输出:</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">]</span>
</pre></table></code></div></div><p>进阶: 递归算法很简单，你可以通过迭代算法完成吗？</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="nf">inorderTraversal</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
  	<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
  	<span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>	<span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
  	<span class="c1">//Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();	用Deque比Stack快多了</span>
  	<span class="nc">Deque</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
  	<span class="nc">TreeNode</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
  	<span class="k">while</span><span class="o">(</span> <span class="n">cur</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">!</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
      	<span class="k">while</span><span class="o">(</span><span class="n">cur</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
          	<span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">cur</span><span class="o">);</span>
          	<span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
        <span class="o">}</span>
      	<span class="n">cur</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
      	<span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">cur</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
      	<span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
    <span class="o">}</span>
  	<span class="k">return</span> <span class="n">res</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><p><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/er-cha-shu-de-zhong-xu-bian-li-by-leetcode-solutio/">Morris中序遍历</a></p><p><span id="jump96"></span></p><h2 id="96-不同的二叉搜索树">96. 不同的二叉搜索树</h2><p>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？</p><p>示例:</p><p>输入: 3 输出: 5 解释: 给定 n = 3, 一共有 5 种不同结构的二叉搜索树:</p><div class="language-markdown highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>   1         3     3      2      1
    <span class="se">\ </span>      /     /      / <span class="se">\ </span>     <span class="err">\</span>
     3     2     1      1   3      2
    /     /       <span class="se">\ </span>                <span class="err">\</span>
   2     1         2                 3
</pre></table></code></div></div><h3 id="分治递归">分治递归</h3><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">int</span> <span class="nf">numTrees</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>

        <span class="k">if</span><span class="o">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">2</span><span class="o">)</span> <span class="k">return</span> <span class="mi">2</span><span class="o">;</span>

        <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">num</span> <span class="o">+=</span> <span class="n">numTrees</span><span class="o">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">*</span> <span class="n">numTrees</span><span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">num</span><span class="o">;</span>
    <span class="o">}</span>
</pre></table></code></div></div><h3 id="不用递归的解法">不用递归的解法</h3><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">numTrees</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="no">G</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>
        <span class="no">G</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="no">G</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">i</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">)</span> <span class="o">{</span>
                <span class="no">G</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+=</span> <span class="no">G</span><span class="o">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">*</span> <span class="no">G</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">j</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="no">G</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="卡特兰数">卡特兰数</h3><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">numTrees</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 提示：我们在这里需要用 long 类型防止计算过程中的溢出</span>
        <span class="kt">long</span> <span class="no">C</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="no">C</span> <span class="o">=</span> <span class="no">C</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="o">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">/</span> <span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="no">C</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump98"></span></p><h2 id="98验证二叉搜索树">98.验证二叉搜索树</h2><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p><p>假设一个二叉搜索树具有如下特征：</p><p>节点的左子树只包含小于当前节点的数。 节点的右子树只包含大于当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。 示例 1:</p><p>输入:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>    <span class="mi">2</span>
   <span class="o">/</span> <span class="err">\</span>
  <span class="mi">1</span>   <span class="mi">3</span>
<span class="nl">输出:</span> <span class="kc">true</span>
</pre></table></code></div></div><p>示例 2:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="nl">输入:</span>
    <span class="mi">5</span>
   <span class="o">/</span> <span class="err">\</span>
  <span class="mi">1</span>   <span class="mi">4</span>
     <span class="o">/</span> <span class="err">\</span>
    <span class="mi">3</span>   <span class="mi">6</span>
<span class="nl">输出:</span> <span class="kc">false</span>
<span class="nl">解释:</span> <span class="nl">输入为:</span> <span class="o">[</span><span class="mi">5</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="kc">null</span><span class="o">,</span><span class="kc">null</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">6</span><span class="o">]</span><span class="err">。</span>
     <span class="n">根节点的值为</span> <span class="mi">5</span> <span class="err">，</span><span class="n">但是其右子节点值为</span> <span class="mi">4</span> <span class="err">。</span>
</pre></table></code></div></div><p>中序遍历，序列有序则符合要求。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="nc">TreeNode</span> <span class="n">pre</span><span class="o">;</span>
    <span class="kt">boolean</span> <span class="n">flag</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isValidBST</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">pre</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="n">inOrder</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>

        <span class="k">return</span> <span class="n">flag</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">inOrder</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">flag</span> <span class="o">==</span> <span class="kc">true</span><span class="o">){</span>
            <span class="n">inOrder</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
            <span class="k">if</span><span class="o">(</span><span class="n">pre</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">flag</span> <span class="o">==</span> <span class="kc">true</span><span class="o">){</span>
                <span class="n">flag</span> <span class="o">=</span> <span class="n">pre</span><span class="o">.</span><span class="na">val</span> <span class="o">&lt;</span> <span class="n">root</span><span class="o">.</span><span class="na">val</span> <span class="o">?</span> <span class="kc">true</span> <span class="o">:</span> <span class="kc">false</span><span class="o">;</span>
                <span class="k">if</span><span class="o">(</span><span class="n">flag</span> <span class="o">==</span> <span class="kc">false</span><span class="o">)</span>
                    <span class="k">return</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">pre</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
            <span class="n">inOrder</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump101"></span></p><h2 id="101对称二叉树">101.对称二叉树</h2><p>给定一个二叉树，检查它是否是镜像对称的。</p><p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>		1
   / \
  2   2
 / \ / \
3  4 4  3
</pre></table></code></div></div><p>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>		1
   / \
  2   2
   \   \
   3    3
</pre></table></code></div></div><p>进阶：</p><p>你可以运用递归和迭代两种方法解决这个问题吗？</p><p>递归：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isSymmetric</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">compare</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">root</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kt">boolean</span> <span class="nf">compare</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root1</span><span class="o">,</span> <span class="nc">TreeNode</span> <span class="n">root2</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root1</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">root2</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>  <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root1</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">root2</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>  <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">root1</span><span class="o">.</span><span class="na">val</span> <span class="o">==</span> <span class="n">root2</span><span class="o">.</span><span class="na">val</span>
        <span class="o">&amp;&amp;</span> <span class="n">compare</span><span class="o">(</span><span class="n">root1</span><span class="o">.</span><span class="na">left</span><span class="o">,</span><span class="n">root2</span><span class="o">.</span><span class="na">right</span><span class="o">)</span>
        <span class="o">&amp;&amp;</span> <span class="n">compare</span><span class="o">(</span><span class="n">root1</span><span class="o">.</span><span class="na">right</span><span class="o">,</span><span class="n">root2</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>迭代：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isSymmetric</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//初始化队列</span>
        <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
        <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
      	<span class="c1">//每次取两个节点出来比较</span>
        <span class="k">while</span><span class="o">(!</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
            <span class="nc">TreeNode</span> <span class="n">node1</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="nc">TreeNode</span> <span class="n">node2</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
          	<span class="c1">//如果这两个节点都为空，那么就继续比较</span>
            <span class="k">if</span><span class="o">(</span><span class="n">node1</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">node2</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                <span class="k">continue</span><span class="o">;</span>
          	<span class="c1">//如果有一者为空，或者两个节点值不等，就返回false</span>
            <span class="k">if</span><span class="o">((</span><span class="n">node1</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">node2</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">||</span> <span class="n">node1</span><span class="o">.</span><span class="na">val</span> <span class="o">!=</span> <span class="n">node2</span><span class="o">.</span><span class="na">val</span><span class="o">)</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
						<span class="c1">//按比较顺序入队</span>
            <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">node1</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
            <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">node2</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
          
            <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">node1</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
            <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">node2</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>

        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump136"></span></p><h2 id="136只出现一次的数字">136.只出现一次的数字</h2><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p>说明：</p><p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><p>示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">]</span>
<span class="nl">输出:</span> <span class="mi">1</span>
</pre></table></code></div></div><p>示例 2:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="o">[</span><span class="mi">4</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">]</span>
<span class="nl">输出:</span> <span class="mi">4</span>
</pre></table></code></div></div><p>利用异或的性质，当一个数被另一个数异或两次时，会变回自身。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">singleNumber</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">targe</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">targe</span> <span class="o">^=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">targe</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump141"></span></p><h2 id="141环形链表">141.环形链表</h2><p>给定一个链表，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p><p>如果链表中存在环，则返回 true 。 否则，返回 false 。</p><p>进阶：</p><p>你能用 O(1)（即，常量）内存解决此问题吗？</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt="" /></p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">head</span> <span class="o">=</span> <span class="o">[</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">0</span><span class="o">,-</span><span class="mi">4</span><span class="o">],</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">输出</span><span class="err">：</span><span class="kc">true</span>
<span class="n">解释</span><span class="err">：</span><span class="n">链表中有一个环</span><span class="err">，</span><span class="n">其尾部连接到第二个节点</span><span class="err">。</span>
</pre></table></code></div></div><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="" /></p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">head</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">],</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">输出</span><span class="err">：</span><span class="kc">true</span>
<span class="n">解释</span><span class="err">：</span><span class="n">链表中有一个环</span><span class="err">，</span><span class="n">其尾部连接到第一个节点</span><span class="err">。</span>
</pre></table></code></div></div><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt="" /></p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">head</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">],</span> <span class="n">pos</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="n">输出</span><span class="err">：</span><span class="kc">false</span>
<span class="n">解释</span><span class="err">：</span><span class="n">链表中没有环</span><span class="err">。</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hasCycle</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>

        <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="k">while</span><span class="o">(</span><span class="n">head</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">cnt</span><span class="o">++</span> <span class="o">&gt;</span> <span class="mi">10000</span><span class="o">){</span>
                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>快慢指针：</p><p>一个指针移动地慢，一个指针移动地快，如果有环路存在，那么快的指针肯定会追上慢的指针（套圈）。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hasCycle</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>   <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="nc">ListNode</span> <span class="n">slow</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="nc">ListNode</span> <span class="n">fast</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">fast</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">slow</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">slow</span> <span class="o">==</span> <span class="n">fast</span><span class="o">)</span>
                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
            <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">fast</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump142"></span></p><h2 id="142环形链表ii">142.环形链表II</h2><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 <code class="language-plaintext highlighter-rouge">null</code>。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p><p><strong>说明：</strong>不允许修改给定的链表。</p><p>进阶：</p><p>你能用 O(1)（即，常量）内存解决此问题吗？</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt="" /></p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">head</span> <span class="o">=</span> <span class="o">[</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">0</span><span class="o">,-</span><span class="mi">4</span><span class="o">],</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">输出</span><span class="err">：</span><span class="kc">true</span>
<span class="n">解释</span><span class="err">：</span><span class="n">链表中有一个环</span><span class="err">，</span><span class="n">其尾部连接到第二个节点</span><span class="err">。</span>
</pre></table></code></div></div><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="" /></p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">head</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">],</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">输出</span><span class="err">：</span><span class="kc">true</span>
<span class="n">解释</span><span class="err">：</span><span class="n">链表中有一个环</span><span class="err">，</span><span class="n">其尾部连接到第一个节点</span><span class="err">。</span>
</pre></table></code></div></div><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt="" /></p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">head</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">],</span> <span class="n">pos</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="n">输出</span><span class="err">：</span><span class="kc">false</span>
<span class="n">解释</span><span class="err">：</span><span class="n">链表中没有环</span><span class="err">。</span>
</pre></table></code></div></div><p>快慢指针：</p><p>初始时，slow和fast都位于链表的头部，随后slow每次向后移动一个位置，fast向后移动两个位置。二者会在环中的某点相遇。如下图所示：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://assets.leetcode-cn.com/solution-static/142/142_fig1.png" alt="" /></p><p>b是相遇时slow指针在环内走过的距离，所以此时fast指针走过的距离为：<code class="language-plaintext highlighter-rouge">a+n(b+c)+b = a+(n+1)b+nc</code>。任意时刻，fast指针走过的距离都为slow指针的两倍，所以有：<code class="language-plaintext highlighter-rouge">b = a+(n+1)b+nc</code>，即：<code class="language-plaintext highlighter-rouge">a = c+(n-1)(b+c)</code>，所以从相遇点到入环点的距离加上 n-1 圈的环长，恰好等于从链表头部到入环点的距离。因此，当发现 slow 与 fast 相遇时，我们再额外使用一个指针 ptr。起始，它指向链表头部；随后，它和 slow 每次向后移动一个位置。最终，它们会在入环点相遇。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">detectCycle</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>

        <span class="k">if</span><span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>   <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="nc">ListNode</span> <span class="n">slow</span> <span class="o">=</span> <span class="n">head</span><span class="o">,</span> <span class="n">fast</span> <span class="o">=</span> <span class="n">head</span><span class="o">,</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>

        <span class="k">while</span><span class="o">(</span><span class="n">fast</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">fast</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
            <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">slow</span> <span class="o">==</span> <span class="n">fast</span><span class="o">){</span>
                <span class="k">while</span><span class="o">(</span><span class="n">slow</span> <span class="o">!=</span> <span class="n">ptr</span><span class="o">){</span>
                    <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                    <span class="n">ptr</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="k">return</span> <span class="n">slow</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="148排序链表">148.排序链表</h2><p>给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。</p><p>进阶：</p><p>你可以在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序吗？</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">head</span> <span class="o">=</span> <span class="o">[</span><span class="mi">4</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">]</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">head</span> <span class="o">=</span> <span class="o">[-</span><span class="mi">1</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">0</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="o">[-</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span>
</pre></table></code></div></div><p><strong>提示：</strong></p><ul><li>链表中节点的数目在范围 <code class="language-plaintext highlighter-rouge">[0, 5 * 104]</code> 内</li><li><code class="language-plaintext highlighter-rouge">-105 &lt;= Node.val &lt;= 105</code></li></ul><p>暴力遍历插入：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">sortList</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//制造一个伪头节点，用于执行插入操作</span>
        <span class="nc">ListNode</span> <span class="n">fake_head</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(-</span><span class="mi">1</span><span class="o">);</span>
        <span class="n">fake_head</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="c1">//遍历节点，出现逆序对，就把后一个节点插入到合适的位置</span>
        <span class="nc">ListNode</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">ptr</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">ptr</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">ptr</span><span class="o">.</span><span class="na">val</span> <span class="o">&gt;</span> <span class="n">ptr</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">val</span><span class="o">){</span>
                <span class="c1">//将此节点从原链表中取出</span>
                <span class="nc">ListNode</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                <span class="n">ptr</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                <span class="nc">ListNode</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">fake_head</span><span class="o">;</span>
                <span class="c1">//找合适的位置</span>
                <span class="k">while</span><span class="o">(</span><span class="n">cur</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">val</span> <span class="o">&lt;</span> <span class="n">tmp</span><span class="o">.</span><span class="na">val</span><span class="o">){</span>
                    <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="c1">//把该节点插入到合适的位置</span>
                <span class="n">tmp</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                <span class="n">cur</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span> <span class="o">{</span>
                <span class="n">ptr</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="o">}</span>

        <span class="o">}</span>
        <span class="k">return</span> <span class="n">fake_head</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>小顶堆：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">sortList</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//小顶堆</span>
        <span class="nc">PriorityQueue</span><span class="o">&lt;</span><span class="nc">ListNode</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PriorityQueue</span><span class="o">&lt;&gt;((</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">)-&gt;{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">a</span><span class="o">.</span><span class="na">val</span> <span class="o">&gt;</span> <span class="n">b</span><span class="o">.</span><span class="na">val</span><span class="o">){</span>
                <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">});</span>
        <span class="nc">ListNode</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">ptr</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">ptr</span><span class="o">);</span>
            <span class="n">ptr</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="nc">ListNode</span> <span class="n">newHead</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(-</span><span class="mi">1</span><span class="o">);</span>
        <span class="n">ptr</span> <span class="o">=</span> <span class="n">newHead</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(!</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
            <span class="nc">ListNode</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="n">tmp</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
            <span class="n">ptr</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
            <span class="n">ptr</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">ptr</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">newHead</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>递归归并排序：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="c1">//归并排序链表</span>
    <span class="c1">//1.先用快慢指针把链表分割为两部分</span>
    <span class="c1">//2.再递归分割直至只剩一个节点，即head.next = null</span>
    <span class="c1">//3.接着对两个有序链表进行归并</span>
    <span class="c1">//4.用一个指针来串</span>
    <span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">sortList</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
            <span class="k">return</span> <span class="n">head</span><span class="o">;</span>
        <span class="nc">ListNode</span> <span class="n">slow</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="nc">ListNode</span> <span class="n">fast</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">slow</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">//保留后半段的引用</span>
        <span class="nc">ListNode</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">slow</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="c1">//分割链表</span>
        <span class="n">slow</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="c1">//递归分割</span>
        <span class="nc">ListNode</span> <span class="n">left</span> <span class="o">=</span> <span class="n">sortList</span><span class="o">(</span><span class="n">head</span><span class="o">);</span>
        <span class="nc">ListNode</span> <span class="n">right</span> <span class="o">=</span> <span class="n">sortList</span><span class="o">(</span><span class="n">tmp</span><span class="o">);</span>

        <span class="nc">ListNode</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(-</span><span class="mi">1</span><span class="o">);</span>
        <span class="nc">ListNode</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">res</span><span class="o">;</span>
        <span class="c1">//执行归并</span>
        <span class="k">while</span><span class="o">(</span><span class="n">left</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">left</span><span class="o">.</span><span class="na">val</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">.</span><span class="na">val</span><span class="o">){</span>
                <span class="n">cur</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">left</span><span class="o">;</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="n">cur</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">right</span><span class="o">;</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">right</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">cur</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">left</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">?</span> <span class="n">left</span> <span class="o">:</span> <span class="n">right</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>

    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>迭代归并排序（不是我写的，待复习！）：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">sortList</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="n">getLength</span><span class="o">(</span><span class="n">head</span><span class="o">);</span>
        <span class="nc">ListNode</span> <span class="n">dummy</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(-</span><span class="mi">1</span><span class="o">);</span>
        <span class="n">dummy</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
       
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">step</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">step</span> <span class="o">&lt;</span> <span class="n">length</span><span class="o">;</span> <span class="n">step</span><span class="o">*=</span><span class="mi">2</span><span class="o">){</span> <span class="c1">//依次将链表分成1块，2块，4块...</span>
            <span class="c1">//每次变换步长，pre指针和cur指针都初始化在链表头</span>
            <span class="nc">ListNode</span> <span class="n">pre</span> <span class="o">=</span> <span class="n">dummy</span><span class="o">;</span> 
            <span class="nc">ListNode</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">dummy</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="k">while</span><span class="o">(</span><span class="n">cur</span><span class="o">!=</span><span class="kc">null</span><span class="o">){</span>
                <span class="nc">ListNode</span> <span class="n">h1</span> <span class="o">=</span> <span class="n">cur</span><span class="o">;</span> <span class="c1">//第一部分头 （第二次循环之后，cur为剩余部分头，不断往后把链表按照步长step分成一块一块...）</span>
                <span class="nc">ListNode</span> <span class="n">h2</span> <span class="o">=</span> <span class="n">split</span><span class="o">(</span><span class="n">h1</span><span class="o">,</span><span class="n">step</span><span class="o">);</span>  <span class="c1">//第二部分头</span>
                <span class="n">cur</span> <span class="o">=</span> <span class="n">split</span><span class="o">(</span><span class="n">h2</span><span class="o">,</span><span class="n">step</span><span class="o">);</span> <span class="c1">//剩余部分的头</span>
                <span class="nc">ListNode</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">merge</span><span class="o">(</span><span class="n">h1</span><span class="o">,</span><span class="n">h2</span><span class="o">);</span> <span class="c1">//将一二部分排序合并</span>
                <span class="n">pre</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span> <span class="c1">//将前面的部分与排序好的部分连接</span>
                <span class="k">while</span><span class="o">(</span><span class="n">pre</span><span class="o">.</span><span class="na">next</span><span class="o">!=</span><span class="kc">null</span><span class="o">){</span>
                    <span class="n">pre</span> <span class="o">=</span> <span class="n">pre</span><span class="o">.</span><span class="na">next</span><span class="o">;</span> <span class="c1">//把pre指针移动到排序好的部分的末尾</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">dummy</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getLength</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">){</span>
    <span class="c1">//获取链表长度</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">head</span><span class="o">!=</span><span class="kc">null</span><span class="o">){</span>
            <span class="n">count</span><span class="o">++;</span>
            <span class="n">head</span><span class="o">=</span><span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">count</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">split</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">,</span><span class="kt">int</span> <span class="n">step</span><span class="o">){</span>
        <span class="c1">//断链操作 返回第二部分链表头</span>
        <span class="k">if</span><span class="o">(</span><span class="n">head</span><span class="o">==</span><span class="kc">null</span><span class="o">)</span>  <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="nc">ListNode</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">step</span> <span class="o">&amp;&amp;</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">!=</span><span class="kc">null</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="nc">ListNode</span> <span class="n">right</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="n">cur</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">//切断连接</span>
        <span class="k">return</span> <span class="n">right</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">merge</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">h1</span><span class="o">,</span> <span class="nc">ListNode</span> <span class="n">h2</span><span class="o">){</span>
    <span class="c1">//合并两个有序链表</span>
        <span class="nc">ListNode</span> <span class="n">head</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(-</span><span class="mi">1</span><span class="o">);</span>
        <span class="nc">ListNode</span> <span class="n">p</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">h1</span><span class="o">!=</span><span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">h2</span><span class="o">!=</span><span class="kc">null</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">h1</span><span class="o">.</span><span class="na">val</span> <span class="o">&lt;</span> <span class="n">h2</span><span class="o">.</span><span class="na">val</span><span class="o">){</span>
                <span class="n">p</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">h1</span><span class="o">;</span>
                <span class="n">h1</span> <span class="o">=</span> <span class="n">h1</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">else</span><span class="o">{</span>
                <span class="n">p</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">h2</span><span class="o">;</span>
                <span class="n">h2</span> <span class="o">=</span> <span class="n">h2</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>           
        <span class="o">}</span>
        <span class="k">if</span><span class="o">(</span><span class="n">h1</span><span class="o">!=</span><span class="kc">null</span><span class="o">)</span>    <span class="n">p</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">h1</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">h2</span><span class="o">!=</span><span class="kc">null</span><span class="o">)</span>    <span class="n">p</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">h2</span><span class="o">;</span>

        <span class="k">return</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>     
    <span class="o">}</span>
<span class="o">}</span>

<span class="n">作者</span><span class="err">：</span><span class="n">cherry</span><span class="o">-</span><span class="n">n1</span>
<span class="n">链接</span><span class="err">：</span><span class="nl">https:</span><span class="c1">//leetcode-cn.com/problems/sort-list/solution/pai-xu-lian-biao-di-gui-die-dai-xiang-jie-by-cherr/</span>
<span class="n">来源</span><span class="err">：</span><span class="n">力扣</span><span class="err">（</span><span class="nc">LeetCode</span><span class="err">）</span>
<span class="n">著作权归作者所有</span><span class="err">。</span><span class="n">商业转载请联系作者获得授权</span><span class="err">，</span><span class="n">非商业转载请注明出处</span><span class="err">。</span>
</pre></table></code></div></div><p><span id="jump215"></span></p><h2 id="215数组中的第k大元素">215.数组中的第k大元素</h2><p>在未排序的数组中找到第 <strong>k</strong> 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p><p>示例 1:</p><div class="language-markdown highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>输入: [3,2,1,5,6,4] 和 k = 2
输出: 5
</pre></table></code></div></div><p>示例 2:</p><div class="language-markdown highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>输入: [3,2,3,1,2,4,5,5,6] 和 k = 4
输出: 4
</pre></table></code></div></div><p>说明: 你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。</p><h3 id="基于快速排序的选择方法">基于快速排序的选择方法</h3><p>每完成一轮快速排序，就有一个元素被放在正确的位置上，所以要找到数组第k大的元素，只需在第k大的元素被放置在正确的位置上时，返回其值即可。为了提高快速排序的性能，pivot的选择采用随机数的方式，这样可以避免每次都将数组分为1和n-1的极端情况。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
        <span class="nc">Random</span> <span class="n">random</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Random</span><span class="o">();</span>

        <span class="kd">public</span> <span class="kt">int</span> <span class="nf">findKthLargest</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="nf">quickSelect</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">k</span><span class="o">);</span>
        <span class="o">}</span>
				<span class="c1">//快速选择算法</span>
        <span class="kd">public</span> <span class="kt">int</span> <span class="nf">quickSelect</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">l</span><span class="o">,</span> <span class="kt">int</span> <span class="n">r</span><span class="o">,</span> <span class="kt">int</span> <span class="n">index</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">q</span> <span class="o">=</span> <span class="n">randomPartition</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">q</span> <span class="o">==</span> <span class="n">index</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">a</span><span class="o">[</span><span class="n">q</span><span class="o">];</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">q</span> <span class="o">&lt;</span> <span class="n">index</span> <span class="o">?</span> <span class="n">quickSelect</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">q</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">r</span><span class="o">,</span> <span class="n">index</span><span class="o">)</span> <span class="o">:</span> <span class="n">quickSelect</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">l</span><span class="o">,</span> <span class="n">q</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">index</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
			<span class="c1">//随机选择pivot</span>
       <span class="kd">public</span> <span class="kt">int</span> <span class="nf">randomPartition</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">l</span><span class="o">,</span> <span class="kt">int</span> <span class="n">r</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="na">nextInt</span><span class="o">(</span><span class="n">r</span><span class="o">-</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="n">l</span><span class="o">;</span>
            <span class="n">swap</span><span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">i</span><span class="o">,</span><span class="n">l</span><span class="o">);</span>
            <span class="k">return</span> <span class="nf">partition</span><span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">l</span><span class="o">,</span><span class="n">r</span><span class="o">);</span>
       <span class="o">}</span>

       <span class="kd">public</span> <span class="kt">int</span> <span class="nf">partition</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">l</span><span class="o">,</span> <span class="kt">int</span> <span class="n">r</span><span class="o">){</span>
            <span class="c1">//取第l个元素作为基准，此时已经在randomPartition中随机选择了一个数放在了l位置</span>
            <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">l</span><span class="o">];</span>
						
            <span class="k">while</span><span class="o">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">r</span><span class="o">){</span>
                <span class="k">while</span><span class="o">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">r</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">a</span><span class="o">[</span><span class="n">r</span><span class="o">])</span> <span class="o">--</span><span class="n">r</span><span class="o">;</span>
                <span class="n">a</span><span class="o">[</span><span class="n">l</span><span class="o">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">r</span><span class="o">];</span>
                <span class="k">while</span><span class="o">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">r</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="n">a</span><span class="o">[</span><span class="n">l</span><span class="o">])</span> <span class="o">++</span><span class="n">l</span><span class="o">;</span>
                <span class="n">a</span><span class="o">[</span><span class="n">r</span><span class="o">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">l</span><span class="o">];</span>
            <span class="o">}</span>
            <span class="n">a</span><span class="o">[</span><span class="n">l</span><span class="o">]</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
            <span class="k">return</span> <span class="n">l</span><span class="o">;</span>
       <span class="o">}</span>

        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">swap</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
            <span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
        <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="基于堆排序的选择方法">基于堆排序的选择方法</h3><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">findKthLargest</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">heapSize</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="n">buildMaxHeap</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">heapSize</span><span class="o">);</span>
        <span class="c1">//排序出数组的后k-1个元素</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="o">--</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">swap</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
            <span class="o">--</span><span class="n">heapSize</span><span class="o">;</span>
            <span class="n">maxHeapify</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">heapSize</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="c1">//前k-1大的元素已经被排序到数组的后方，则最大堆的根节点就是第k大元素</span>
        <span class="k">return</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">buildMaxHeap</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">heapSize</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">heapSize</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="o">--</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">maxHeapify</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">heapSize</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">maxHeapify</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">heapSize</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">*</span><span class="mi">2</span> <span class="o">+</span><span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">heapSize</span><span class="o">;</span> <span class="n">j</span> <span class="o">=</span><span class="mi">2</span> <span class="o">*</span> <span class="n">j</span> <span class="o">+</span><span class="mi">1</span><span class="o">){</span>
<span class="c1">//            若右孩子大于左孩子</span>
            <span class="k">if</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="n">heapSize</span><span class="o">)</span>
                <span class="o">++</span><span class="n">j</span><span class="o">;</span>
            <span class="c1">//如果当前值已经是最大值，则不做操作</span>
            <span class="k">if</span><span class="o">(</span><span class="n">tmp</span> <span class="o">&gt;</span> <span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">])</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="c1">//若父节点的值小于其子节点最大值，则将子节点的值赋给父节点</span>
            <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
            <span class="c1">//记录原来父节点值应该放置的位置</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">j</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">//放置父节点</span>
        <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">swap</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
        <span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump226"></span></p><h2 id="226翻转二叉树">226.翻转二叉树</h2><p>翻转一棵二叉树。</p><p>示例：</p><p>输入：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>		 <span class="mi">4</span>
   <span class="o">/</span>   <span class="err">\</span>
  <span class="mi">2</span>     <span class="mi">7</span>
 <span class="o">/</span> <span class="err">\</span>   <span class="o">/</span> <span class="err">\</span>
<span class="mi">1</span>   <span class="mi">3</span> <span class="mi">6</span>   <span class="mi">9</span>
</pre></table></code></div></div><p>输出：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>		 <span class="mi">4</span>
   <span class="o">/</span>   <span class="err">\</span>
  <span class="mi">7</span>     <span class="mi">2</span>
 <span class="o">/</span> <span class="err">\</span>   <span class="o">/</span> <span class="err">\</span>
<span class="mi">9</span>   <span class="mi">6</span> <span class="mi">3</span>   <span class="mi">1</span>
</pre></table></code></div></div><p>备注: 这个问题是受到 Max Howell 的 原问题 启发的 ：</p><blockquote><p>谷歌：我们90％的工程师使用您编写的软件(Homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。</p></blockquote><p>立即推—&gt;白板撸代码无用！</p><p>递归交换：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">TreeNode</span> <span class="nf">invertTree</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="n">invert</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">root</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">invert</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="nc">TreeNode</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
        <span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
        <span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
        <span class="n">invert</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
        <span class="n">invert</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>迭代交换：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">TreeNode</span> <span class="nf">invertTree</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
      	<span class="c1">//层序遍历</span>
        <span class="k">while</span><span class="o">(!</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
            <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>

            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
                <span class="nc">TreeNode</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
                <span class="c1">//交换子节点</span>
                <span class="nc">TreeNode</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
                <span class="n">cur</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
                <span class="n">cur</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
                <span class="k">if</span><span class="o">(</span><span class="n">cur</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>   <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">cur</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
                <span class="k">if</span><span class="o">(</span><span class="n">cur</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>   <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">cur</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">root</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump234"></span></p><h2 id="234回文链表">234.回文链表</h2><p>请判断一个链表是否为回文链表。</p><p>示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="mi">1</span><span class="o">-&gt;</span><span class="mi">2</span>
<span class="nl">输出:</span> <span class="kc">false</span>
</pre></table></code></div></div><p>示例 2:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="mi">1</span><span class="o">-&gt;</span><span class="mi">2</span><span class="o">-&gt;</span><span class="mi">2</span><span class="o">-&gt;</span><span class="mi">1</span>
<span class="nl">输出:</span> <span class="kc">true</span>
</pre></table></code></div></div><p>进阶：</p><ul><li>你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</li></ul><p>用栈实现逆序比对。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isPalindrome</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>

        <span class="c1">//统计节点个数</span>
        <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="nc">ListNode</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">ptr</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="n">num</span><span class="o">++;</span>
            <span class="n">ptr</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">ptr</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="n">num</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
        <span class="c1">//将前一半节点入栈</span>
        <span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">ListNode</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Stack</span><span class="o">&lt;&gt;();</span>
        <span class="k">while</span><span class="o">(</span><span class="n">cnt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span>
            <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">ptr</span><span class="o">);</span>
            <span class="n">ptr</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">cnt</span><span class="o">--;</span>
        <span class="o">}</span>
        <span class="c1">//如果是奇数，就需要继续向后移动一个节点，越过中间节点</span>
        <span class="k">if</span><span class="o">(</span><span class="n">num</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>    <span class="n">ptr</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="c1">//出栈比对</span>
        <span class="k">while</span><span class="o">(!</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
            <span class="nc">ListNode</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
            <span class="k">if</span><span class="o">(</span><span class="n">tmp</span><span class="o">.</span><span class="na">val</span> <span class="o">!=</span> <span class="n">ptr</span><span class="o">.</span><span class="na">val</span><span class="o">)</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="n">ptr</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>进阶：将后一半链表翻转，再双指针遍历比较，结束后将链表恢复原样</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isPalindrome</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="c1">//统计节点个数</span>
        <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="nc">ListNode</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">ptr</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="n">num</span><span class="o">++;</span>
            <span class="n">ptr</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">ptr</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="n">num</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">cnt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span>
            <span class="n">ptr</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">cnt</span><span class="o">--;</span>
        <span class="o">}</span>
        <span class="c1">//将后一半链表翻转</span>
        <span class="nc">ListNode</span> <span class="n">revStart</span> <span class="o">=</span> <span class="n">reverseListNode</span><span class="o">(</span><span class="n">ptr</span><span class="o">);</span>
        <span class="nc">ListNode</span> <span class="n">p1</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="nc">ListNode</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">revStart</span><span class="o">;</span>
        <span class="n">cnt</span> <span class="o">=</span> <span class="n">num</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">cnt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">p1</span><span class="o">.</span><span class="na">val</span> <span class="o">!=</span> <span class="n">p2</span><span class="o">.</span><span class="na">val</span><span class="o">){</span>
                <span class="n">ptr</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">reverseListNode</span><span class="o">(</span><span class="n">revStart</span><span class="o">);</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">cnt</span><span class="o">--;</span>
            <span class="n">p1</span> <span class="o">=</span> <span class="n">p1</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">p2</span> <span class="o">=</span> <span class="n">p2</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">ptr</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">reverseListNode</span><span class="o">(</span><span class="n">revStart</span><span class="o">);</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nc">ListNode</span> <span class="nf">reverseListNode</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">){</span>
        <span class="nc">ListNode</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="nc">ListNode</span> <span class="n">pre</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

        <span class="k">while</span><span class="o">(</span><span class="n">cur</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="nc">ListNode</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">cur</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">pre</span><span class="o">;</span>
            <span class="n">pre</span> <span class="o">=</span> <span class="n">cur</span><span class="o">;</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>            
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">pre</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump239"></span></p><h2 id="239滑动窗口最大值">239.滑动窗口最大值</h2><p>给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p><p>返回滑动窗口中的最大值。</p><p>进阶：</p><ul><li>你能在线性时间复杂度内解决此题吗？</li></ul><p>示例:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="n">nums</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">,-</span><span class="mi">1</span><span class="o">,-</span><span class="mi">3</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">7</span><span class="o">],</span> <span class="n">和</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">3</span>
<span class="nl">输出:</span> <span class="o">[</span><span class="mi">3</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">7</span><span class="o">]</span> 
<span class="nl">解释:</span> 

  <span class="n">滑动窗口的位置</span>                <span class="n">最大值</span>

<span class="o">---------------</span>               <span class="o">-----</span>

<span class="o">[</span><span class="mi">1</span>  <span class="mi">3</span>  <span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">-</span><span class="mi">3</span>  <span class="mi">5</span>  <span class="mi">3</span>  <span class="mi">6</span>  <span class="mi">7</span>       <span class="mi">3</span>
 <span class="mi">1</span> <span class="o">[</span><span class="mi">3</span>  <span class="o">-</span><span class="mi">1</span>  <span class="o">-</span><span class="mi">3</span><span class="o">]</span> <span class="mi">5</span>  <span class="mi">3</span>  <span class="mi">6</span>  <span class="mi">7</span>       <span class="mi">3</span>
 <span class="mi">1</span>  <span class="mi">3</span> <span class="o">[-</span><span class="mi">1</span>  <span class="o">-</span><span class="mi">3</span>  <span class="mi">5</span><span class="o">]</span> <span class="mi">3</span>  <span class="mi">6</span>  <span class="mi">7</span>       <span class="mi">5</span>
 <span class="mi">1</span>  <span class="mi">3</span>  <span class="o">-</span><span class="mi">1</span> <span class="o">[-</span><span class="mi">3</span>  <span class="mi">5</span>  <span class="mi">3</span><span class="o">]</span> <span class="mi">6</span>  <span class="mi">7</span>       <span class="mi">5</span>
 <span class="mi">1</span>  <span class="mi">3</span>  <span class="o">-</span><span class="mi">1</span>  <span class="o">-</span><span class="mi">3</span> <span class="o">[</span><span class="mi">5</span>  <span class="mi">3</span>  <span class="mi">6</span><span class="o">]</span> <span class="mi">7</span>       <span class="mi">6</span>
 <span class="mi">1</span>  <span class="mi">3</span>  <span class="o">-</span><span class="mi">1</span>  <span class="o">-</span><span class="mi">3</span>  <span class="mi">5</span> <span class="o">[</span><span class="mi">3</span>  <span class="mi">6</span>  <span class="mi">7</span><span class="o">]</span>      <span class="mi">7</span>
</pre></table></code></div></div><p>提示：</p><ul><li>1 &lt;= nums.length &lt;= 10^5</li><li>-10^4 &lt;= nums[i] &lt;= 10^4</li><li>1 &lt;= k &lt;= nums.length</li><li>通过次数83,092提交次数168,914</li></ul><p>暴力法：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">maxSlidingWindow</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>    <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="c1">//最终结果的数组</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">max_i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MIN_VALUE</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">cur</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="c1">//还在第一个窗口内</span>
            <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">max</span><span class="o">){</span>
                    <span class="n">max</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
                    <span class="n">max_i</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span>
                    <span class="n">res</span><span class="o">[</span><span class="n">cur</span><span class="o">++]</span> <span class="o">=</span> <span class="n">max</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="c1">//开始滑动窗口</span>
                <span class="c1">//去除的左边界就是最大值</span>
                <span class="k">if</span><span class="o">(</span><span class="n">i</span><span class="o">-</span><span class="n">k</span> <span class="o">==</span> <span class="n">max_i</span><span class="o">){</span>
                    <span class="n">max</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MIN_VALUE</span><span class="o">;</span>
                    <span class="n">max_i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
                    <span class="c1">//重新搜索最大值</span>
                    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">i</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                        <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">max</span><span class="o">){</span>
                            <span class="n">max</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
                            <span class="n">max_i</span> <span class="o">=</span> <span class="n">j</span><span class="o">;</span>
                        <span class="o">}</span>
                    <span class="o">}</span>
                <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                    <span class="c1">//去除的左边界不是最大值</span>
                    <span class="c1">//比较加入的右边界是否比当前最大值大</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">max</span><span class="o">){</span>
                        <span class="n">max</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
                        <span class="n">max_i</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span>
                <span class="n">res</span><span class="o">[</span><span class="n">cur</span><span class="o">++]</span> <span class="o">=</span> <span class="n">max</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>双向队列：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="c1">//建立一个双向队列</span>
    <span class="c1">//实现：遍历每一个元素，从右边删除（出队）所有小于等于该元素的队列元素</span>
    <span class="c1">//这样就能保证队列首元素为最大值</span>
    <span class="nc">ArrayDeque</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">deque</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayDeque</span><span class="o">&lt;&gt;();</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">k</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">maxSlidingWindow</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>    <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="c1">//最终结果的数组</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">cur</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">max_i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">nums</span> <span class="o">=</span> <span class="n">nums</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">k</span> <span class="o">=</span> <span class="n">k</span><span class="o">;</span>
        <span class="c1">//先遍历前k个元素，初始化队列</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">clean_deq</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="n">deque</span><span class="o">.</span><span class="na">offerLast</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">res</span><span class="o">[</span><span class="n">cur</span><span class="o">++]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">deque</span><span class="o">.</span><span class="na">getFirst</span><span class="o">()];</span>
        <span class="c1">//遍历剩余元素</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">k</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">clean_deq</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="n">deque</span><span class="o">.</span><span class="na">offerLast</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="n">res</span><span class="o">[</span><span class="n">cur</span><span class="o">++]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">deque</span><span class="o">.</span><span class="na">getFirst</span><span class="o">()];</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">clean_deq</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">){</span>
        <span class="c1">//如果当前最大值为左边界</span>
        <span class="k">if</span><span class="o">(!</span><span class="n">deque</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">deque</span><span class="o">.</span><span class="na">getFirst</span><span class="o">()</span> <span class="o">==</span> <span class="n">i</span> <span class="o">-</span> <span class="n">k</span><span class="o">){</span>
            <span class="c1">//删除左边界</span>
            <span class="n">deque</span><span class="o">.</span><span class="na">pollFirst</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="c1">//把nums[i]放入队列</span>
        <span class="k">while</span><span class="o">(!</span><span class="n">deque</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">nums</span><span class="o">[</span><span class="n">deque</span><span class="o">.</span><span class="na">getLast</span><span class="o">()])</span> <span class="n">deque</span><span class="o">.</span><span class="na">pollLast</span><span class="o">();</span>
        
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>动态规划（别人写的，需要看！）：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">maxSlidingWindow</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">*</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">k</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="n">nums</span><span class="o">;</span>

    <span class="kt">int</span> <span class="o">[]</span> <span class="n">left</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
    <span class="n">left</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
    <span class="kt">int</span> <span class="o">[]</span> <span class="n">right</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
    <span class="n">right</span><span class="o">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
      <span class="c1">// from left to right</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">%</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">left</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>  <span class="c1">// block_start</span>
      <span class="k">else</span> <span class="n">left</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">left</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">],</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>

      <span class="c1">// from right to left</span>
      <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
      <span class="k">if</span> <span class="o">((</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">%</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">right</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>  <span class="c1">// block_end</span>
      <span class="k">else</span> <span class="n">right</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">right</span><span class="o">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">],</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]);</span>
    <span class="o">}</span>

    <span class="kt">int</span> <span class="o">[]</span> <span class="n">output</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
      <span class="n">output</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">left</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="o">],</span> <span class="n">right</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>

    <span class="k">return</span> <span class="n">output</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="n">作者</span><span class="err">：</span><span class="nc">LeetCode</span>
<span class="n">链接</span><span class="err">：</span><span class="nl">https:</span><span class="c1">//leetcode-cn.com/problems/sliding-window-maximum/solution/hua-dong-chuang-kou-zui-da-zhi-by-leetcode-3/</span>
<span class="n">来源</span><span class="err">：</span><span class="n">力扣</span><span class="err">（</span><span class="nc">LeetCode</span><span class="err">）</span>
<span class="n">著作权归作者所有</span><span class="err">。</span><span class="n">商业转载请联系作者获得授权</span><span class="err">，</span><span class="n">非商业转载请注明出处</span><span class="err">。</span>
</pre></table></code></div></div><p><span id="jump240"></span></p><h2 id="240搜索二维矩阵-ii">240.搜索二维矩阵 II</h2><p>编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性：</p><p>每行的元素从左到右升序排列。 每列的元素从上到下升序排列。 示例:</p><p>现有矩阵 matrix 如下：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="o">[</span>
  <span class="o">[</span><span class="mi">1</span><span class="o">,</span>   <span class="mi">4</span><span class="o">,</span>  <span class="mi">7</span><span class="o">,</span> <span class="mi">11</span><span class="o">,</span> <span class="mi">15</span><span class="o">],</span>
  <span class="o">[</span><span class="mi">2</span><span class="o">,</span>   <span class="mi">5</span><span class="o">,</span>  <span class="mi">8</span><span class="o">,</span> <span class="mi">12</span><span class="o">,</span> <span class="mi">19</span><span class="o">],</span>
  <span class="o">[</span><span class="mi">3</span><span class="o">,</span>   <span class="mi">6</span><span class="o">,</span>  <span class="mi">9</span><span class="o">,</span> <span class="mi">16</span><span class="o">,</span> <span class="mi">22</span><span class="o">],</span>
  <span class="o">[</span><span class="mi">10</span><span class="o">,</span> <span class="mi">13</span><span class="o">,</span> <span class="mi">14</span><span class="o">,</span> <span class="mi">17</span><span class="o">,</span> <span class="mi">24</span><span class="o">],</span>
  <span class="o">[</span><span class="mi">18</span><span class="o">,</span> <span class="mi">21</span><span class="o">,</span> <span class="mi">23</span><span class="o">,</span> <span class="mi">26</span><span class="o">,</span> <span class="mi">30</span><span class="o">]</span>
<span class="o">]</span>
</pre></table></code></div></div><ul><li>给定 target = 5，返回 true。</li><li>给定 target = 20，返回 false。</li></ul><p>深度优先搜索，从左上角开始搜索：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>

    <span class="kt">boolean</span><span class="o">[][]</span> <span class="n">visited</span><span class="o">;</span>
    <span class="kt">int</span><span class="o">[][]</span> <span class="n">matrix</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">target</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">searchMatrix</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">matrix</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">matrix</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>  <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">matrix</span><span class="o">.</span><span class="na">length</span><span class="o">][</span><span class="n">matrix</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">];</span>
        <span class="k">this</span><span class="o">.</span><span class="na">matrix</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">target</span> <span class="o">=</span> <span class="n">target</span><span class="o">;</span>
        <span class="k">return</span> <span class="nf">dfs</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kt">boolean</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">){</span>
        <span class="c1">//超出边界</span>
        <span class="k">if</span><span class="o">(</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="n">matrix</span><span class="o">.</span><span class="na">length</span> <span class="o">||</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">y</span> <span class="o">&gt;=</span> <span class="n">matrix</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">)</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="c1">//找到了target</span>
        <span class="k">if</span><span class="o">(</span><span class="n">matrix</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]</span> <span class="o">==</span> <span class="n">target</span><span class="o">)</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="c1">//记录已访问元素</span>
        <span class="n">visited</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="c1">//当前元素小于target</span>
        <span class="k">if</span><span class="o">(</span><span class="n">matrix</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="o">){</span>
            <span class="c1">//如果在右边界了，就往下走</span>
            <span class="k">if</span><span class="o">(</span><span class="n">y</span> <span class="o">==</span> <span class="n">matrix</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">){</span>
                <span class="k">return</span> <span class="nf">dfs</span><span class="o">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">y</span><span class="o">);</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="c1">//如果还没在右边界，并且(x,y+1)没有被访问过</span>
                <span class="k">if</span><span class="o">(</span><span class="n">visited</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="kc">false</span><span class="o">){</span>
                    <span class="c1">//向右边走</span>
                    <span class="k">return</span> <span class="nf">dfs</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span> <span class="o">+</span><span class="mi">1</span><span class="o">);</span>
                <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                    <span class="c1">//右边已经访问过了，就往下走</span>
                    <span class="k">return</span> <span class="nf">dfs</span><span class="o">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">y</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">else</span><span class="o">{</span>
            <span class="c1">//如果当前元素大于target，就往左走</span>
            <span class="k">return</span> <span class="nf">dfs</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>

    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>从左下角开始搜索：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">searchMatrix</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">matrix</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">matrix</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">matrix</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">target</span><span class="o">){</span>
                <span class="n">x</span><span class="o">--;</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">matrix</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="o">){</span>
                <span class="n">y</span><span class="o">++;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>         
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>   
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump309"></span></p><h2 id="309最佳买卖股票时机含冷冻期">309.最佳买卖股票时机含冷冻期</h2><p>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。</p><p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p><p>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。 示例:</p><div class="language-markdown highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>输入: [1,2,3,0,2]
输出: 3 
解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]
</pre></table></code></div></div><h3 id="动态规划">动态规划</h3><p>设<code class="language-plaintext highlighter-rouge">dp[i]</code>为第<code class="language-plaintext highlighter-rouge">i</code>天结束后，最大的累积收益。第<code class="language-plaintext highlighter-rouge">i</code>天结束后有3种状态：</p><div class="language-markdown highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="p">1.</span> 持有一支股票，对应的累积最大收益为<span class="sb">`dp[i][0]`</span>;
<span class="p">2.</span> 不持有任何股票，并处于冷冻期，累计最大收益为<span class="sb">`dp[i][1]`</span>;
<span class="p">3.</span> 不持有任何股票，并不处于冷冻期，累计最大收益为<span class="sb">`dp[i][2]`</span>;
</pre></table></code></div></div><p>第<code class="language-plaintext highlighter-rouge">i</code>天的状态由第<code class="language-plaintext highlighter-rouge">i-1</code>天状态转移而来，针对以上三种状态，分别有如下可能：</p><div class="language-markdown highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="p">1.</span> 当出现状态1时，说明第i天结束后持有一支股票，股票来源可能是
		第i-1天就持有的，那么dp<span class="p">[</span><span class="nv">i</span><span class="p">][</span><span class="ss">0</span><span class="p">]</span> = dp<span class="p">[</span><span class="nv">i-1</span><span class="p">][</span><span class="ss">0</span><span class="p">]</span>;
		第i天买入的，那么第i-1天结束后就不可能持有股票，且不可能处于冷冻期，则
								dp<span class="p">[</span><span class="nv">i</span><span class="p">][</span><span class="ss">0</span><span class="p">]</span>=dp<span class="p">[</span><span class="nv">i-1</span><span class="p">][</span><span class="ss">2</span><span class="p">]</span>-prices[i];
		综上：dp<span class="p">[</span><span class="nv">i</span><span class="p">][</span><span class="ss">0</span><span class="p">]</span> = max(dp<span class="p">[</span><span class="nv">i-1</span><span class="p">][</span><span class="ss">0</span><span class="p">]</span>, dp<span class="p">[</span><span class="nv">i-1</span><span class="p">][</span><span class="ss">2</span><span class="p">]</span>-prices[i]);
<span class="p">
2.</span> 当出现状态2时，说明第i天结束后不持有股票，并处于冷冻期，说明第i天卖出了股票，则只有一种可能，即第i-1天持有一支股票：
		dp<span class="p">[</span><span class="nv">i</span><span class="p">][</span><span class="ss">1</span><span class="p">]</span> = dp<span class="p">[</span><span class="nv">i-1</span><span class="p">][</span><span class="ss">0</span><span class="p">]</span>;
<span class="p">3.</span> 当出现状态3时，说明第i天结束后不持有股票，并不处于冷冻期，说明在第i天未买入也未卖出股票，则有两种可能，即第i-1天不持有股票，并处于冷冻期；或第i-1天不持有股票，并不处于冷冻期：
		dp<span class="p">[</span><span class="nv">i</span><span class="p">][</span><span class="ss">1</span><span class="p">]</span> = max(dp<span class="p">[</span><span class="nv">i-1</span><span class="p">][</span><span class="ss">1</span><span class="p">]</span>, dp<span class="p">[</span><span class="nv">i-1</span><span class="p">][</span><span class="ss">2</span><span class="p">]</span>);
</pre></table></code></div></div><p>初始条件：<code class="language-plaintext highlighter-rouge">dp[0][0]</code>表示第1天结束后，持有一支股票，则<code class="language-plaintext highlighter-rouge">dp[0][0] = -prices[0]</code>，<code class="language-plaintext highlighter-rouge">dp[0][1]</code>和<code class="language-plaintext highlighter-rouge">dp[0][2]</code>均为0；</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">maxProfit</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">prices</span><span class="o">)</span> <span class="o">{</span>

        <span class="k">if</span><span class="o">(</span><span class="n">prices</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>

        <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="n">prices</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="mi">3</span><span class="o">];</span>
        <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">prices</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>


        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">l</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="mi">0</span><span class="o">],</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="mi">2</span><span class="o">]-</span><span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">2</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="mi">1</span><span class="o">],</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="mi">2</span><span class="o">]);</span>
        <span class="o">}</span>

        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">dp</span><span class="o">[</span><span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">dp</span><span class="o">[</span><span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span> <span class="o">?</span> <span class="n">dp</span><span class="o">[</span><span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">:</span> <span class="n">dp</span><span class="o">[</span><span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">res</span> <span class="o">&gt;</span> <span class="n">dp</span><span class="o">[</span><span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="mi">2</span><span class="o">]</span> <span class="o">?</span> <span class="n">res</span> <span class="o">:</span> <span class="n">dp</span><span class="o">[</span><span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="mi">2</span><span class="o">];</span>

        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="空间优化">空间优化</h3><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">maxProfit</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">prices</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">prices</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">prices</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">f0</span> <span class="o">=</span> <span class="o">-</span><span class="n">prices</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">f1</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">f2</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">newf0</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">f0</span><span class="o">,</span> <span class="n">f2</span> <span class="o">-</span> <span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="kt">int</span> <span class="n">newf1</span> <span class="o">=</span> <span class="n">f0</span> <span class="o">+</span> <span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="kt">int</span> <span class="n">newf2</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">f1</span><span class="o">,</span> <span class="n">f2</span><span class="o">);</span>
            <span class="n">f0</span> <span class="o">=</span> <span class="n">newf0</span><span class="o">;</span>
            <span class="n">f1</span> <span class="o">=</span> <span class="n">newf1</span><span class="o">;</span>
            <span class="n">f2</span> <span class="o">=</span> <span class="n">newf2</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">f1</span><span class="o">,</span> <span class="n">f2</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump337"></span></p><h2 id="337-打家劫舍-3">337. 打家劫舍 3</h2><p>在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。</p><p>计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。</p><p>示例 1:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>输入: [3,2,3,null,3,null,1]
 3
/ \
2  3
\   \ 
 3   1
 输出: 7 
解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.
</pre></table></code></div></div><p>示例 2:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre> 输入: [3,4,5,1,3,null,1]
     3
    / \
   4   5
  / \   \ 
 1   3   1
 
 输出: 9
解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9.
</pre></table></code></div></div><h3 id="暴力递归">暴力递归</h3><p><strong>4 个孙子偷的钱 + 爷爷的钱 VS 两个儿子偷的钱 哪个组合钱多，就当做当前节点能偷的最大钱数。这就是动态规划里面的最优子结构</strong></p><p>由于是二叉树，这里可以选择计算所有子节点</p><p>4 个孙子投的钱加上爷爷的钱如下 <code class="language-plaintext highlighter-rouge">int method1 = root.val + rob(root.left.left) + rob(root.left.right) + rob(root.right.left) + rob(root.right.right)</code> 两个儿子偷的钱如下 <code class="language-plaintext highlighter-rouge">int method2 = rob(root.left) + rob(root.right);</code> 挑选一个钱数多的方案则 <code class="language-plaintext highlighter-rouge">int result = Math.max(method1, method2);</code></p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="cm">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">rob</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>

        <span class="kt">int</span> <span class="n">money</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
            <span class="n">money</span> <span class="o">+=</span> <span class="n">rob</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">+</span> <span class="n">rob</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
            <span class="n">money</span> <span class="o">+=</span> <span class="n">rob</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">+</span> <span class="n">rob</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
        
        <span class="k">return</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">money</span><span class="o">,</span><span class="n">rob</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">+</span> <span class="n">rob</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">));</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></table></code></div></div><h3 id="记忆化-解决重叠问题">记忆化-解决重叠问题</h3><p>针对解法一种速度太慢的问题，经过分析其实现，我们发现爷爷在计算自己能偷多少钱的时候，同时计算了 4 个孙子能偷多少钱，也计算了 2 个儿子能偷多少钱。这样在儿子当爷爷时，就会产生重复计算一遍孙子节点。</p><p>我们这一步针对重复子问题进行优化，我们在做斐波那契数列时，使用的优化方案是记忆化，但是之前的问题都是使用数组解决的，把每次计算的结果都存起来，下次如果再来计算，就从缓存中取，不再计算了，这样就保证每个数字只计算一次。 由于二叉树不适合拿数组当缓存，我们这次使用哈希表来存储结果，TreeNode 当做 key，能偷的钱当做 value</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre><td class="rouge-code"><pre><span class="cm">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">rob</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">memo</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="k">return</span> <span class="nf">memRob</span><span class="o">(</span><span class="n">root</span><span class="o">,</span><span class="n">memo</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">memRob</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">,</span> <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">memo</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">memo</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">root</span><span class="o">))</span> <span class="k">return</span> <span class="n">memo</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>

        <span class="kt">int</span> <span class="n">money</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
            <span class="n">money</span> <span class="o">+=</span> <span class="n">memRob</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">left</span><span class="o">,</span><span class="n">memo</span><span class="o">)</span> <span class="o">+</span> <span class="n">memRob</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">right</span><span class="o">,</span><span class="n">memo</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
            <span class="n">money</span> <span class="o">+=</span> <span class="n">memRob</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">left</span><span class="o">,</span><span class="n">memo</span><span class="o">)</span> <span class="o">+</span> <span class="n">memRob</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">right</span><span class="o">,</span><span class="n">memo</span><span class="o">);</span>

        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">money</span><span class="o">,</span><span class="n">memRob</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">,</span><span class="n">memo</span><span class="o">)</span> <span class="o">+</span> <span class="n">memRob</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">,</span><span class="n">memo</span><span class="o">));</span>
        
        <span class="n">memo</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">root</span><span class="o">,</span><span class="n">res</span><span class="o">);</span>

        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>每个节点可选择偷或者不偷两种状态，根据题目意思，相连节点不能一起偷</p><p>当前节点选择偷时，那么两个孩子节点就不能选择偷了 当前节点选择不偷时，两个孩子节点只需要拿最多的钱出来就行(两个孩子节点偷不偷没关系) 我们使用一个大小为 2 的数组来表示 <code class="language-plaintext highlighter-rouge">int[] res = new int[2]</code> 0 代表不偷，1 代表偷 <strong>任何一个节点能偷到的最大钱的状态可以定义为</strong></p><ol><li>当前节点选择不偷：当前节点能偷到的最大钱数 = 左孩子能偷到的钱 + 右孩子能偷到的钱</li><li>当前节点选择偷：当前节点能偷到的最大钱数 = 左孩子选择自己不偷时能得到的钱 + 右孩子选择不偷时能得到的钱 + 当前节点的钱数</li></ol><p>表示为公式如下:</p><div class="language-markdown highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>root[0] = Math.max(rob(root.left)[0], rob(root.left)[1]) + Math.max(rob(root.right)[0], rob(root.right)[1])
root[1] = rob(root.left)[0] + rob(root.right)[0] + root.val;
</pre></table></code></div></div><h3 id="规划递归">规划+递归</h3><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">int</span> <span class="nf">rob</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">result</span> <span class="o">=</span> <span class="n">robInternal</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
    <span class="k">return</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">result</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">result</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">robInternal</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>

    <span class="kt">int</span><span class="o">[]</span> <span class="n">left</span> <span class="o">=</span> <span class="n">robInternal</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">right</span> <span class="o">=</span> <span class="n">robInternal</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>

    <span class="n">result</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">left</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">left</span><span class="o">[</span><span class="mi">1</span><span class="o">])</span> <span class="o">+</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">right</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">right</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span>
    <span class="n">result</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">left</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">right</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>

    <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
<span class="o">}</span>

</pre></table></code></div></div><p><span id="jump347"></span></p><h2 id="347前-k-个高频元素">347.前 K 个高频元素</h2><p>给定一个非空的整数数组，返回其中出现频率前 k 高的元素。</p><p>示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="n">nums</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">],</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">2</span>
<span class="nl">输出:</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">]</span>
</pre></table></code></div></div><p>示例 2:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="n">nums</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">],</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span>
<span class="nl">输出:</span> <span class="o">[</span><span class="mi">1</span><span class="o">]</span>
</pre></table></code></div></div><p>提示：</p><ul><li>你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。</li><li>你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。</li><li>题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。</li><li>你可以按任意顺序返回答案。</li></ul><p>先统计所有数出现的次数，放到一个map里，再创建一个有序集合，将map中的key按value的大小降序放入，取出有序集合的前k个元素，即为答案。</p><p>需要注意的是，定制TreeSet比较器的时候，当两个元素相等时，不能返回0，否则不会将相等的元素放入，要返回1，就默认后加入的元素放在了前面（因为是降序排序的，升序排序就会放在后面）。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">topKFrequent</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>

        <span class="c1">//先统计所有数出现的次数，放到一个map里</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span><span class="mi">0</span><span class="o">)+</span><span class="mi">1</span><span class="o">)</span>
        <span class="o">}</span>
        <span class="c1">//再创建一个有序集合，定制比较器。</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">ts</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeSet</span><span class="o">(</span><span class="k">new</span> <span class="nc">Comparator</span><span class="o">()</span> <span class="o">{</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o1</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">o2</span><span class="o">)</span> <span class="o">{</span>
              	<span class="c1">//相等时返回1，其实返回-1也是可以的</span>
                <span class="k">if</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">o1</span><span class="o">)</span> <span class="o">==</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">o2</span><span class="o">)){</span>
                    <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="k">return</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">o2</span><span class="o">)</span> <span class="o">-</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">o1</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">});</span>
	      <span class="c1">//将map中的key按value的大小降序放入</span>
        <span class="n">ts</span><span class="o">.</span><span class="na">addAll</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">keySet</span><span class="o">());</span>
        <span class="nc">Iterator</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">iterator</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="na">iterator</span><span class="o">();</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">k</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">//取出有序集合的前k个元素，即为答案</span>
        <span class="k">while</span><span class="o">(</span><span class="n">iterator</span><span class="o">.</span><span class="na">hasNext</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">k</span><span class="o">){</span>
            <span class="n">res</span><span class="o">[</span><span class="n">n</span><span class="o">++]</span> <span class="o">=</span> <span class="n">iterator</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>也可以用一个数组来替代有序集合：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">topKFrequent</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>

        <span class="c1">//先统计所有数出现的次数，放到一个map里</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span><span class="n">map</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span><span class="mi">0</span><span class="o">)+</span><span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
      	<span class="kt">int</span><span class="o">[][]</span> <span class="n">num</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">len</span><span class="o">][</span><span class="mi">2</span><span class="o">];</span>
      	<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
      	<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span> <span class="o">:</span> <span class="n">map</span><span class="o">.</span><span class="na">keySet</span><span class="o">()){</span>
          	<span class="n">num</span><span class="o">[</span><span class="n">n</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">key</span><span class="o">;</span>
          	<span class="n">num</span><span class="o">[</span><span class="n">n</span><span class="o">++][</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
        <span class="o">}</span>
      	<span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">num</span><span class="o">,(</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">[</span><span class="mi">1</span><span class="o">]-</span><span class="n">a</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span>
	      
        <span class="kt">int</span><span class="o">[]</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">k</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="o">;++</span><span class="n">i</span><span class="o">){</span>
          <span class="n">res</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">num</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>用map+堆：</p><p>在小顶堆中存放目前为止堆元素出现次数为前k大的。如果小顶堆元素个数小于k，就直接插入，否则插入时判断出现次数是否大于堆顶元素，大于就删除堆顶元素，然后执行插入。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">topKFrequent</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">occurrences</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">occurrences</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">num</span><span class="o">,</span> <span class="n">occurrences</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">num</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// int[] 的第一个元素代表数组的值，第二个元素代表了该值出现的次数</span>
        <span class="nc">PriorityQueue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PriorityQueue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;(</span><span class="k">new</span> <span class="nc">Comparator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;()</span> <span class="o">{</span>
            <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">m</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">m</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="n">n</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">});</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">entry</span> <span class="o">:</span> <span class="n">occurrences</span><span class="o">.</span><span class="na">entrySet</span><span class="o">())</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="na">getKey</span><span class="o">(),</span> <span class="n">count</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="na">getValue</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">queue</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">queue</span><span class="o">.</span><span class="na">peek</span><span class="o">()[</span><span class="mi">1</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">count</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
                    <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">num</span><span class="o">,</span> <span class="n">count</span><span class="o">});</span>
                <span class="o">}</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">num</span><span class="o">,</span> <span class="n">count</span><span class="o">});</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">ret</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">k</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">ret</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">()[</span><span class="mi">0</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">ret</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump406"></span></p><h2 id="406根据身高重建队列">406.根据身高重建队列</h2><p>假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对(h, k)表示，其中h是这个人的身高，k是排在这个人前面且身高大于或等于h的人数。 编写一个算法来重建这个队列。</p><p>注意： 总人数少于1100人。</p><p>示例</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="nl">输入:</span>
<span class="o">[[</span><span class="mi">7</span><span class="o">,</span><span class="mi">0</span><span class="o">],</span> <span class="o">[</span><span class="mi">4</span><span class="o">,</span><span class="mi">4</span><span class="o">],</span> <span class="o">[</span><span class="mi">7</span><span class="o">,</span><span class="mi">1</span><span class="o">],</span> <span class="o">[</span><span class="mi">5</span><span class="o">,</span><span class="mi">0</span><span class="o">],</span> <span class="o">[</span><span class="mi">6</span><span class="o">,</span><span class="mi">1</span><span class="o">],</span> <span class="o">[</span><span class="mi">5</span><span class="o">,</span><span class="mi">2</span><span class="o">]]</span>

<span class="nl">输出:</span>
<span class="o">[[</span><span class="mi">5</span><span class="o">,</span><span class="mi">0</span><span class="o">],</span> <span class="o">[</span><span class="mi">7</span><span class="o">,</span><span class="mi">0</span><span class="o">],</span> <span class="o">[</span><span class="mi">5</span><span class="o">,</span><span class="mi">2</span><span class="o">],</span> <span class="o">[</span><span class="mi">6</span><span class="o">,</span><span class="mi">1</span><span class="o">],</span> <span class="o">[</span><span class="mi">4</span><span class="o">,</span><span class="mi">4</span><span class="o">],</span> <span class="o">[</span><span class="mi">7</span><span class="o">,</span><span class="mi">1</span><span class="o">]]</span>
</pre></table></code></div></div><p>观察数组，如果将数组按<code class="language-plaintext highlighter-rouge">people[i][0]</code>逆序排序，然后逐个插入到新数组中，发现<code class="language-plaintext highlighter-rouge">people[i][1]</code>就是此元素需要在数组插入的位置，向后移动数组，再进行插入即可。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[][]</span> <span class="nf">reconstructQueue</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">people</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//将数组按people[i][0]逆序排序</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">people</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">)-&gt;{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">b</span><span class="o">[</span><span class="mi">0</span><span class="o">])</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
            <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">==</span> <span class="n">b</span><span class="o">[</span><span class="mi">0</span><span class="o">]){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">b</span><span class="o">[</span><span class="mi">1</span><span class="o">])</span>
                    <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
                <span class="k">else</span>
                    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span>
                <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">});</span>

        <span class="kt">int</span><span class="o">[][]</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">people</span><span class="o">.</span><span class="na">length</span><span class="o">][</span><span class="mi">2</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">people</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">insert</span><span class="o">(</span><span class="n">res</span><span class="o">,</span><span class="n">people</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">],</span> <span class="n">people</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">],</span> <span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">insert</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">res</span><span class="o">,</span> <span class="kt">int</span> <span class="n">h</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">,</span> <span class="kt">int</span> <span class="n">tail</span><span class="o">){</span>
        <span class="c1">//k是此元素在数组中需要被插入的位置</span>
        <span class="c1">//先把k以后的元素都往后挪，腾出第k个位置</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">tail</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">k</span><span class="o">;</span> <span class="o">--</span><span class="n">i</span><span class="o">){</span>
            <span class="n">res</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">res</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>
            <span class="n">res</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">res</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="n">res</span><span class="o">[</span><span class="n">k</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">h</span><span class="o">;</span>
        <span class="n">res</span><span class="o">[</span><span class="n">k</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">k</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>用list代替数组来提高效率，实际上用的方法是一样的，只不过上面这种方法实现了下面list的底层思想，效率没它高罢了：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[][]</span> <span class="nf">reconstructQueue</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">people</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//将数组按people[i][0]逆序排序</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">people</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">)-&gt;{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">b</span><span class="o">[</span><span class="mi">0</span><span class="o">])</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
            <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">==</span> <span class="n">b</span><span class="o">[</span><span class="mi">0</span><span class="o">]){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">b</span><span class="o">[</span><span class="mi">1</span><span class="o">])</span>
                    <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
                <span class="k">else</span>
                    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span>
                <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">});</span>

        <span class="nc">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">people</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">people</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">],</span><span class="n">people</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">list</span><span class="o">.</span><span class="na">toArray</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">people</span><span class="o">.</span><span class="na">length</span><span class="o">][</span><span class="mi">2</span><span class="o">]);</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump416"></span></p><h2 id="416分割等和子集">416.分割等和子集</h2><p>给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><p>注意:</p><p>每个数组中的元素不会超过 100 数组的大小不会超过 200 示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">11</span><span class="o">,</span> <span class="mi">5</span><span class="o">]</span>

<span class="nl">输出:</span> <span class="kc">true</span>

<span class="nl">解释:</span> <span class="n">数组可以分割成</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">5</span><span class="o">]</span> <span class="n">和</span> <span class="o">[</span><span class="mi">11</span><span class="o">].</span>
</pre></table></code></div></div><p>示例 2:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">]</span>

<span class="nl">输出:</span> <span class="kc">false</span>

<span class="nl">解释:</span> <span class="n">数组不能分割成两个元素和相等的子集</span><span class="o">.</span>
</pre></table></code></div></div><p>动态规划：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">canPartition</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>

        <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">sum</span>  <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">maxNum</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="n">maxNum</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxNum</span><span class="o">,</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
        <span class="o">}</span>

        <span class="c1">//和不能被2整除，肯定false</span>
        <span class="k">if</span><span class="o">(</span><span class="n">sum</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">target</span> <span class="o">=</span> <span class="n">sum</span>  <span class="o">/</span><span class="mi">2</span><span class="o">;</span>
        <span class="c1">//最大元素比总和的一半都大，肯定不能平分</span>
        <span class="k">if</span><span class="o">(</span><span class="n">maxNum</span> <span class="o">&gt;</span> <span class="n">target</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>

        <span class="kt">boolean</span><span class="o">[][]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">][</span><span class="n">target</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>

        <span class="c1">//dp[i][j] 表示是否能够从下标为0~i的数组元素中选取若干个元素时，和为j。</span>

        
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">]]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">target</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                
                <span class="k">if</span><span class="o">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]){</span>
                    <span class="c1">//当j &lt; nums[i]时，肯定不能选nums[i]，所以dp[i][j]只能由dp[i-1][j]决定</span>
                    <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>
                <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                    <span class="c1">//当j &gt;= nums[i]时，nums[i]可选可不选</span>
                    <span class="c1">//如果选了，就取决于dp[i-1][j-nums[i]]是否为true</span>
                    <span class="c1">//如果不选，就取决于d[i-1][j]</span>
                    <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">||</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]];</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="n">target</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump494"></span></p><h2 id="494目标和">494.目标和</h2><p>给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。</p><p>返回可以使最终数组和为目标数 S 的所有添加符号的方法数。</p><p>示例：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="nl">nums:</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">],</span> <span class="nl">S:</span> <span class="mi">3</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">5</span>
<span class="n">解释</span><span class="err">：</span>

<span class="o">-</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span> <span class="o">=</span> <span class="mi">3</span>
<span class="o">+</span><span class="mi">1</span><span class="o">-</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span> <span class="o">=</span> <span class="mi">3</span>
<span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="o">-</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span> <span class="o">=</span> <span class="mi">3</span>
<span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="o">-</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span> <span class="o">=</span> <span class="mi">3</span>
<span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="o">-</span><span class="mi">1</span> <span class="o">=</span> <span class="mi">3</span>

<span class="n">一共有5种方法让最终目标和为3</span><span class="err">。</span>
</pre></table></code></div></div><p>提示：</p><ul><li>数组非空，且长度不会超过 20 。</li><li>初始的数组的和不会超过 1000 。</li><li>保证返回的最终结果能被 32 位整数存下。</li></ul><p>深搜回溯：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">target</span><span class="o">;</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">findTargetSumWays</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="no">S</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">nums</span> <span class="o">=</span> <span class="n">nums</span><span class="o">;</span>
        <span class="n">target</span> <span class="o">=</span> <span class="no">S</span><span class="o">;</span>
        <span class="n">dfs</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">cnt</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">int</span> <span class="n">cur</span><span class="o">,</span> <span class="kt">int</span> <span class="n">sum</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">cur</span> <span class="o">==</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">sum</span> <span class="o">==</span> <span class="n">target</span><span class="o">)</span>    <span class="n">cnt</span><span class="o">++;</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">dfs</span><span class="o">(</span><span class="n">cur</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">sum</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">cur</span><span class="o">]);</span>
        <span class="n">dfs</span><span class="o">(</span><span class="n">cur</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">sum</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="n">cur</span><span class="o">]);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>动态规划：</p><p>这道题也是一个常见的背包问题，我们可以用类似求解背包问题的方法来求出可能的方法数。</p><p>我们用 <code class="language-plaintext highlighter-rouge">dp[i][j] </code>表示用数组中的前 i 个元素，组成和为 j 的方案数。考虑第 i 个数 <code class="language-plaintext highlighter-rouge">nums[i]</code>，它可以被添加 + 或 -，因此状态转移方程如下：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="n">j</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]]</span> <span class="o">+</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="n">j</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]]</span>
</pre></table></code></div></div><p>也可以写成递推的形式：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]]</span> <span class="o">+=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">]</span>
<span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]]</span> <span class="o">+=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">]</span>
</pre></table></code></div></div><p>由于数组中所有数的和不超过 1000，那么 j 的最小值可以达到 -1000。在很多语言中，是不允许数组的下标为负数的，因此我们需要给 dp[i][j] 的第二维预先增加 1000，即：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1000</span><span class="o">]</span> <span class="o">+=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1000</span><span class="o">]</span>
<span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1000</span><span class="o">]</span> <span class="o">+=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">findTargetSumWays</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="no">S</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">][</span><span class="mi">2001</span><span class="o">];</span>
        <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1000</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">][-</span><span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1000</span><span class="o">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1000</span><span class="o">;</span> <span class="n">sum</span> <span class="o">&lt;=</span> <span class="mi">1000</span><span class="o">;</span> <span class="n">sum</span><span class="o">++)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="n">sum</span> <span class="o">+</span> <span class="mi">1000</span><span class="o">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">sum</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1000</span><span class="o">]</span> <span class="o">+=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="n">sum</span> <span class="o">+</span> <span class="mi">1000</span><span class="o">];</span>
                    <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">sum</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1000</span><span class="o">]</span> <span class="o">+=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="n">sum</span> <span class="o">+</span> <span class="mi">1000</span><span class="o">];</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="no">S</span> <span class="o">&gt;</span> <span class="mi">1000</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">dp</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="no">S</span> <span class="o">+</span> <span class="mi">1000</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump538"></span></p><h2 id="538把二叉搜索树转换为累加树">538.把二叉搜索树转换为累加树</h2><p>给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。</p><p>例如：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="nl">原始二叉搜索树:</span>
              <span class="mi">5</span>
            <span class="o">/</span>   <span class="err">\</span>
           <span class="mi">2</span>     <span class="mi">13</span>

<span class="nl">输出:</span> <span class="nl">转换为累加树:</span>
             <span class="mi">18</span>
            <span class="o">/</span>   <span class="err">\</span>
          <span class="mi">20</span>     <span class="mi">13</span>
</pre></table></code></div></div><p>递归反中序遍历，可以得到二叉搜索树的降序排序节点。将较大值加到前一个较小值即可。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>

    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">&gt;</span> <span class="n">nodes</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">TreeNode</span> <span class="nf">convertBST</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="n">inOrder</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
      	<span class="c1">//将节点值累加到较小节点</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nodes</span><span class="o">.</span><span class="na">size</span><span class="o">()-</span><span class="mi">1</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">nodes</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">).</span><span class="na">val</span> <span class="o">+=</span> <span class="n">nodes</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">).</span><span class="na">val</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">root</span><span class="o">;</span>
    <span class="o">}</span>
		<span class="c1">//逆中序遍历，将节点添加到list中</span>
    <span class="kt">void</span> <span class="nf">inOrder</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
            <span class="k">return</span><span class="o">;</span>
        
        <span class="n">inOrder</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
        <span class="n">nodes</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
        <span class="n">inOrder</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>或：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>

    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">TreeNode</span> <span class="nf">convertBST</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="n">convertBST</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
            <span class="n">root</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">sum</span><span class="o">;</span>
            <span class="n">convertBST</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
        <span class="o">}</span>   
        <span class="k">return</span> <span class="n">root</span><span class="o">;</span>
    <span class="o">}</span>    
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump560"></span></p><h2 id="560和为k的子数组">560.和为K的子数组</h2><p>给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。</p><p>示例 1 :</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span><span class="n">nums</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">],</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">2</span>
<span class="nl">输出:</span> <span class="mi">2</span> <span class="o">,</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">]</span> <span class="n">与</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">]</span> <span class="n">为两种不同的情况</span><span class="err">。</span>
</pre></table></code></div></div><p>说明 :</p><ul><li>数组的长度为 [1, 20,000]。</li><li>数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]。</li></ul><p>暴力遍历子数组：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">subarraySum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        
        <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="o">--</span><span class="n">j</span><span class="o">){</span>
                <span class="n">sum</span> <span class="o">+=</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
                <span class="k">if</span><span class="o">(</span><span class="n">sum</span> <span class="o">==</span> <span class="n">k</span><span class="o">){</span>
                    <span class="n">cnt</span><span class="o">++;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">cnt</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>记录前缀和，统计<code class="language-plaintext highlighter-rouge">pre[j] = pre[i] - k</code>的个数。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">subarraySum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">//pre[i]表示从[0,i]的元素之和，那么我们只需要找到所有符合条件的下标j</span>
        <span class="c1">//使得pre[j] == pre[i] - k即可，这样的j可能有多个，所以我们把所有元素的前缀和pre[i]都放入一个哈希表中</span>
        <span class="c1">//再从左往右遍历数组，统计pre[j]出现的次数</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">pre</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">pre</span> <span class="o">+=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="k">if</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">pre</span> <span class="o">-</span> <span class="n">k</span><span class="o">)){</span>
               <span class="n">cnt</span> <span class="o">+=</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">pre</span> <span class="o">-</span> <span class="n">k</span><span class="o">);</span> 
            <span class="o">}</span>
            <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">pre</span><span class="o">,</span> <span class="n">map</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">pre</span><span class="o">,</span> <span class="mi">0</span><span class="o">)+</span><span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">cnt</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump581"></span></p><h2 id="581最短无序连续子数组">581.最短无序连续子数组</h2><p>给定一个整数数组，你需要寻找一个连续的子数组，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。</p><p>你找到的子数组应是最短的，请输出它的长度。</p><p>示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="o">[</span><span class="mi">2</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">15</span><span class="o">]</span>
<span class="nl">输出:</span> <span class="mi">5</span>
<span class="nl">解释:</span> <span class="n">你只需要对</span> <span class="o">[</span><span class="mi">6</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">9</span><span class="o">]</span> <span class="n">进行升序排序</span><span class="err">，</span><span class="n">那么整个表都会变为升序排序</span><span class="err">。</span>
</pre></table></code></div></div><p>说明 :</p><ul><li>输入的数组长度范围在 [1, 10,000]。</li><li>输入的数组可能包含重复元素 ，所以升序的意思是&lt;=。</li></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">findUnsortedSubarray</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//有可能这个子数组长度为0</span>
        <span class="c1">//初始化指针，[start, end]表示需要排序的子数组</span>
        <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">end</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        <span class="c1">//max记录[0,i]的最大值</span>
        <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="c1">//每找到一个逆序对，即nums[i] &lt; max，就从[0, start]中搜索第一个比nums[i]大的数，更新start</span>
            <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">max</span><span class="o">){</span>
                <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">start</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]){</span>
                        <span class="c1">//往前更新start</span>
                        <span class="n">start</span> <span class="o">=</span> <span class="n">j</span><span class="o">;</span>
                        <span class="k">break</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span>
                <span class="c1">//更新end</span>
                <span class="n">end</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">max</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">max</span><span class="o">,</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">end</span> <span class="o">==</span> <span class="n">start</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump617"></span></p><h2 id="617合并二叉树">617.合并二叉树</h2><p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p><p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</p><p>示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> 
				<span class="nc">Tree</span> <span class="mi">1</span>                     <span class="nc">Tree</span> <span class="mi">2</span>                  
          <span class="mi">1</span>                         <span class="mi">2</span>                             
         <span class="o">/</span> <span class="err">\</span>                       <span class="o">/</span> <span class="err">\</span>                            
        <span class="mi">3</span>   <span class="mi">2</span>                     <span class="mi">1</span>   <span class="mi">3</span>                        
       <span class="o">/</span>                           <span class="err">\</span>   <span class="err">\</span>                      
      <span class="mi">5</span>                             <span class="mi">4</span>   <span class="mi">7</span>                  
<span class="nl">输出:</span> 
<span class="nl">合并后的树:</span>
	     <span class="mi">3</span>
	    <span class="o">/</span> <span class="err">\</span>
	   <span class="mi">4</span>   <span class="mi">5</span>
	  <span class="o">/</span> <span class="err">\</span>   <span class="err">\</span> 
	 <span class="mi">5</span>   <span class="mi">4</span>   <span class="mi">7</span>
</pre></table></code></div></div><p>注意: 合并必须从两个树的根节点开始。</p><p>以Tree 2为参照，同时遍历两颗树：</p><ul><li>如果Tree2的左子节点不为空，就在Tree1的左子节点上合并这个节点，如果此时Tree1的左子节点为空，就新建一个值为0的节点，再合并。</li><li>如果Tree2的右子节点不为空，就在Tree1的右子节点上合并这个节点，如果此时Tree1的右子节点为空，就新建一个值为0的节点，再合并。</li><li>Tree2子树为空的情况无需处理</li></ul><p>最终返回Tree1，即为答案。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">TreeNode</span> <span class="nf">mergeTrees</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">t1</span><span class="o">,</span> <span class="nc">TreeNode</span> <span class="n">t2</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">t1</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>  <span class="k">return</span> <span class="n">t2</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">t2</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>  <span class="k">return</span> <span class="n">t1</span><span class="o">;</span>
        <span class="n">merge</span><span class="o">(</span><span class="n">t1</span><span class="o">,</span><span class="n">t2</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">t1</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kt">void</span> <span class="nf">merge</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">t1</span><span class="o">,</span> <span class="nc">TreeNode</span> <span class="n">t2</span><span class="o">){</span>
        <span class="c1">//传进来的节点肯定不为空</span>
        <span class="n">t1</span><span class="o">.</span><span class="na">val</span> <span class="o">+=</span> <span class="n">t2</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">t2</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">t1</span><span class="o">.</span><span class="na">left</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
                <span class="n">t1</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="c1">//合并左子树</span>
            <span class="n">merge</span><span class="o">(</span><span class="n">t1</span><span class="o">.</span><span class="na">left</span><span class="o">,</span><span class="n">t2</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">if</span><span class="o">(</span><span class="n">t2</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">t1</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
                <span class="n">t1</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="c1">//合并右子树</span>
            <span class="n">merge</span><span class="o">(</span><span class="n">t1</span><span class="o">.</span><span class="na">right</span><span class="o">,</span><span class="n">t2</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>或：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">TreeNode</span> <span class="nf">mergeTrees</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">t1</span><span class="o">,</span> <span class="nc">TreeNode</span> <span class="n">t2</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">t1</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>  <span class="k">return</span> <span class="n">t2</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">t2</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>  <span class="k">return</span> <span class="n">t1</span><span class="o">;</span>

        <span class="nc">TreeNode</span> <span class="n">merge</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="n">t1</span><span class="o">.</span><span class="na">val</span> <span class="o">+</span> <span class="n">t2</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
        <span class="n">merge</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">mergeTrees</span><span class="o">(</span><span class="n">t1</span><span class="o">.</span><span class="na">left</span><span class="o">,</span><span class="n">t2</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
        <span class="n">merge</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">mergeTrees</span><span class="o">(</span><span class="n">t1</span><span class="o">.</span><span class="na">right</span><span class="o">,</span><span class="n">t2</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>

        <span class="k">return</span> <span class="n">merge</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump621"></span></p><h2 id="621任务调度器">621.任务调度器</h2><p>给定一个用字符数组表示的 CPU 需要执行的任务列表。其中包含使用大写的 A - Z 字母表示的26 种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。CPU 在任何一个单位时间内都可以执行一个任务，或者在待命状态。</p><p>然而，两个相同种类的任务之间必须有长度为 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。</p><p>你需要计算完成所有任务所需要的最短时间。</p><p>示例 ：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">tasks</span> <span class="o">=</span> <span class="o">[</span><span class="s">"A"</span><span class="o">,</span><span class="s">"A"</span><span class="o">,</span><span class="s">"A"</span><span class="o">,</span><span class="s">"B"</span><span class="o">,</span><span class="s">"B"</span><span class="o">,</span><span class="s">"B"</span><span class="o">],</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">8</span>
<span class="n">解释</span><span class="err">：</span><span class="no">A</span> <span class="o">-&gt;</span> <span class="no">B</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="n">待命</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="no">A</span> <span class="o">-&gt;</span> <span class="no">B</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="n">待命</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="no">A</span> <span class="o">-&gt;</span> <span class="no">B</span><span class="o">.</span>
     <span class="n">在本示例中</span><span class="err">，</span><span class="n">两个相同类型任务之间必须间隔长度为</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">2</span> <span class="n">的冷却时间</span><span class="err">，</span><span class="n">而执行一个任务只需要一个单位时间</span><span class="err">，</span><span class="n">所以中间出现了</span><span class="err">（</span><span class="n">待命</span><span class="err">）</span><span class="n">状态</span><span class="err">。</span> 
</pre></table></code></div></div><p>提示：</p><ul><li>任务的总个数为 [1, 10000]。</li><li>n 的取值范围为 [0, 100]。</li></ul><p>每次从任务列表中选取剩余次数最多的n+1个任务执行，如果剩余任务没有超过n+1个，则选取剩余所有任务执行，多余的时间待命。</p><p>只要每次选取剩余次数最多的n+1个任务，那么下一轮选取的时候，每个任务都是处于可选择状态。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">leastInterval</span><span class="o">(</span><span class="kt">char</span><span class="o">[]</span> <span class="n">tasks</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">rest</span> <span class="o">=</span> <span class="n">tasks</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">counts</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span>
				<span class="c1">//记录所有任务的次数</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tasks</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">tasks</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="mi">65</span><span class="o">;</span>
            <span class="n">counts</span><span class="o">[</span><span class="n">index</span><span class="o">]++;</span>
        <span class="o">}</span>

        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">counts</span><span class="o">);</span>

        <span class="k">while</span><span class="o">(</span><span class="n">counts</span><span class="o">[</span><span class="mi">25</span><span class="o">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span>
          	<span class="c1">//选取剩余次数最多的n+1个任务</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
              	<span class="c1">//剩余次数最多的任务，次数都为0了，那么就执行完毕了</span>
                <span class="k">if</span><span class="o">(</span><span class="n">counts</span><span class="o">[</span><span class="mi">25</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="k">if</span><span class="o">(</span> <span class="mi">25</span> <span class="o">-</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">counts</span><span class="o">[</span><span class="mi">25</span> <span class="o">-</span> <span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
                    <span class="n">counts</span><span class="o">[</span><span class="mi">25</span><span class="o">-</span><span class="n">i</span><span class="o">]--;</span>
                <span class="n">res</span><span class="o">++;</span>
            <span class="o">}</span>
          	<span class="c1">//选取完后，需要重新排序</span>
            <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">counts</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>最小堆解法：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">leastInterval</span><span class="o">(</span><span class="kt">char</span><span class="o">[]</span> <span class="n">tasks</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>

        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">counts</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tasks</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">tasks</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="mi">65</span><span class="o">;</span>
            <span class="n">counts</span><span class="o">[</span><span class="n">index</span><span class="o">]++;</span>
        <span class="o">}</span>

        <span class="nc">PriorityQueue</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PriorityQueue</span><span class="o">&lt;&gt;(</span><span class="mi">26</span><span class="o">,</span> <span class="nc">Collections</span><span class="o">.</span><span class="na">reverseOrder</span><span class="o">());</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">:</span> <span class="n">counts</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
                <span class="n">queue</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>


        <span class="k">while</span><span class="o">(!</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
            <span class="c1">//为了避免重复选取任务，每次取出一个任务时，先放入list中，最后再统一插入到最小堆</span>
            <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(!</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">queue</span><span class="o">.</span><span class="na">peek</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">)</span>
                        <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
                    <span class="k">else</span>
                        <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
                <span class="o">}</span>
                <span class="n">res</span><span class="o">++;</span>
                <span class="k">if</span><span class="o">(</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
                    <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">e</span> <span class="o">:</span> <span class="n">list</span><span class="o">){</span>
                <span class="n">queue</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump647"></span></p><h2 id="647-回文子串">647. 回文子串</h2><p>给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。</p><p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="s">"abc"</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">3</span>
<span class="n">解释</span><span class="err">：</span><span class="nl">三个回文子串:</span> <span class="s">"a"</span><span class="o">,</span> <span class="s">"b"</span><span class="o">,</span> <span class="s">"c"</span>
</pre></table></code></div></div><p>示例 2：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="s">"aaa"</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">6</span>
<span class="n">解释</span><span class="err">：</span><span class="mi">6</span><span class="nl">个回文子串:</span> <span class="s">"a"</span><span class="o">,</span> <span class="s">"a"</span><span class="o">,</span> <span class="s">"a"</span><span class="o">,</span> <span class="s">"aa"</span><span class="o">,</span> <span class="s">"aa"</span><span class="o">,</span> <span class="s">"aaa"</span>
</pre></table></code></div></div><p>提示：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">输入的字符串长度不会超过</span> <span class="mi">1000</span> <span class="err">。</span>
</pre></table></code></div></div><h3 id="暴力法">暴力法</h3><p>遍历所有子串</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">countSubstrings</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                <span class="n">cnt</span> <span class="o">+=</span> <span class="n">isPlindromeString</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">i</span><span class="o">,</span><span class="n">j</span><span class="o">));</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">cnt</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kt">int</span> <span class="nf">isPlindromeString</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">l</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">l</span><span class="o">)</span> <span class="o">!=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">r</span><span class="o">))</span>
                <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
            <span class="o">++</span><span class="n">l</span><span class="o">;</span>
            <span class="o">--</span><span class="n">r</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>剪枝</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">countSubstrings</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
        <span class="kt">boolean</span> <span class="n">flag</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
      	<span class="c1">//------------剪枝------------------</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">!=</span> <span class="n">c</span><span class="o">){</span>
                <span class="n">flag</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">if</span><span class="o">(</span><span class="n">flag</span><span class="o">)</span> <span class="k">return</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()*(</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">+</span> <span class="mi">1</span><span class="o">))/</span><span class="mi">2</span><span class="o">;</span>
      	<span class="c1">//------------剪枝------------------</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                <span class="n">cnt</span> <span class="o">+=</span> <span class="n">isPlindromeString</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">i</span><span class="o">,</span><span class="n">j</span><span class="o">));</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">cnt</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kt">int</span> <span class="nf">isPlindromeString</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">l</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">l</span><span class="o">)</span> <span class="o">!=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">r</span><span class="o">))</span>
                <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
            <span class="o">++</span><span class="n">l</span><span class="o">;</span>
            <span class="o">--</span><span class="n">r</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="回文中心法">回文中心法</h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/HYCBlog/assets/img/leetcode/leetcode_回文子串.png" alt="leetcode_回文子串" /></p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">countSubstrings</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">(),</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="n">i</span> <span class="o">/</span> <span class="mi">2</span><span class="o">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">i</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span><span class="o">;</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">l</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">l</span><span class="o">)</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">r</span><span class="o">))</span> <span class="o">{</span>
                <span class="o">--</span><span class="n">l</span><span class="o">;</span>
                <span class="o">++</span><span class="n">r</span><span class="o">;</span>
                <span class="o">++</span><span class="n">ans</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="manacher算法">Manacher算法</h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/HYCBlog/assets/img/leetcode/leetcode_回文子串_Manacher算法_1.png" alt="leetcode_回文子串_Manacher算法_1" /></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/HYCBlog/assets/img/leetcode/leetcode_回文子串_Manacher算法_2.png" alt="leetcode_回文子串_Manacher算法_2" /></p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">countSubstrings</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="nc">StringBuffer</span> <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuffer</span><span class="o">(</span><span class="s">"$#"</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">t</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
            <span class="n">t</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="sc">'#'</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="n">t</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="sc">'!'</span><span class="o">);</span>

        <span class="kt">int</span><span class="o">[]</span> <span class="n">f</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">iMax</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">rMax</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 初始化 f[i]</span>
            <span class="n">f</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">rMax</span> <span class="o">?</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">rMax</span> <span class="o">-</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">f</span><span class="o">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">iMax</span> <span class="o">-</span> <span class="n">i</span><span class="o">])</span> <span class="o">:</span> <span class="mi">1</span><span class="o">;</span>
            <span class="c1">// 中心拓展</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">f</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">==</span> <span class="n">t</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">f</span><span class="o">[</span><span class="n">i</span><span class="o">]))</span> <span class="o">{</span>
                <span class="o">++</span><span class="n">f</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="o">}</span>
            <span class="c1">// 动态维护 iMax 和 rMax</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">f</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="n">rMax</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">iMax</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
                <span class="n">rMax</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">f</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="c1">// 统计答案, 当前贡献为 (f[i] - 1) / 2 上取整</span>
            <span class="n">ans</span> <span class="o">+=</span> <span class="n">f</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="n">作者</span><span class="err">：</span><span class="nc">LeetCode</span><span class="o">-</span><span class="nc">Solution</span>
<span class="n">链接</span><span class="err">：</span><span class="nl">https:</span><span class="c1">//leetcode-cn.com/problems/palindromic-substrings/solution/hui-wen-zi-chuan-by-leetcode-solution/</span>
<span class="n">来源</span><span class="err">：</span><span class="n">力扣</span><span class="err">（</span><span class="nc">LeetCode</span><span class="err">）</span>
<span class="n">著作权归作者所有</span><span class="err">。</span><span class="n">商业转载请联系作者获得授权</span><span class="err">，</span><span class="n">非商业转载请注明出处</span><span class="err">。</span>
</pre></table></code></div></div></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/HYCBlog/categories/blogging/'>Blogging</a>, <a href='/HYCBlog/categories/leetcode/'>leetcode</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/HYCBlog/tags/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/" class="post-tag no-text-decoration" >算法题解</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><!-- Post sharing snippet v2.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2019 Cotes Chung Published under the MIT License --><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Leetcode题解:Hot 100! - 黄玉才的博客&url=www.yucaihuang.com/HYCBlog/posts/leetcode-solution_hot_100/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Leetcode题解:Hot 100! - 黄玉才的博客&u=www.yucaihuang.com/HYCBlog/posts/leetcode-solution_hot_100/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Leetcode题解:Hot 100! - 黄玉才的博客&url=www.yucaihuang.com/HYCBlog/posts/leetcode-solution_hot_100/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><!-- The Pannel on right side (Desktop views) v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"><h3 data-toc-skip>Recent Update</h3><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/HYCBlog/posts/leetcode-solution_hot_100/">Leetcode题解:Hot 100!</a></li><li><a href="/HYCBlog/posts/leetcode-solution_200_500/">Leetcode题解:200~500</a></li><li><a href="/HYCBlog/posts/leetcode-solution_101_200/">Leetcode题解:101~200</a></li><li><a href="/HYCBlog/posts/leetcode-solution_0_100/">Leetcode题解:1~100</a></li></ul></div><div id="access-tags"><h3 data-toc-skip>Trending Tags</h3><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/HYCBlog/tags/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/">算法题解</a> <a class="post-tag" href="/HYCBlog/tags/java/">java</a> <a class="post-tag" href="/HYCBlog/tags/java%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/">Java源码学习</a> <a class="post-tag" href="/HYCBlog/tags/algorithms/">Algorithms</a> <a class="post-tag" href="/HYCBlog/tags/web/">web</a> <a class="post-tag" href="/HYCBlog/tags/security/">security</a> <a class="post-tag" href="/HYCBlog/tags/redis/">redis</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><h3 data-toc-skip class="pl-3 pt-2 mb-2">Contents</h3><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"> <!-- Recommend the other 3 posts according to the tags and categories of the current post, if the number is not enough, use the other latest posts to supplement. v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2019 Cotes Chung Published under the MIT License --><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/HYCBlog/posts/leetcode-hard_0/"><div class="card-body"> <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <span class="timeago small" > Sep 16 <i class="unloaded">2020-09-16T21:14:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>处理大数：剑指 Offer 14- II. 剪绳子 II</h3><div class="text-muted small"><p> 这题做了很久，做不出来，看题解也看了好久，难点在于证明过程，以及如何对大数求余。这题单独列出来，需要多看看，否则下次碰到了还是不会。 题目描述 给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m - 1] 。请问 k[0]k[1]…*k[m - 1] 可能的最大乘积是多少？例如，当绳子...</p></div></div></a></div><div class="card"> <a href="/HYCBlog/posts/leetcode-solution_0_100/"><div class="card-body"> <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <span class="timeago small" > Sep 23 <i class="unloaded">2020-09-23T08:29:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Leetcode题解:1~100</h3><div class="text-muted small"><p> 目录 1.两数之和 5.最长回文子串 16.最接近三数之和 17.电话号码的字母组合 18.四数之和 19.删除链表的倒数第N个节点 24.两两交换链表中的节点 37.解数独 39.组合总和1 40.组合总和2 43.字符串相乘 47.全排列 51.N 皇后 52.N皇后 II[tag] 60.第k个排列[tag] 62.不同路径 63.含障碍物网格中的不同...</p></div></div></a></div><div class="card"> <a href="/HYCBlog/posts/leetcode-solution_101_200/"><div class="card-body"> <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <span class="timeago small" > Sep 23 <i class="unloaded">2020-09-23T08:29:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Leetcode题解:101~200</h3><div class="text-muted small"><p> 目录 106.从中序与后序遍历序列构造二叉树 107.二叉树的层次遍历 II 108. 将有序数组转换为二叉搜索树 109. 有序链表转换二叉搜索树 110.平衡二叉树 111. 二叉树的最小深度 112. 路径总和 113.路径总和 II 144.二叉树的前序遍历 116.填充每个节点的下一个右侧节点指针 117.填充每个节点的下一个右侧节点指针 II 120.三...</p></div></div></a></div></div></div><!-- Navigation buttons at the bottom of the post. v2.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --><div class="post-navigation d-flex justify-content-between"> <a href="/HYCBlog/posts/redis-sentinel/" class="btn btn-outline-primary"><p>用Docker搭建一套Redis Sentinel集群</p></a> <a href="/HYCBlog/posts/javaweb-seckill/" class="btn btn-outline-primary"><p>JavaWeb SSM+Maven实现简单的秒杀系统</p></a></div></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('#post-wrapper img'); const observer = lozad(imgs); observer.observe(); </script> <!-- The Footer v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><footer class="d-flex w-100 justify-content-center"><p class="footer-center"> © 2020 <a href="">Yucai Huang</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span> <br> <a href="https://beian.miit.gov.cn/" target="_blank">浙ICP备2020032055号-1</a></p></footer></div><!-- The Search results v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-xl-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/HYCBlog/tags/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/">算法题解</a> <a class="post-tag" href="/HYCBlog/tags/java/">java</a> <a class="post-tag" href="/HYCBlog/tags/java%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/">Java源码学习</a> <a class="post-tag" href="/HYCBlog/tags/algorithms/">Algorithms</a> <a class="post-tag" href="/HYCBlog/tags/web/">web</a> <a class="post-tag" href="/HYCBlog/tags/security/">security</a> <a class="post-tag" href="/HYCBlog/tags/redis/">redis</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <!-- The GA snippet v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','https://www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-176388509-1', 'auto'); ga('send', 'pageview'); </script> <script> (function(e,t,n,i,s,a,c){e[n]=e[n]||function(){(e[n].q=e[n].q||[]).push(arguments)} ;a=t.createElement(i);c=t.getElementsByTagName(i)[0];a.async=true;a.src=s ;c.parentNode.insertBefore(a,c) })(window,document,"galite","script","https://cdn.jsdelivr.net/npm/ga-lite@2/dist/ga-lite.min.js"); galite('create', '{"id"=>"UA-176388509-1", "pv"=>{"enabled"=>false, "proxy_url"=>"", "proxy_endpoint"=>"", "cache"=>true}}', 'auto'); galite('send', 'pageview'); </script> <!-- Jekyll Simple Search loader v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/HYCBlog/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="www.yucaihuang.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"><div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>{categories}</div><div><i class="fa fa-tag fa-fw"></i>{tags}</div></div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>' }); </script>
