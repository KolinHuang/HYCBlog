<!DOCTYPE html><html lang="en" > <!-- The Head v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Leetcode题解:200~500 | 黄玉才的博客</title><meta name="generator" content="Jekyll v4.1.1" /><meta property="og:title" content="Leetcode题解:200~500" /><meta name="author" content="Kol Huang" /><meta property="og:locale" content="en_US" /><meta name="description" content="目录" /><meta property="og:description" content="目录" /><link rel="canonical" href="www.yucaihuang.com/HYCBlog/posts/leetcode-solution_200_500/" /><meta property="og:url" content="www.yucaihuang.com/HYCBlog/posts/leetcode-solution_200_500/" /><meta property="og:site_name" content="黄玉才的博客" /><meta property="og:image" content="www.yucaihuang.com/HYCBlog/HYCBlog/assets/img/leetcode/leetcode_cover.jpg" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2020-09-23T08:29:00+08:00" /><meta name="twitter:card" content="summary_large_image" /><meta property="twitter:image" content="www.yucaihuang.com/HYCBlog/HYCBlog/assets/img/leetcode/leetcode_cover.jpg" /><meta property="twitter:title" content="Leetcode题解:200~500" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@Kol Huang" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"image":"www.yucaihuang.com/HYCBlog/HYCBlog/assets/img/leetcode/leetcode_cover.jpg","mainEntityOfPage":{"@type":"WebPage","@id":"www.yucaihuang.com/HYCBlog/posts/leetcode-solution_200_500/"},"url":"www.yucaihuang.com/HYCBlog/posts/leetcode-solution_200_500/","author":{"@type":"Person","name":"Kol Huang"},"description":"目录","dateModified":"2020-09-23T08:29:00+08:00","datePublished":"2020-09-23T08:29:00+08:00","headline":"Leetcode题解:200~500","@type":"BlogPosting","@context":"https://schema.org"}</script> <!-- The Favicons for Web, Android, Microsoft, and iOS (iPhone and iPad) Apps Generated by: https://www.favicon-generator.org/ v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2019 Cotes Chung Published under the MIT license --><link rel="shortcut icon" href="/HYCBlog/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/HYCBlog/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/HYCBlog/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/HYCBlog/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/HYCBlog/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/HYCBlog/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/HYCBlog/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/HYCBlog/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/HYCBlog/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/HYCBlog/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/HYCBlog/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/HYCBlog/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/HYCBlog/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/HYCBlog/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/HYCBlog/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/HYCBlog/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/HYCBlog/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/HYCBlog/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/HYCBlog/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/HYCBlog/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="preload" as="style" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"> <!-- CSS selector for site. Chirpy v2.3 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT Licensed --><link rel="preload" as="style" href="/HYCBlog/assets/css/post.css"><link rel="stylesheet" href="/HYCBlog/assets/css/post.css"><link rel="preload" as="style" href="/HYCBlog/assets/css/lib/bootstrap-toc.min.css"><link rel="stylesheet" href="/HYCBlog/assets/css/lib/bootstrap-toc.min.css" /><link rel="preload" as="script" href="https://cdn.jsdelivr.net/npm/jquery@3.4.1" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"> <script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4.0.0/dist/js/bootstrap.min.js" async></script> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-176388509-1"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-176388509-1'); </script> <!-- JS selector for site. Chirpy v2.3 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT Licensed --> <script src="/HYCBlog/assets/js/post.min.js" async></script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" async></script> <script src="/HYCBlog/app.js" defer></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column"> <!-- The Side Bar v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><div id="nav-wrapper"><div id="profile-wrapper" class="d-flex flex-column"><div id="avatar" class="d-flex justify-content-center"> <a href="http://www.yucaihuang.com" alt="avatar"> <img src="/HYCBlog/assets/img/daliy/avatar.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="profile-text mt-3"><div class="site-title"> <a href="/HYCBlog/">黄玉才的博客</a></div><div class="site-subtitle font-italic">把开源的变成自己的，把自己的变成祖传的!</div></div></div><ul class="nav flex-column"><li class="nav-item d-flex justify-content-center "> <a href="/HYCBlog/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/HYCBlog/tabs/categories/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/HYCBlog/tabs/tags/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/HYCBlog/tabs/archives/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/HYCBlog/tabs/about/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></li></ul></div><div class="sidebar-bottom d-flex flex-wrap justify-content-around mt-4"> <span id="mode-toggle-wrapper"> <!-- Switch the mode between dark and light. v2.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <i class="mode-toggle fas fa-sun" dark-mode-invisible></i> <i class="mode-toggle fas fa-moon" light-mode-invisible></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.mode != null) { if (this.mode == ModeToggle.DARK_MODE) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.mode != null) { if (self.mode == ModeToggle.DARK_MODE) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightkMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightkMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span> <span class="icon-border"></span> <a href="https://github.com/KolinHuang" target="_blank"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/twitter_username" target="_blank"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:window.open('mailto:' + ['yc_huang97','163.com'].join('@'))" > <i class="fas fa-envelope"></i> </a></div></div><!-- The Top Bar v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/HYCBlog/"> Posts </a> </span> <span>Leetcode题解:200~500</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"> <!-- Refactor the HTML structure. --> <!-- Suroundding the markdown table with '<div class="table-wrapper">. and '</div>' --> <!-- Fixed kramdown code highlight rendering: https://github.com/penibelst/jekyll-compress-html/issues/101 https://github.com/penibelst/jekyll-compress-html/issues/71#issuecomment-188144901 --><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Leetcode题解:200~500</h1><div class="post-meta text-muted d-flex flex-column"><div> Posted <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Sep 23, 2020, 8:29 AM +0800" > Sep 23, 2020 <i class="unloaded">2020-09-23T08:29:00+08:00</i> </span> by <span class="author"> Kol Huang</div><div> Updated <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Thu, Dec 31, 2020, 8:56 AM +0800" > Dec 31, 2020 <i class="unloaded">2020-12-31T08:56:45+08:00</i> </span></div></div><div class="post-content"> <img src="/HYCBlog/assets/img/leetcode/leetcode_cover.jpg" class="post-preview-img"><h2 id="目录">目录</h2><p><a href="#jump201">201.数字范围按位与</a></p><p><a href="#jump204">204.计数质数</a></p><p><a href="#jump206">206.反转链表</a></p><p><a href="#jump209">209.寻找长度最小的子数组</a></p><p><a href="#jump214">214.最短回文串</a></p><p><a href="#jump216">216.组合总和3</a></p><p><a href="#jump221">221.最大正方形</a></p><p><a href="#jump222">222.完全二叉树的节点个数</a></p><p><a href="#jump235">235.二叉树的最近公共祖先</a></p><p><a href="#jump242">242.有效的字母异位词</a></p><p><a href="#jump257">257.二叉树的所有路径</a></p><p><a href="#jump316">316. 去除重复字母</a></p><p><a href="#jump321">321.拼接最大数[tag]</a></p><p><a href="#jump327">327.区间和的个数[tag]</a></p><p><a href="#jump328">328.奇偶链表</a></p><p><a href="#jump332">332.重新安排行程</a></p><p><a href="#jump336">336.回文对</a></p><p><a href="#jump349">349.两个数组的交集</a></p><p><a href="#jump376">376. 摆动序列</a></p><p><a href="#jump378">378.有序矩阵中第K小元素</a></p><p><a href="#jump381">381.O(1) 时间插入、删除和获取随机元素 - 允许重复</a></p><p><a href="#jump387">387. 字符串中的第一个唯一字符</a></p><p><a href="#jump389">389. 找不同</a></p><p><a href="#jumo344">344.反转字符串</a></p><p><a href="#jump402">402.移掉K位数字</a></p><p><a href="#jump404">404.左叶子之和</a></p><p><a href="#jump416">416.分割等和子集</a></p><p><a href="#jump435">435. 无重叠区间</a></p><p><a href="#jump437">437.路径总和 III</a></p><p><a href="#jump438">438.找到字符串中所有字母异位词</a></p><p><a href="#jump452">452.用最少数量的箭引爆气球</a></p><p><a href="#jump455">455. 分发饼干</a></p><p><a href="#jump459">459.重复的子字符串</a></p><p><a href="#jump463">463.岛屿的周长</a></p><p><a href="#jump486">486.预测赢家</a></p><p><a href="#jump493">493.翻转对</a></p><p><span id="jump201"></span></p><h2 id="201数字范围按位与">201.数字范围按位与</h2><p>给定范围 [m, n]，其中 0 &lt;= m &lt;= n &lt;= 2147483647，返回此范围内所有数字的按位与（包含 m, n 两端点）。</p><p>示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="o">[</span><span class="mi">5</span><span class="o">,</span><span class="mi">7</span><span class="o">]</span>
<span class="nl">输出:</span> <span class="mi">4</span>
</pre></table></code></div></div><p>示例 2:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">]</span>
<span class="nl">输出:</span> <span class="mi">0</span>
</pre></table></code></div></div><h3 id="分析法-最长公共前缀">分析法-最长公共前缀</h3><p>通过分析，若m和n转为二进制字符串后，长度不一致，则在这个范围内按位与后，结果必为0。例如：</p><div class="language-markdown highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>m = 11110011
n = 101101111
在范围[m,n]中，肯定会出现100000000的情况，所以有：
100000000 &amp; 101101111 = 100000000,且100000000 &amp; 11111111 = 000000000
所以结果为0
</pre></table></code></div></div><p>长度一致的情况下，结果就是m和n的最长公共前缀。</p><div class="language-markdown highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>m = 101101101
n = 101101111
最长前缀为1011011，最后两位需要归0，因为在范围[m,n]中，会出现数字101101100使得最终结果的两位归0。
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">rangeBitwiseAnd</span><span class="o">(</span><span class="kt">int</span> <span class="n">m</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">m</span> <span class="o">==</span> <span class="n">n</span><span class="o">)</span>  <span class="k">return</span> <span class="n">m</span><span class="o">;</span>

        <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">toBinaryString</span><span class="o">(</span><span class="n">m</span><span class="o">);</span>
        <span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">toBinaryString</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">s1</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">!=</span> <span class="n">s2</span><span class="o">.</span><span class="na">length</span><span class="o">())</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>

        <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">//找到两个字符串第一个不同的位置</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s1</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">s1</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">!=</span> <span class="n">s2</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)){</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">//取出其公共前缀，剩余位都替换为0</span>
        <span class="nc">String</span> <span class="n">sub1</span> <span class="o">=</span> <span class="n">s1</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="n">index</span><span class="o">);</span>
        <span class="nc">String</span> <span class="n">sub2</span> <span class="o">=</span> <span class="n">s1</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">index</span><span class="o">,</span><span class="n">s1</span><span class="o">.</span><span class="na">length</span><span class="o">());</span>
        <span class="n">sub2</span> <span class="o">=</span> <span class="n">sub2</span><span class="o">.</span><span class="na">replaceAll</span><span class="o">(</span><span class="s">"1"</span><span class="o">,</span><span class="s">"0"</span><span class="o">);</span>
        <span class="nc">String</span> <span class="n">res</span> <span class="o">=</span> <span class="n">sub1</span> <span class="o">+</span> <span class="n">sub2</span><span class="o">;</span>
        <span class="k">return</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseUnsignedInt</span><span class="o">(</span><span class="n">res</span><span class="o">,</span><span class="mi">2</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump204"></span></p><h2 id="204计数质数">204.计数质数</h2><p>统计所有小于非负整数 n 的质数的数量。</p><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">n</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">4</span>
<span class="n">解释</span><span class="err">：</span><span class="n">小于</span> <span class="mi">10</span> <span class="n">的质数一共有</span> <span class="mi">4</span> <span class="n">个</span><span class="o">,</span> <span class="n">它们是</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">7</span> <span class="err">。</span>
</pre></table></code></div></div><p>示例 2：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">0</span>
</pre></table></code></div></div><p>示例 3：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">n</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">0</span>
</pre></table></code></div></div><p>提示：</p><ul><li>0 &lt;= n &lt;= 5 * 106</li></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="c1">//要判断数字x是不是质数，需要判断[2,x-1]中的每个数是否都不是x的因数</span>
    <span class="c1">//考虑到如果y是x的因数，那么x/y肯定也是x的因数是，所以只需要判断y或者x/y是不是x的因数即可</span>
    <span class="c1">//而y和x/y的较小值肯定落在[2,√x]中，所以只要枚举[2,√x]的值即可</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">countPrimes</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">res</span> <span class="o">+=</span> <span class="n">isPrime</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isPrime</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">){</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span> <span class="n">i</span> <span class="o">*</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">x</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">x</span> <span class="o">%</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="c1">//埃式筛：由希腊数学家厄拉多塞（Eratosthenes）提出</span>
    <span class="c1">//如果x是质数，那么2x,3x,...等肯定不是质数</span>
    <span class="c1">//所以只要用一个数组，记录下标对应的数字是不是质数即可</span>
    <span class="c1">//遇到一个质数，就将其所有的倍数下标标记为合数</span>
    <span class="c1">//优化：应该从x*x开始标记，因为2x,3x,...这些数一定在x之前就被其他质数的倍数标记了，例如2的所有倍数</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">countPrimes</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">isPrime</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>

        <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">isPrime</span><span class="o">,</span><span class="mi">1</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">isPrime</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="mi">1</span><span class="o">){</span>
                <span class="n">res</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">;</span>

                <span class="k">if</span><span class="o">((</span><span class="kt">long</span><span class="o">)</span> <span class="n">i</span> <span class="o">*</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">){</span>
                    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">i</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span> <span class="o">+=</span> <span class="n">i</span><span class="o">){</span>
                        <span class="n">isPrime</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump206"></span></p><h2 id="206反转链表">206.反转链表</h2><p>反转一个单链表。</p><p>示例:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="mi">1</span><span class="o">-&gt;</span><span class="mi">2</span><span class="o">-&gt;</span><span class="mi">3</span><span class="o">-&gt;</span><span class="mi">4</span><span class="o">-&gt;</span><span class="mi">5</span><span class="o">-&gt;</span><span class="no">NULL</span>
<span class="nl">输出:</span> <span class="mi">5</span><span class="o">-&gt;</span><span class="mi">4</span><span class="o">-&gt;</span><span class="mi">3</span><span class="o">-&gt;</span><span class="mi">2</span><span class="o">-&gt;</span><span class="mi">1</span><span class="o">-&gt;</span><span class="no">NULL</span>
</pre></table></code></div></div><p>进阶:</p><ul><li>你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</li></ul><p>迭代：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">reverseList</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ListNode</span> <span class="n">pre</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="nc">ListNode</span> <span class="n">p</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">p</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="nc">ListNode</span> <span class="n">q</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">p</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">pre</span><span class="o">;</span>
            <span class="n">pre</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">q</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">pre</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>递归:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">reverseList</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
        
        <span class="k">return</span> <span class="nf">reverse</span><span class="o">(</span><span class="kc">null</span><span class="o">,</span> <span class="n">head</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nc">ListNode</span> <span class="nf">reverse</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">pre</span><span class="o">,</span> <span class="nc">ListNode</span> <span class="n">p</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">p</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
            <span class="k">return</span> <span class="n">pre</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="nc">ListNode</span> <span class="n">q</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="n">p</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">pre</span><span class="o">;</span>
        <span class="n">pre</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">q</span><span class="o">;</span>
        <span class="k">return</span> <span class="nf">reverse</span><span class="o">(</span><span class="n">pre</span><span class="o">,</span> <span class="n">p</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump209"></span></p><h2 id="209寻找长度最小的子数组">209.寻找长度最小的子数组</h2><p>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组，并返回其长度。如果不存在符合条件的连续子数组，返回 0。</p><p>示例:</p><div class="language-markdown highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>输入: s = 7, nums = [2,3,1,2,4,3]
输出: 2
解释: 子数组 [4,3] 是该条件下的长度最小的连续子数组。
</pre></table></code></div></div><p>进阶:</p><div class="language-markdown highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>如果你已经完成了O(n) 时间复杂度的解法, 请尝试 O(n log n) 时间复杂度的解法。
</pre></table></code></div></div><h3 id="动态规划">动态规划</h3><p>dp[i]表示数组nums前i个元素中，符合条件的最短数组长度，为0时表示不符合条件。</p><p>状态方程：</p><div class="language-markdown highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>	dp[i] = min(f(i-1), f(i))
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">int</span> <span class="nf">minSubArrayLen</span><span class="o">(</span><span class="kt">int</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>

        <span class="c1">//dp[i]表示数组nums前i个元素中，符合条件的最短数组长度，为0时表示不符合条件</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
        <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">boolean</span> <span class="n">yes</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">s</span><span class="o">)</span>
            <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">else</span>
            <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dp</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="o">--</span><span class="n">j</span><span class="o">){</span>
                <span class="n">sum</span> <span class="o">+=</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
                <span class="o">++</span><span class="n">tmp</span><span class="o">;</span>
                <span class="k">if</span><span class="o">(</span><span class="n">sum</span> <span class="o">&gt;=</span> <span class="n">s</span><span class="o">){</span>
                    <span class="n">yes</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">sum</span> <span class="o">&gt;=</span> <span class="n">s</span> <span class="o">?</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">],</span> <span class="n">tmp</span><span class="o">)</span> <span class="o">:</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">yes</span> <span class="o">?</span> <span class="n">dp</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>
</pre></table></code></div></div><h3 id="暴力法">暴力法</h3><p>暴力法是最直观的方法。初始化子数组的最小长度为无穷大，枚举数组<code class="language-plaintext highlighter-rouge">nums</code> 中的每个下标作为子数组的开始下标，对于每个开始下标 <code class="language-plaintext highlighter-rouge">i</code>，需要找到大于或等于 <code class="language-plaintext highlighter-rouge">i</code>的最小下标 <code class="language-plaintext highlighter-rouge">j</code>，使得从<code class="language-plaintext highlighter-rouge">nums[i]</code> 到<code class="language-plaintext highlighter-rouge">nums[j] </code>的元素和大于或等于<code class="language-plaintext highlighter-rouge">s</code>，并更新子数组的最小长度（此时子数组的长度是 <code class="language-plaintext highlighter-rouge">j-i+1</code>。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">minSubArrayLen</span><span class="o">(</span><span class="kt">int</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">sum</span> <span class="o">+=</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">sum</span> <span class="o">&gt;=</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">ans</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">ans</span><span class="o">,</span> <span class="n">j</span> <span class="o">-</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">ans</span> <span class="o">==</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="前缀和二分查找">前缀和+二分查找</h3><p>为了使用二分查找，需要额外创建一个数组 <code class="language-plaintext highlighter-rouge">sums</code> 用于存储数组<code class="language-plaintext highlighter-rouge"> nums</code> 的前缀和，其中 <code class="language-plaintext highlighter-rouge">sums[i]</code> 表示从<code class="language-plaintext highlighter-rouge">nums[0]</code> 到<code class="language-plaintext highlighter-rouge">nums[i−1]</code> 的元素和。得到前缀和之后，对于每个开始下标<code class="language-plaintext highlighter-rouge">i</code>，可通过二分查找得到大于或等于<code class="language-plaintext highlighter-rouge">i</code>的最小下标 <code class="language-plaintext highlighter-rouge">bound</code>，使得<code class="language-plaintext highlighter-rouge">sums[bound]−sums[i−1]≥s</code>，并更新子数组的最小长度（此时子数组的长度是 <code class="language-plaintext highlighter-rouge">bound−(i−1)</code>）。</p><p>因为这道题保证了数组中每个元素都为正，所以前缀和一定是递增的，这一点保证了二分的正确性。如果题目没有说明数组中每个元素都为正，这里就不能使用二分来查找这个位置了。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">minSubArrayLen</span><span class="o">(</span><span class="kt">int</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">sums</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span> 
        <span class="c1">// 为了方便计算，令 size = n + 1 </span>
        <span class="c1">// sums[0] = 0 意味着前 0 个元素的前缀和为 0</span>
        <span class="c1">// sums[1] = A[0] 前 1 个元素的前缀和为 A[0]</span>
        <span class="c1">// 以此类推</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">sums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">sums</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">target</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="n">sums</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>
            <span class="kt">int</span> <span class="n">bound</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">binarySearch</span><span class="o">(</span><span class="n">sums</span><span class="o">,</span> <span class="n">target</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">bound</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">bound</span> <span class="o">=</span> <span class="o">-</span><span class="n">bound</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">bound</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">ans</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">ans</span><span class="o">,</span> <span class="n">bound</span> <span class="o">-</span> <span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">));</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">ans</span> <span class="o">==</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="双指针">双指针</h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/HYCBlog/assets/img/leetcode/leetcode_长度最小的子数组.png" alt="leetcode_长度最小的子数组" /></p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">minSubArrayLen</span><span class="o">(</span><span class="kt">int</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">end</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">end</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">nums</span><span class="o">[</span><span class="n">end</span><span class="o">];</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">sum</span> <span class="o">&gt;=</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">ans</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">ans</span><span class="o">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
                <span class="n">sum</span> <span class="o">-=</span> <span class="n">nums</span><span class="o">[</span><span class="n">start</span><span class="o">];</span>
                <span class="n">start</span><span class="o">++;</span>
            <span class="o">}</span>
            <span class="n">end</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">ans</span> <span class="o">==</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump214"></span></p><h2 id="214-最短回文串">214. 最短回文串</h2><p>给定一个字符串 s，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。</p><p>示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="s">"aacecaaa"</span>
<span class="nl">输出:</span> <span class="s">"aaacecaaa"</span>
</pre></table></code></div></div><p>示例 2:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="s">"abcd"</span>
<span class="nl">输出:</span> <span class="s">"dcbabcd"</span>
</pre></table></code></div></div><p>不难分析，“在字符串前添加字符，将其转换为回文串”，并且要求的回文串最短，说明只需要找到以第一个字符为起始的最长回文子串s1，然后将s-s1剩余的子串翻转放到s的前面即可。</p><p>找最长回文子串的方法有很多，动态规划、KMP、中心扩展等。<a href="#jump5">参考第5题。</a></p><p>本题用暴力判断+中心扩展法超时了，所以需要考虑KMP或Manacher算法。</p><p>另外，还有一个条件就是最长回文子串必须是以0为起始位置。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">shortestPalindrome</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="s">""</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="n">s</span><span class="o">;</span>
        <span class="c1">//找到以第一个元素为起始的最大回文子串的结尾位置</span>
        <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">longestPalindrome</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>

        <span class="nc">StringBuffer</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuffer</span><span class="o">();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()-</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">index</span><span class="o">;--</span><span class="n">i</span><span class="o">){</span>
            <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">()</span> <span class="o">+</span> <span class="n">s</span><span class="o">;</span>

    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">longestPalindrome</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>

        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>

        <span class="c1">// 得到预处理字符串</span>
        <span class="nc">String</span> <span class="n">str</span> <span class="o">=</span> <span class="n">addBoundaries</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="sc">'#'</span><span class="o">);</span>
        <span class="c1">// 新字符串的长度</span>
        <span class="kt">int</span> <span class="n">sLen</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>

        <span class="c1">// 数组 p 记录了扫描过的回文子串的信息</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">sLen</span><span class="o">];</span>

        <span class="c1">// 双指针，它们是一一对应的，须同时更新</span>
        <span class="kt">int</span> <span class="n">maxRight</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">center</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// 当前遍历的中心最大扩散步数，其值等于原始字符串的最长回文子串的长度</span>
        <span class="kt">int</span> <span class="n">maxLen</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="c1">// 原始字符串的最长回文子串的起始位置，与 maxLen 必须同时更新</span>
        <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sLen</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">maxRight</span><span class="o">)</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">mirror</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">center</span> <span class="o">-</span> <span class="n">i</span><span class="o">;</span>
                <span class="c1">// 这一行代码是 Manacher 算法的关键所在，要结合图形来理解</span>
                <span class="n">p</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">maxRight</span> <span class="o">-</span> <span class="n">i</span><span class="o">,</span> <span class="n">p</span><span class="o">[</span><span class="n">mirror</span><span class="o">]);</span>
            <span class="o">}</span>

            <span class="c1">// 下一次尝试扩散的左右起点，能扩散的步数直接加到 p[i] 中</span>
            <span class="c1">//就是为了处理p[mirror] == marRight - i的情况</span>
            <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="o">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">p</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="o">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">p</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>

            <span class="c1">// left &gt;= 0 &amp;&amp; right &lt; sLen 保证不越界</span>
            <span class="c1">// str.charAt(left) == str.charAt(right) 表示可以扩散 1 次</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">sLen</span> <span class="o">&amp;&amp;</span> <span class="n">str</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">left</span><span class="o">)</span> <span class="o">==</span> <span class="n">str</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">right</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">p</span><span class="o">[</span><span class="n">i</span><span class="o">]++;</span>
                <span class="n">left</span><span class="o">--;</span>
                <span class="n">right</span><span class="o">++;</span>
            <span class="o">}</span>
            <span class="c1">// 根据 maxRight 的定义，它是遍历过的 i 的 i + p[i] 的最大者</span>
            <span class="c1">// 如果 maxRight 的值越大，进入上面 i &lt; maxRight 的判断的可能性就越大，这样就可以重复利用之前判断过的回文信息了</span>
            <span class="c1">//更新maxRight，如果当前遍历到的中心i所能达到的最右端大于maxRight，就更新它</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">p</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">maxRight</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// maxRight 和 center 需要同时更新</span>
                <span class="n">maxRight</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">p</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
                <span class="n">center</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="k">if</span> <span class="o">(</span> <span class="n">p</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">maxLen</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// 记录最长回文子串的长度和相应它在原始字符串中的起点</span>
                <span class="k">if</span><span class="o">((</span><span class="n">i</span> <span class="o">-</span> <span class="n">p</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
                    <span class="n">maxLen</span> <span class="o">=</span> <span class="n">p</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
                    <span class="n">start</span> <span class="o">=</span> <span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">maxLen</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
                <span class="o">}</span>

            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">start</span><span class="o">+</span><span class="n">maxLen</span><span class="o">;</span>
    <span class="o">}</span>


    <span class="cm">/**
     * 创建预处理字符串
     */</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="nf">addBoundaries</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">char</span> <span class="n">divide</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="s">""</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="nc">StringBuilder</span> <span class="n">stringBuilder</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">stringBuilder</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">divide</span><span class="o">);</span>
            <span class="n">stringBuilder</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
        <span class="o">}</span>
        <span class="n">stringBuilder</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">divide</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">stringBuilder</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump216"></span></p><h2 id="216组合总和-iii">216.组合总和 III</h2><p>找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。</p><p>说明：</p><ul><li>所有数字都是正整数。</li><li>解集不能包含重复的组合。</li></ul><p>示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">3</span><span class="o">,</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">7</span>
<span class="nl">输出:</span> <span class="o">[[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">4</span><span class="o">]]</span>
</pre></table></code></div></div><p>示例 2:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">3</span><span class="o">,</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">9</span>
<span class="nl">输出:</span> <span class="o">[[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">6</span><span class="o">],</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">5</span><span class="o">],</span> <span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">]]</span>
</pre></table></code></div></div><p>这题比这个系列的前两题简单，几个条件：</p><ul><li>只含有1-9的整数</li><li>组合不存在重复数字。</li></ul><p>这两个条件简化了许多操作，可以创建一个数组存放待取数字，<code class="language-plaintext highlighter-rouge">{1,2,3,4,5,6,7,8,9}</code>，每次固定一位，一共取k位数字。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">;</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">res</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">combinationSum3</span><span class="o">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">if</span><span class="o">(</span><span class="n">k</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">){</span>
            <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;());</span>
            <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">//待取数字</span>
        <span class="n">nums</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="mi">9</span><span class="o">};</span>
        <span class="n">dfs</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="n">k</span><span class="o">,</span><span class="n">n</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;(),</span><span class="mi">0</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">int</span> <span class="n">cnt</span><span class="o">,</span><span class="kt">int</span> <span class="n">k</span><span class="o">,</span><span class="kt">int</span> <span class="n">n</span><span class="o">,</span><span class="kt">int</span> <span class="n">cur</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">,</span> <span class="kt">int</span> <span class="n">sum</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">cnt</span> <span class="o">&gt;</span> <span class="n">k</span> <span class="o">||</span> <span class="n">sum</span> <span class="o">&gt;</span> <span class="n">n</span><span class="o">){</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span><span class="o">(</span><span class="n">sum</span> <span class="o">==</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">cnt</span> <span class="o">==</span> <span class="n">k</span><span class="o">){</span>
            <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(</span><span class="n">list</span><span class="o">));</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">cur</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="c1">//剪枝</span>
            <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">n</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>
            <span class="n">cnt</span><span class="o">++;</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="n">dfs</span><span class="o">(</span><span class="n">cnt</span><span class="o">,</span><span class="n">k</span><span class="o">,</span><span class="n">n</span><span class="o">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span><span class="n">list</span><span class="o">,</span><span class="n">sum</span><span class="o">);</span>
            <span class="n">cnt</span><span class="o">--;</span>
            <span class="n">sum</span><span class="o">-=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="n">list</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">()-</span><span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump221"></span></p><h2 id="221最大正方形">221.最大正方形</h2><p>在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。</p><p>示例:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> 
<span class="mi">1</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span>
<span class="mi">1</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span>
<span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span>
<span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span>

<span class="nl">输出:</span> <span class="mi">4</span>
</pre></table></code></div></div><p>动态规划，<code class="language-plaintext highlighter-rouge">dp[i][j]</code>表示以<code class="language-plaintext highlighter-rouge">(i,j)</code>为右下角的正方形的最大边长。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">maximalSquare</span><span class="o">(</span><span class="kt">char</span><span class="o">[][]</span> <span class="n">matrix</span><span class="o">)</span> <span class="o">{</span>

        <span class="k">if</span><span class="o">(</span><span class="n">matrix</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">matrix</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>    <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">//dp[i][j]表示以(i,j)为右下角的正方形的最大边长</span>
        <span class="c1">//dp[i][j]的值由其左方，上方，左上方的dp值得到。</span>

        <span class="kt">int</span><span class="o">[][]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">matrix</span><span class="o">.</span><span class="na">length</span><span class="o">][</span><span class="n">matrix</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">//边界初始化</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">matrix</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'1'</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
            <span class="n">max</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">],</span> <span class="n">max</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">matrix</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
            <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'1'</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
            <span class="n">max</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="n">j</span><span class="o">],</span> <span class="n">max</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">matrix</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">matrix</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">matrix</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'0'</span><span class="o">)</span>
                    <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
                <span class="k">else</span>
                    <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">],</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">]),</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">])</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
                <span class="n">max</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">],</span> <span class="n">max</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">max</span> <span class="o">*</span> <span class="n">max</span><span class="o">;</span>
        
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump222"></span></p><h2 id="222完全二叉树的节点个数">222.完全二叉树的节点个数</h2><p>给出一个完全二叉树，求出该树的节点个数。</p><p>说明：</p><p>完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。</p><p>示例:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> 
    <span class="mi">1</span>
   <span class="o">/</span> <span class="err">\</span>
  <span class="mi">2</span>   <span class="mi">3</span>
 <span class="o">/</span> <span class="err">\</span>  <span class="o">/</span>
<span class="mi">4</span>  <span class="mi">5</span> <span class="mi">6</span>

<span class="nl">输出:</span> <span class="mi">6</span>
</pre></table></code></div></div><p>层序遍历：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">countNodes</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>    <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>   <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
        <span class="c1">//首先求出二叉树的深度，再遍历倒数第二层的节点，统计最后一层的节点个数</span>
        <span class="c1">//由于是完全二叉树，所以只要持续探索左节点，就能得到深度</span>
        <span class="nc">TreeNode</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">depth</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">cur</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="n">depth</span><span class="o">++;</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">//层序遍历，直到到达第depth-1层</span>
        <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="n">depth</span><span class="o">;</span>
        <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
        <span class="k">while</span><span class="o">(!</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">cnt</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="o">){</span>
            <span class="n">cnt</span><span class="o">--;</span>
            <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
                <span class="nc">TreeNode</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
                <span class="k">if</span><span class="o">(</span><span class="n">tmp</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>    <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">tmp</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
                <span class="k">if</span><span class="o">(</span><span class="n">tmp</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>    <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">tmp</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">//此时queue中的节点都是倒数第二层的节点</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="nc">Math</span><span class="o">.</span><span class="na">pow</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span><span class="n">depth</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="nc">TreeNode</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="k">if</span><span class="o">(</span><span class="n">tmp</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">tmp</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
                <span class="n">res</span><span class="o">+=</span><span class="mi">2</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">tmp</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">tmp</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
                <span class="n">res</span><span class="o">+=</span><span class="mi">1</span><span class="o">;</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>二分+位运算</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">countNodes</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>    <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>   <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
        <span class="c1">//首先求出二叉树的深度</span>
        <span class="c1">//由于是完全二叉树，所以只要持续探索左节点，就能得到深度</span>
        <span class="nc">TreeNode</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">depth</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">cur</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="n">depth</span><span class="o">++;</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">//知道了深度，就知道了此二叉树的节点数范围：2^depth~2^(depth+1)-1</span>
        <span class="c1">//可以利用二分搜索确定节点数</span>
        <span class="c1">// 1 00000 ～ 1 11111</span>
        <span class="kt">int</span> <span class="n">low</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">depth</span><span class="o">,</span> <span class="n">high</span> <span class="o">=</span> <span class="o">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="o">(</span><span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">low</span> <span class="o">&lt;</span> <span class="n">high</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="o">(</span><span class="n">high</span> <span class="o">-</span> <span class="n">low</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">low</span><span class="o">;</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"mid:"</span> <span class="o">+</span> <span class="n">mid</span><span class="o">);</span>
            <span class="c1">//判断二叉树是否有mid个节点</span>
            <span class="k">if</span><span class="o">(</span><span class="n">exist</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">depth</span><span class="o">,</span> <span class="n">mid</span><span class="o">)){</span>
                <span class="n">low</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="n">high</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">low</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">//根据节点编号寻找路径，最后判断节点是否为空，即可知道第mid个节点是否存在了</span>
    <span class="c1">//比如第mid个节点是第6个节点，那么编号为110，则1 0 表示二叉树先往右子树移动再往左子树移动，即可到达mid节点</span>
    <span class="kt">boolean</span> <span class="nf">exist</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">,</span> <span class="kt">int</span> <span class="n">depth</span><span class="o">,</span> <span class="kt">int</span> <span class="n">mid</span><span class="o">){</span>
        <span class="c1">//取出 11111，即最后一层的最大节点数</span>
        <span class="kt">int</span> <span class="n">bits</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="o">(</span><span class="n">depth</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"mid:"</span> <span class="o">+</span> <span class="n">mid</span> <span class="o">+</span> <span class="s">"; bits :"</span> <span class="o">+</span> <span class="n">bits</span><span class="o">);</span>
        <span class="nc">TreeNode</span> <span class="n">node</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">node</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">bits</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span>
            <span class="k">if</span><span class="o">((</span><span class="n">bits</span> <span class="o">&amp;</span> <span class="n">mid</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">bits</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">node</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump235"></span></p><h2 id="235二叉搜索树的最近公共祖先">235.二叉搜索树的最近公共祖先</h2><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4]</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/15/binarytree.png" alt="" /></p><p>示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="n">root</span> <span class="o">=</span> <span class="o">[</span><span class="mi">3</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="kc">null</span><span class="o">,</span><span class="kc">null</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">4</span><span class="o">],</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">5</span><span class="o">,</span> <span class="n">q</span> <span class="o">=</span> <span class="mi">1</span>
<span class="nl">输出:</span> <span class="mi">3</span>
<span class="nl">解释:</span> <span class="n">节点</span> <span class="mi">5</span> <span class="n">和节点</span> <span class="mi">1</span> <span class="n">的最近公共祖先是节点</span> <span class="mi">3</span><span class="err">。</span>
</pre></table></code></div></div><p>示例 2:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="n">root</span> <span class="o">=</span> <span class="o">[</span><span class="mi">3</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="kc">null</span><span class="o">,</span><span class="kc">null</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">4</span><span class="o">],</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">5</span><span class="o">,</span> <span class="n">q</span> <span class="o">=</span> <span class="mi">4</span>
<span class="nl">输出:</span> <span class="mi">5</span>
<span class="nl">解释:</span> <span class="n">节点</span> <span class="mi">5</span> <span class="n">和节点</span> <span class="mi">4</span> <span class="n">的最近公共祖先是节点</span> <span class="mi">5</span><span class="err">。</span><span class="n">因为根据定义最近公共祖先节点可以为节点本身</span><span class="err">。</span>
</pre></table></code></div></div><p>说明:</p><ul><li><p>所有节点的值都是唯一的。</p></li><li><p>p、q 为不同节点且均存在于给定的二叉树中。</p></li></ul><p>思路：</p><p>后序遍历，从树的底部开始向上回溯，这样可以保证搜索到的祖先是离p,q最近的。</p><ul><li>如果p和q分别是root的左右节点，那么root就是我们要找的最近公共祖先</li><li>如果p和q都是root的左节点，那么返回lowestCommonAncestor(root.left,p,q)</li><li>如果p和q都是root的右节点，那么返回lowestCommonAncestor(root.right,p,q)</li></ul><p>边界条件：</p><ul><li>如果root是null，则说明我们已经找到最底了，返回null表示没找到</li><li>如果root与p相等或者与q相等，则返回root</li><li>如果左子树没找到，递归函数返回null，证明p和q同在root的右侧，那么最终的公共祖先就是右子树找到的结点</li><li>如果右子树没找到，递归函数返回null，证明p和q同在root的左侧，那么最终的公共祖先就是左子树找到的结点</li></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="nc">TreeNode</span> <span class="nf">lowestCommonAncestor</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">,</span> <span class="nc">TreeNode</span> <span class="n">p</span><span class="o">,</span> <span class="nc">TreeNode</span> <span class="n">q</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">root</span> <span class="o">==</span> <span class="n">p</span> <span class="o">||</span> <span class="n">root</span> <span class="o">==</span> <span class="n">q</span><span class="o">)</span>  <span class="k">return</span> <span class="n">root</span><span class="o">;</span>
        <span class="nc">TreeNode</span> <span class="n">left</span> <span class="o">=</span> <span class="n">lowestCommonAncestor</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">p</span><span class="o">,</span> <span class="n">q</span><span class="o">);</span>
        <span class="nc">TreeNode</span> <span class="n">right</span> <span class="o">=</span> <span class="n">lowestCommonAncestor</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">p</span><span class="o">,</span> <span class="n">q</span><span class="o">);</span>
        <span class="c1">//有一者为空，那么p和q在另一侧，由于是后序遍历，所以该侧指向最近的公共祖先</span>
        <span class="k">if</span><span class="o">(</span><span class="n">left</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>    <span class="k">return</span> <span class="n">right</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">right</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>   <span class="k">return</span> <span class="n">left</span><span class="o">;</span>
        <span class="c1">//p,q在两侧</span>
        <span class="k">return</span> <span class="n">root</span><span class="o">;</span>   
    <span class="o">}</span>   
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump242"></span></p><h2 id="242有效的字母异位词">242.有效的字母异位词</h2><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p><p>示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"anagram"</span><span class="o">,</span> <span class="n">t</span> <span class="o">=</span> <span class="s">"nagaram"</span>
<span class="nl">输出:</span> <span class="kc">true</span>
</pre></table></code></div></div><p>示例 2:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"rat"</span><span class="o">,</span> <span class="n">t</span> <span class="o">=</span> <span class="s">"car"</span>
<span class="nl">输出:</span> <span class="kc">false</span>
</pre></table></code></div></div><p>说明: 你可以假设字符串只包含小写字母。</p><p>进阶: 如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？</p><p>排序比较：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isAnagram</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="nc">String</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">!=</span> <span class="n">t</span><span class="o">.</span><span class="na">length</span><span class="o">())</span>    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>

        <span class="kt">char</span><span class="o">[]</span> <span class="n">char1</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>
        <span class="kt">char</span><span class="o">[]</span> <span class="n">char2</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>

        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">char1</span><span class="o">);</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">char2</span><span class="o">);</span>

        <span class="k">return</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">char1</span><span class="o">,</span><span class="n">char2</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>哈希表：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isAnagram</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="nc">String</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">!=</span> <span class="n">t</span><span class="o">.</span><span class="na">length</span><span class="o">())</span>    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>

        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">table</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="n">table</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">c</span><span class="o">,</span><span class="n">table</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">t</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="n">table</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">c</span><span class="o">,</span><span class="n">table</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
            <span class="k">if</span><span class="o">(</span><span class="n">table</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">c</span><span class="o">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">){</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>

        
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump257"></span></p><h2 id="257二叉树的所有路径">257.二叉树的所有路径</h2><p>给定一个二叉树，返回所有从根节点到叶子节点的路径。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="nl">输入:</span>
   <span class="mi">1</span>
 <span class="o">/</span>   <span class="err">\</span>
<span class="mi">2</span>     <span class="mi">3</span>
 <span class="err">\</span>
  <span class="mi">5</span>

<span class="nl">输出:</span> <span class="o">[</span><span class="s">"1-&gt;2-&gt;5"</span><span class="o">,</span> <span class="s">"1-&gt;3"</span><span class="o">]</span>
<span class="nl">解释:</span> <span class="nl">所有根节点到叶子节点的路径为:</span> <span class="mi">1</span><span class="o">-&gt;</span><span class="mi">2</span><span class="o">-&gt;</span><span class="mi">5</span><span class="o">,</span> <span class="mi">1</span><span class="o">-&gt;</span><span class="mi">3</span>
</pre></table></code></div></div><h3 id="回溯法">回溯法</h3><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="nc">StringBuffer</span> <span class="n">path</span><span class="o">;</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">res</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="nf">binaryTreePaths</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>    <span class="k">return</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="n">path</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuffer</span><span class="o">();</span>
        <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="n">getPath</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">getPath</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">){</span>
        <span class="c1">//到达叶节点</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
            <span class="n">path</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
            <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">path</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
            <span class="c1">//回溯</span>
            <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">).</span><span class="na">length</span><span class="o">();</span>
            <span class="n">path</span><span class="o">.</span><span class="na">delete</span><span class="o">(</span><span class="n">path</span><span class="o">.</span><span class="na">length</span><span class="o">()-</span><span class="n">len</span><span class="o">,</span><span class="n">path</span><span class="o">.</span><span class="na">length</span><span class="o">());</span>
            <span class="k">return</span><span class="o">;</span>
            
        <span class="o">}</span>
        <span class="n">path</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
        <span class="n">path</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">"-&gt;"</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>   <span class="n">getPath</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>  <span class="n">getPath</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
        <span class="c1">//回溯，这题比较奇葩，root.val长度是变化的，所以在删除字符的时候需要计算root.val的长度</span>
        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">).</span><span class="na">length</span><span class="o">()</span> <span class="o">+</span> <span class="mi">2</span><span class="o">;</span>
        <span class="n">path</span><span class="o">.</span><span class="na">delete</span><span class="o">(</span><span class="n">path</span><span class="o">.</span><span class="na">length</span><span class="o">()-</span><span class="n">len</span><span class="o">,</span><span class="n">path</span><span class="o">.</span><span class="na">length</span><span class="o">());</span>

    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump316"></span></p><h2 id="316-去除重复字母">316. 去除重复字母</h2><p>给你一个字符串 s ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 返回结果的字典序最小（要求不能打乱其他字符的相对位置）。</p><p>注意：该题与 1081 https://leetcode-cn.com/problems/smallest-subsequence-of-distinct-characters 相同</p><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">s</span> <span class="o">=</span> <span class="s">"bcabc"</span>
<span class="n">输出</span><span class="err">：</span><span class="s">"abc"</span>
</pre></table></code></div></div><p>示例 2：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">s</span> <span class="o">=</span> <span class="s">"cbacdcbc"</span>
<span class="n">输出</span><span class="err">：</span><span class="s">"acdb"</span>
</pre></table></code></div></div><p>提示：</p><ul><li>1 &lt;= s.length &lt;= 104</li><li>s 由小写英文字母组成</li></ul><p>单调栈</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">removeDuplicateLetters</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">count</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">count</span><span class="o">[</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]++;</span>
        <span class="o">}</span>
        <span class="nc">StringBuilder</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>

        <span class="kt">boolean</span><span class="o">[]</span> <span class="n">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span>
        <span class="c1">//维护一个单调栈，如果当前字母小于栈顶字母，就将栈顶字母出栈</span>
        <span class="c1">//  但是如果当前栈顶字母的计数已经为0了，那就不能出栈了</span>
      	<span class="c1">//	如果当前字母已经在栈中了，没必要访问了，计数-1</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="kt">char</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="k">if</span><span class="o">(!</span><span class="n">visited</span><span class="o">[</span><span class="n">cur</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]){</span>
                <span class="k">while</span><span class="o">(</span><span class="n">sb</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">sb</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">sb</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">&gt;</span> <span class="n">cur</span><span class="o">){</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">count</span><span class="o">[</span><span class="n">sb</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">sb</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span>
                        <span class="n">visited</span><span class="o">[</span><span class="n">sb</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">sb</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                        <span class="n">sb</span><span class="o">.</span><span class="na">deleteCharAt</span><span class="o">(</span><span class="n">sb</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
                    <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                        <span class="k">break</span><span class="o">;</span>
                    <span class="o">}</span>

                <span class="o">}</span>
                <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">cur</span><span class="o">);</span>
                <span class="n">visited</span><span class="o">[</span><span class="n">cur</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="n">count</span><span class="o">[</span><span class="n">cur</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]--;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump321"></span></p><h2 id="321拼接最大数tag">321.拼接最大数[tag]</h2><p>给定长度分别为 m 和 n 的两个数组，其元素由 0-9 构成，表示两个自然数各位上的数字。现在从这两个数组中选出 k (k &lt;= m + n) 个数字拼接成一个新的数，要求从同一个数组中取出的数字保持其在原数组中的相对顺序。</p><p>求满足该条件的最大数。结果返回一个表示该最大数的长度为 k 的数组。</p><p>说明: 请尽可能地优化你算法的时间和空间复杂度。</p><p>示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="nl">输入:</span>
<span class="n">nums1</span> <span class="o">=</span> <span class="o">[</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">5</span><span class="o">]</span>
<span class="n">nums2</span> <span class="o">=</span> <span class="o">[</span><span class="mi">9</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">3</span><span class="o">]</span>
<span class="n">k</span> <span class="o">=</span> <span class="mi">5</span>
<span class="nl">输出:</span>
<span class="o">[</span><span class="mi">9</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">3</span><span class="o">]</span>
</pre></table></code></div></div><p>示例 2:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="nl">输入:</span>
<span class="n">nums1</span> <span class="o">=</span> <span class="o">[</span><span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">]</span>
<span class="n">nums2</span> <span class="o">=</span> <span class="o">[</span><span class="mi">6</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">4</span><span class="o">]</span>
<span class="n">k</span> <span class="o">=</span> <span class="mi">5</span>
<span class="nl">输出:</span>
<span class="o">[</span><span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">4</span><span class="o">]</span>
</pre></table></code></div></div><p>示例 3:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="nl">输入:</span>
<span class="n">nums1</span> <span class="o">=</span> <span class="o">[</span><span class="mi">3</span><span class="o">,</span> <span class="mi">9</span><span class="o">]</span>
<span class="n">nums2</span> <span class="o">=</span> <span class="o">[</span><span class="mi">8</span><span class="o">,</span> <span class="mi">9</span><span class="o">]</span>
<span class="n">k</span> <span class="o">=</span> <span class="mi">3</span>
<span class="nl">输出:</span>
<span class="o">[</span><span class="mi">9</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">9</span><span class="o">]</span>
</pre></table></code></div></div><p>与删除k个数字类似：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="c1">//单调栈：保留k个数相当于移除nums1.length+nums2.length - k个数</span>
    <span class="c1">//从两个数组中取k个数，相当于从nums1中取k1个数，从nums2中取k2个数</span>
    <span class="c1">//k1 + k2 = k</span>
    <span class="c1">//也就是:</span>
  	<span class="c1">//1.从nums1中删除n1 - k1个数，使得子序列最大</span>
    <span class="c1">//2.从nums2中删除n2 - k2个数，使得子序列最大</span>
    <span class="c1">//若k &lt; n1，那么nums1可以删除1、2、3、...、k个数</span>
    <span class="c1">//但是k有可能大于n1或n2，所以需要遍历每一种情况</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">maxNumber</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">nums1</span><span class="o">.</span><span class="na">length</span><span class="o">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums2</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">maxSubsequence</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">k</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">k</span> <span class="o">-</span> <span class="n">n</span><span class="o">),</span> <span class="n">end</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">k</span><span class="o">,</span> <span class="n">m</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">start</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">int</span><span class="o">[]</span> <span class="n">subsequence1</span> <span class="o">=</span> <span class="n">maxSubsequence</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
            <span class="kt">int</span><span class="o">[]</span> <span class="n">subsequence2</span> <span class="o">=</span> <span class="n">maxSubsequence</span><span class="o">(</span><span class="n">nums2</span><span class="o">,</span> <span class="n">k</span> <span class="o">-</span> <span class="n">i</span><span class="o">);</span>
            <span class="kt">int</span><span class="o">[]</span> <span class="n">curMaxSubsequence</span> <span class="o">=</span> <span class="n">merge</span><span class="o">(</span><span class="n">subsequence1</span><span class="o">,</span> <span class="n">subsequence2</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">compare</span><span class="o">(</span><span class="n">curMaxSubsequence</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">maxSubsequence</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">arraycopy</span><span class="o">(</span><span class="n">curMaxSubsequence</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">maxSubsequence</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">k</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">maxSubsequence</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">//单调栈，找到长度为leng-k的最大子序列</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">maxSubsequence</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">k</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">top</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">remain</span> <span class="o">=</span> <span class="n">length</span> <span class="o">-</span> <span class="n">k</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">top</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">stack</span><span class="o">[</span><span class="n">top</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">num</span> <span class="o">&amp;&amp;</span> <span class="n">remain</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">top</span><span class="o">--;</span>
                <span class="n">remain</span><span class="o">--;</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">top</span> <span class="o">&lt;</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">stack</span><span class="o">[++</span><span class="n">top</span><span class="o">]</span> <span class="o">=</span> <span class="n">num</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">remain</span><span class="o">--;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">stack</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">//合并子序列</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">merge</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">subsequence1</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">subsequence2</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">subsequence1</span><span class="o">.</span><span class="na">length</span><span class="o">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">subsequence2</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">subsequence2</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">y</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">subsequence1</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="kt">int</span> <span class="n">mergeLength</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">merged</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">mergeLength</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">index1</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">index2</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mergeLength</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">compare</span><span class="o">(</span><span class="n">subsequence1</span><span class="o">,</span> <span class="n">index1</span><span class="o">,</span> <span class="n">subsequence2</span><span class="o">,</span> <span class="n">index2</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">merged</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">subsequence1</span><span class="o">[</span><span class="n">index1</span><span class="o">++];</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">merged</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">subsequence2</span><span class="o">[</span><span class="n">index2</span><span class="o">++];</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">merged</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">//自定义比较方法。首先比较两个子序列的当前元素，</span>
  	<span class="c1">//如果两个当前元素不同，则选其中较大的元素作为下一个合并的元素，</span>
    <span class="c1">//否则需要比较后面的所有元素才能决定选哪个元素作为下一个合并的元素。</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">subsequence1</span><span class="o">,</span> <span class="kt">int</span> <span class="n">index1</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">subsequence2</span><span class="o">,</span> <span class="kt">int</span> <span class="n">index2</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">subsequence1</span><span class="o">.</span><span class="na">length</span><span class="o">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">subsequence2</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">index1</span> <span class="o">&lt;</span> <span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="n">index2</span> <span class="o">&lt;</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">difference</span> <span class="o">=</span> <span class="n">subsequence1</span><span class="o">[</span><span class="n">index1</span><span class="o">]</span> <span class="o">-</span> <span class="n">subsequence2</span><span class="o">[</span><span class="n">index2</span><span class="o">];</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">difference</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">difference</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">index1</span><span class="o">++;</span>
            <span class="n">index2</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="o">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">index1</span><span class="o">)</span> <span class="o">-</span> <span class="o">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">index2</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump327"></span></p><h2 id="327区间和的个数tag">327.区间和的个数[tag]</h2><p>给定一个整数数组 nums，返回区间和在 [lower, upper] 之间的个数，包含 lower 和 upper。 区间和 S(i, j) 表示在 nums 中，位置从 i 到 j 的元素之和，包含 i 和 j (i ≤ j)。</p><p>说明: 最直观的算法复杂度是 O(n2) ，请在此基础上优化你的算法。</p><p>示例:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="n">nums</span> <span class="o">=</span> <span class="o">[-</span><span class="mi">2</span><span class="o">,</span><span class="mi">5</span><span class="o">,-</span><span class="mi">1</span><span class="o">],</span> <span class="n">lower</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="o">,</span> <span class="n">upper</span> <span class="o">=</span> <span class="mi">2</span><span class="o">,</span>
<span class="nl">输出:</span> <span class="mi">3</span> 
<span class="nl">解释:</span> <span class="mi">3</span><span class="nl">个区间分别是:</span> <span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">],</span> <span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">],</span> <span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">2</span><span class="o">]</span><span class="err">，</span><span class="nl">它们表示的和分别为:</span> <span class="o">-</span><span class="mi">2</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="err">。</span>
</pre></table></code></div></div><p>归并排序是从最小子数组开始统计的，我们是在归并之前统计下标对，之后再归并，所以不影响。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="c1">//目的是为了统计符合</span>
    <span class="c1">//pre[j] - pre[i] &gt;= lower &amp;&amp; pre[j] - pre[i] &lt;= upper</span>
    <span class="c1">//的下标（i,j）的个数</span>
    <span class="c1">//归并排序</span>
    <span class="c1">//让排好序的，待归并的两个子数组作为pre</span>
    <span class="c1">//计算从左边数组下标i到右边数组下标j的和是否满足条件</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">countRangeSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">lower</span><span class="o">,</span> <span class="kt">int</span> <span class="n">upper</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">long</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">long</span><span class="o">[]</span> <span class="n">sum</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">long</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>
        <span class="c1">//计算[0,i]的前缀和</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="n">sum</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">s</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="nf">count</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">sum</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">sum</span><span class="o">,</span> <span class="n">lower</span><span class="o">,</span> <span class="n">upper</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kt">int</span> <span class="nf">count</span><span class="o">(</span><span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">,</span> <span class="kt">long</span><span class="o">[]</span> <span class="n">sum</span><span class="o">,</span> <span class="kt">int</span> <span class="n">lower</span><span class="o">,</span> <span class="kt">int</span> <span class="n">upper</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">left</span> <span class="o">==</span> <span class="n">right</span><span class="o">){</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span><span class="k">else</span><span class="o">{</span>
            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">left</span><span class="o">;</span>
            <span class="c1">//归并</span>
            <span class="kt">int</span> <span class="n">n1</span> <span class="o">=</span> <span class="n">count</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">mid</span><span class="o">,</span> <span class="n">sum</span><span class="o">,</span> <span class="n">lower</span><span class="o">,</span> <span class="n">upper</span><span class="o">);</span>
            <span class="kt">int</span> <span class="n">n2</span> <span class="o">=</span> <span class="n">count</span><span class="o">(</span><span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">right</span><span class="o">,</span> <span class="n">sum</span><span class="o">,</span> <span class="n">lower</span><span class="o">,</span> <span class="n">upper</span><span class="o">);</span>
            <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">n1</span> <span class="o">+</span> <span class="n">n2</span><span class="o">;</span>

            <span class="c1">//统计下标对的数量</span>

            <span class="c1">//枚举左边数组的每一位</span>
            <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">left</span><span class="o">;</span>
            
            <span class="c1">//让l和r指向右边数组的开头</span>
            <span class="c1">//让l向右移动，直到sum[l] - sum[i] &gt;= lower</span>
            <span class="c1">//让r向右移动，直到sum[r] - sum[i] &gt; upper</span>
            <span class="c1">//这样 r - l就是下标对的数量了</span>
             <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
             <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
             <span class="k">while</span><span class="o">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">mid</span><span class="o">){</span>
                 <span class="k">while</span><span class="o">(</span><span class="n">l</span> <span class="o">&lt;=</span> <span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="n">sum</span><span class="o">[</span><span class="n">l</span><span class="o">]</span> <span class="o">-</span> <span class="n">sum</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">lower</span><span class="o">){</span>
                     <span class="n">l</span><span class="o">++;</span>
                 <span class="o">}</span>
                 <span class="k">while</span><span class="o">(</span><span class="n">r</span> <span class="o">&lt;=</span> <span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="n">sum</span><span class="o">[</span><span class="n">r</span><span class="o">]</span> <span class="o">-</span> <span class="n">sum</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">upper</span><span class="o">){</span>
                     <span class="n">r</span><span class="o">++;</span>
                 <span class="o">}</span>
                 <span class="n">res</span> <span class="o">+=</span> <span class="n">r</span> <span class="o">-</span> <span class="n">l</span><span class="o">;</span>
                 <span class="o">++</span><span class="n">i</span><span class="o">;</span>
             <span class="o">}</span>
             <span class="c1">//执行左右数组合并</span>
             <span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>
             <span class="kt">int</span> <span class="n">ptr1</span> <span class="o">=</span> <span class="n">left</span><span class="o">,</span> <span class="n">ptr2</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
             <span class="kt">int</span> <span class="n">ptr</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

             <span class="k">while</span><span class="o">(</span><span class="n">ptr1</span> <span class="o">&lt;=</span> <span class="n">mid</span> <span class="o">||</span> <span class="n">ptr2</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="o">){</span>
                 <span class="k">if</span><span class="o">(</span><span class="n">ptr1</span> <span class="o">&gt;</span> <span class="n">mid</span><span class="o">){</span>
                     <span class="n">arr</span><span class="o">[</span><span class="n">ptr</span><span class="o">++]</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">sum</span><span class="o">[</span><span class="n">ptr2</span><span class="o">++];</span>
                 <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">ptr2</span> <span class="o">&gt;</span> <span class="n">right</span><span class="o">){</span>
                     <span class="n">arr</span><span class="o">[</span><span class="n">ptr</span><span class="o">++]</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">sum</span><span class="o">[</span><span class="n">ptr1</span><span class="o">++];</span>
                 <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                     <span class="k">if</span><span class="o">(</span><span class="n">sum</span><span class="o">[</span><span class="n">ptr1</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">sum</span><span class="o">[</span><span class="n">ptr2</span><span class="o">]){</span>
                         <span class="n">arr</span><span class="o">[</span><span class="n">ptr</span><span class="o">++]</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">sum</span><span class="o">[</span><span class="n">ptr1</span><span class="o">++];</span>
                     <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                         <span class="n">arr</span><span class="o">[</span><span class="n">ptr</span><span class="o">++]</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">sum</span><span class="o">[</span><span class="n">ptr2</span><span class="o">++];</span>
                     <span class="o">}</span>
                 <span class="o">}</span>
             <span class="o">}</span>

             <span class="c1">//将归并好的数组放入前缀和数组中</span>
             <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">k</span><span class="o">){</span>
                 <span class="n">sum</span><span class="o">[</span><span class="n">left</span> <span class="o">+</span> <span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">k</span><span class="o">];</span>
             <span class="o">}</span>
             <span class="k">return</span> <span class="n">res</span><span class="o">;</span>

        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump328"></span></p><h2 id="328奇偶链表">328.奇偶链表</h2><p>给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。</p><p>请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。</p><p>示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="mi">1</span><span class="o">-&gt;</span><span class="mi">2</span><span class="o">-&gt;</span><span class="mi">3</span><span class="o">-&gt;</span><span class="mi">4</span><span class="o">-&gt;</span><span class="mi">5</span><span class="o">-&gt;</span><span class="no">NULL</span>
<span class="nl">输出:</span> <span class="mi">1</span><span class="o">-&gt;</span><span class="mi">3</span><span class="o">-&gt;</span><span class="mi">5</span><span class="o">-&gt;</span><span class="mi">2</span><span class="o">-&gt;</span><span class="mi">4</span><span class="o">-&gt;</span><span class="no">NULL</span>
</pre></table></code></div></div><p>示例 2:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="mi">2</span><span class="o">-&gt;</span><span class="mi">1</span><span class="o">-&gt;</span><span class="mi">3</span><span class="o">-&gt;</span><span class="mi">5</span><span class="o">-&gt;</span><span class="mi">6</span><span class="o">-&gt;</span><span class="mi">4</span><span class="o">-&gt;</span><span class="mi">7</span><span class="o">-&gt;</span><span class="no">NULL</span> 
<span class="nl">输出:</span> <span class="mi">2</span><span class="o">-&gt;</span><span class="mi">3</span><span class="o">-&gt;</span><span class="mi">6</span><span class="o">-&gt;</span><span class="mi">7</span><span class="o">-&gt;</span><span class="mi">1</span><span class="o">-&gt;</span><span class="mi">5</span><span class="o">-&gt;</span><span class="mi">4</span><span class="o">-&gt;</span><span class="no">NULL</span>
</pre></table></code></div></div><p>说明:</p><ul><li>应当保持奇数节点和偶数节点的相对顺序。</li><li>链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。</li></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">oddEvenList</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>    <span class="k">return</span> <span class="n">head</span><span class="o">;</span>
        <span class="c1">//双指针</span>
        <span class="nc">ListNode</span> <span class="n">pto</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="nc">ListNode</span> <span class="n">pte</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">pte</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="c1">//移动节点</span>
            <span class="nc">ListNode</span> <span class="n">o</span> <span class="o">=</span> <span class="n">pte</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">o</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>   <span class="k">break</span><span class="o">;</span>
            <span class="nc">ListNode</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">o</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">pto</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">pto</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">o</span><span class="o">;</span>
            <span class="n">pte</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
            <span class="c1">//让这两个指针分别指向奇数子链表和偶数子链表的末端</span>
            <span class="n">pte</span> <span class="o">=</span> <span class="n">pte</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">pto</span> <span class="o">=</span> <span class="n">pto</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">head</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-go highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="k">func</span> <span class="n">oddEvenList</span><span class="p">(</span><span class="n">head</span> <span class="o">*</span><span class="n">ListNode</span><span class="p">)</span> <span class="o">*</span><span class="n">ListNode</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">head</span> <span class="o">==</span> <span class="no">nil</span><span class="p">{</span>
        <span class="k">return</span> <span class="n">head</span>
    <span class="p">}</span>
    <span class="k">var</span> <span class="n">pto</span> <span class="o">*</span><span class="n">ListNode</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
    <span class="k">var</span> <span class="n">pte</span> <span class="o">*</span><span class="n">ListNode</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="n">Next</span><span class="p">;</span>
    <span class="k">for</span> <span class="n">pte</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
        <span class="k">var</span> <span class="n">o</span> <span class="o">*</span><span class="n">ListNode</span> <span class="o">=</span> <span class="n">pte</span><span class="o">.</span><span class="n">Next</span><span class="p">;</span>
        <span class="k">if</span> <span class="n">o</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">var</span> <span class="n">tmp</span> <span class="o">*</span><span class="n">ListNode</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">Next</span><span class="p">;</span>
        <span class="n">o</span><span class="o">.</span><span class="n">Next</span> <span class="o">=</span> <span class="n">pto</span><span class="o">.</span><span class="n">Next</span><span class="p">;</span>
        <span class="n">pto</span><span class="o">.</span><span class="n">Next</span> <span class="o">=</span> <span class="n">o</span><span class="p">;</span>
        <span class="n">pte</span><span class="o">.</span><span class="n">Next</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
        <span class="n">pte</span> <span class="o">=</span> <span class="n">pte</span><span class="o">.</span><span class="n">Next</span><span class="p">;</span>
        <span class="n">pto</span> <span class="o">=</span> <span class="n">pto</span><span class="o">.</span><span class="n">Next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">head</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p><span id="jump332"></span></p><h2 id="332-重新安排行程">332. 重新安排行程</h2><p>给定一个机票的字符串二维数组 [from, to]，子数组中的两个成员分别表示飞机出发和降落的机场地点，对该行程进行重新规划排序。所有这些机票都属于一个从 JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK 开始。</p><p>说明:</p><ol><li>如果存在多种有效的行程，你可以按字符自然排序返回最小的行程组合。例如，行程 [“JFK”, “LGA”] 与 [“JFK”, “LGB”] 相比就更小，排序更靠前</li><li>所有的机场都用三个大写字母表示（机场代码）。</li><li>假定所有机票至少存在一种合理的行程。</li></ol><p>示例 1:</p><div class="language-markdown highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>输入: [["MUC", "LHR"], ["JFK", "MUC"], ["SFO", "SJC"], ["LHR", "SFO"]]
输出: ["JFK", "MUC", "LHR", "SFO", "SJC"]
</pre></table></code></div></div><p>示例 2:</p><div class="language-markdown highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>输入: [["JFK","SFO"],["JFK","ATL"],["SFO","ATL"],["ATL","JFK"],["ATL","SFO"]]
输出: ["JFK","ATL","JFK","SFO","ATL","SFO"]
解释: 另一种有效的行程是 ["JFK","SFO","ATL","JFK","ATL","SFO"]。但是它自然排序更大更靠后。
</pre></table></code></div></div><p>化简题意：</p><div class="language-markdown highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>给定一个n个点m条边的图，要求从指定顶点出发，经过所有边恰好一次，并且路径的字典序最小。
</pre></table></code></div></div><p>这种「一笔画」问题与欧拉图或者半欧拉图有着紧密的联系：</p><div class="language-markdown highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="p">*</span>	通过图中所有边恰好一次且行遍所有顶点的通路称为欧拉通路。
<span class="p">*</span>	通过图中所有边恰好一次且行遍所有顶点的回路称为欧拉回路。
<span class="p">*</span>	具有欧拉回路的无向图称为欧拉图。
<span class="p">*</span>	具有欧拉通路但不具有欧拉回路的无向图称为半欧拉图。
</pre></table></code></div></div><p>因为本题保证至少存在一种合理的路径，也就告诉了我们，这张图是一个欧拉图或者半欧拉图。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/HYCBlog/assets/img/leetcode/leetcode_重新安排行程_1.png" alt="leetcode_重新安排行程_1" /></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/HYCBlog/assets/img/leetcode/leetcode_重新安排行程_2.png" alt="leetcode_重新安排行程_2" /></p><h3 id="排序">排序</h3><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="nf">findItinerary</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">tickets</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 因为逆序插入，所以用链表</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">tickets</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">tickets</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
            <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">graph</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="c1">//将tickets中的所有边和点都对应存入graph中</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">pair</span> <span class="o">:</span> <span class="n">tickets</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 因为涉及删除操作，我们用链表</span>
            <span class="c1">//当key不存在时，向map中插入(key=value);当key存在时，返回旧值</span>
<span class="c1">//            List&lt;String&gt; nbr = graph.computeIfAbsent(pair.get(0), k -&gt; new LinkedList&lt;&gt;());</span>
            <span class="c1">//所以理论上还可以这样写</span>
            <span class="k">if</span><span class="o">(!</span><span class="n">graph</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">pair</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">))){</span><span class="c1">//不存在此key</span>
                <span class="c1">//新建一项</span>
                <span class="n">graph</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">pair</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">),</span><span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;());</span>
            <span class="o">}</span>
            <span class="c1">//获取邻居列表，并添加项</span>
            <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">nbr</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">pair</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">));</span>
            <span class="n">nbr</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">pair</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">1</span><span class="o">));</span>
        <span class="o">}</span>
        <span class="c1">// 将每个邻居节点列表按字典序排序</span>
        <span class="n">graph</span><span class="o">.</span><span class="na">values</span><span class="o">().</span><span class="na">forEach</span><span class="o">(</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="nl">String:</span><span class="o">:</span><span class="n">compareTo</span><span class="o">));</span>
        <span class="n">visit</span><span class="o">(</span><span class="n">graph</span><span class="o">,</span> <span class="s">"JFK"</span><span class="o">,</span> <span class="n">res</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">// DFS方式遍历图，当走到不能走为止，再将节点加入到答案</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">visit</span><span class="o">(</span><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">graph</span><span class="o">,</span> <span class="nc">String</span> <span class="n">src</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">res</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//获取src的邻居列表</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">nbr</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">src</span><span class="o">);</span>
        <span class="c1">//nbr为空时，说明这个顶点从始至终都没有邻居，nbr.size等于0时，说明这个顶点的邻居已经被访问完了</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">nbr</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">nbr</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">//访问一个邻居</span>
            <span class="nc">String</span> <span class="n">dest</span> <span class="o">=</span> <span class="n">nbr</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
            <span class="c1">//DFS</span>
            <span class="n">visit</span><span class="o">(</span><span class="n">graph</span><span class="o">,</span> <span class="n">dest</span><span class="o">,</span> <span class="n">res</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">src</span><span class="o">);</span> <span class="c1">// 逆序插入</span>
    <span class="o">}</span>
</pre></table></code></div></div><h3 id="最小堆优先队列代替排序">最小堆/优先队列代替排序：</h3><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="nf">findItinerary</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">tickets</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 因为逆序插入，所以用链表</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">tickets</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">tickets</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
            <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">PriorityQueue</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">graph</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="c1">//将tickets中的所有边和点都对应存入graph中</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">pair</span> <span class="o">:</span> <span class="n">tickets</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 因为涉及删除操作，我们用链表</span>
            <span class="c1">//当key不存在时，向map中插入(key=value);当key存在时，返回旧值</span>
<span class="c1">//            List&lt;String&gt; nbr = graph.computeIfAbsent(pair.get(0), k -&gt; new LinkedList&lt;&gt;());</span>
            <span class="c1">//所以理论上还可以这样写</span>
            <span class="k">if</span><span class="o">(!</span><span class="n">graph</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">pair</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">))){</span><span class="c1">//不存在此key</span>
                <span class="c1">//新建一项</span>
                <span class="n">graph</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">pair</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">),</span><span class="k">new</span> <span class="nc">PriorityQueue</span><span class="o">&lt;&gt;());</span>
            <span class="o">}</span>
            <span class="c1">//获取邻居列表，并添加项</span>
            <span class="nc">PriorityQueue</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">nbr</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">pair</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">));</span>
            <span class="n">nbr</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">pair</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">1</span><span class="o">));</span>
        <span class="o">}</span>
        <span class="c1">// 将每个邻居节点列表按字典序排序</span>
<span class="c1">//        graph.values().forEach(x -&gt; x.sort(String::compareTo));</span>
        <span class="n">visit</span><span class="o">(</span><span class="n">graph</span><span class="o">,</span> <span class="s">"JFK"</span><span class="o">,</span> <span class="n">res</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">// DFS方式遍历图，当走到不能走为止，再将节点加入到答案</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">visit</span><span class="o">(</span><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">PriorityQueue</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">graph</span><span class="o">,</span> <span class="nc">String</span> <span class="n">src</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">res</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//获取src的邻居列表</span>
        <span class="nc">PriorityQueue</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">nbr</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">src</span><span class="o">);</span>
        <span class="c1">//nbr为空时，说明这个顶点从始至终都没有邻居，nbr.size等于0时，说明这个顶点的邻居已经被访问完了</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">nbr</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">nbr</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">//访问一个邻居</span>
            <span class="nc">String</span> <span class="n">dest</span> <span class="o">=</span> <span class="n">nbr</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="c1">//DFS</span>
            <span class="n">visit</span><span class="o">(</span><span class="n">graph</span><span class="o">,</span> <span class="n">dest</span><span class="o">,</span> <span class="n">res</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">src</span><span class="o">);</span> <span class="c1">// 逆序插入</span>
    <span class="o">}</span>
</pre></table></code></div></div><h3 id="用stack实现迭代代替递归">用stack实现迭代代替递归</h3><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="nf">findItinerary</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">tickets</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 因为逆序插入，所以用链表</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">tickets</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">tickets</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
            <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">PriorityQueue</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">graph</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="c1">//将tickets中的所有边和点都对应存入graph中</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">pair</span> <span class="o">:</span> <span class="n">tickets</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 因为涉及删除操作，我们用链表</span>
            <span class="c1">//当key不存在时，向map中插入(key=value);当key存在时，返回旧值</span>
<span class="c1">//            List&lt;String&gt; nbr = graph.computeIfAbsent(pair.get(0), k -&gt; new LinkedList&lt;&gt;());</span>
            <span class="c1">//所以理论上还可以这样写</span>
            <span class="k">if</span><span class="o">(!</span><span class="n">graph</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">pair</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">))){</span><span class="c1">//不存在此key</span>
                <span class="c1">//新建一项</span>
                <span class="n">graph</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">pair</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">),</span><span class="k">new</span> <span class="nc">PriorityQueue</span><span class="o">&lt;&gt;());</span>
            <span class="o">}</span>
            <span class="c1">//获取邻居列表，并添加项</span>
            <span class="nc">PriorityQueue</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">nbr</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">pair</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">));</span>
            <span class="n">nbr</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">pair</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">1</span><span class="o">));</span>
        <span class="o">}</span>
        <span class="c1">// 将每个邻居节点列表按字典序排序</span>
<span class="c1">//        graph.values().forEach(x -&gt; x.sort(String::compareTo));</span>
        <span class="n">visit</span><span class="o">(</span><span class="n">graph</span><span class="o">,</span> <span class="s">"JFK"</span><span class="o">,</span> <span class="n">res</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">// DFS方式遍历图，当走到不能走为止，再将节点加入到答案</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">visit</span><span class="o">(</span><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">PriorityQueue</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">graph</span><span class="o">,</span> <span class="nc">String</span> <span class="n">src</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">res</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Stack</span><span class="o">&lt;&gt;();</span>

        <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">src</span><span class="o">);</span>

        <span class="k">while</span> <span class="o">(!</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
            <span class="nc">PriorityQueue</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">nbr</span><span class="o">;</span>

            <span class="k">while</span> <span class="o">((</span><span class="n">nbr</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">stack</span><span class="o">.</span><span class="na">peek</span><span class="o">()))</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span>
                    <span class="n">nbr</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">nbr</span><span class="o">.</span><span class="na">poll</span><span class="o">());</span>
            <span class="o">}</span>
            <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">());</span>
        <span class="o">}</span>

    <span class="o">}</span>
</pre></table></code></div></div><div class="language-markdown highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre>如果没有保证至少存在一种合理的路径，我们需要判别这张图是否是欧拉图或者半欧拉图，具体地：
<span class="p">
*</span> 对于无向图 GG，GG 是欧拉图当且仅当 GG 是连通的且没有奇度顶点。
<span class="p">*</span> 对于无向图 GG，GG 是半欧拉图当且仅当 GG 是连通的且 GG 中恰有 22 个奇度顶点。
<span class="p">*</span> 对于有向图 GG，GG 是欧拉图当且仅当 GG 的所有顶点属于同一个强连通分量且每个顶点的入度和出度相同。
<span class="p">*</span> 对于有向图 GG，GG 是半欧拉图当且仅当 GG 的所有顶点属于同一个强连通分量且
<span class="p">*</span> 恰有一个顶点的出度与入度差为 11；
<span class="p">*</span> 恰有一个顶点的入度与出度差为 11；
<span class="p">*</span> 所有其他顶点的入度和出度相同。
</pre></table></code></div></div><p><span id="jump336"></span></p><h2 id="336-回文对">336. 回文对</h2><p>给定一组 互不相同 的单词， 找出所有不同 的索引对(i, j)，使得列表中的两个单词， words[i] + words[j] ，可拼接成回文串。</p><p>示例 1：</p><div class="language-markdown highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>输入：["abcd","dcba","lls","s","sssll"]
输出：[[0,1],[1,0],[3,2],[2,4]] 
解释：可拼接成的回文串为 ["dcbaabcd","abcddcba","slls","llssssll"]
</pre></table></code></div></div><p>示例 2：</p><div class="language-markdown highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>输入：["bat","tab","cat"]
输出：[[0,1],[1,0]] 
解释：可拼接成的回文串为 ["battab","tabbat"]
</pre></table></code></div></div><h3 id="暴力遍历超出时间限制">暴力遍历(超出时间限制)</h3><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">palindromePairs</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">words</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">words</span><span class="o">.</span><span class="na">length</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;();</span>
        
        <span class="c1">//遍历所有的索引对，若拼接后的字符串是回文串则将索引加入list</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">words</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">words</span><span class="o">.</span><span class="na">length</span><span class="o">;++</span><span class="n">j</span><span class="o">){</span>
                <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">tmp</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;();</span>
                <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">tmp2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;();</span>
                <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="n">words</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="n">words</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
                <span class="c1">//String s2 = words[j] + words[i];</span>
                <span class="k">if</span><span class="o">(</span><span class="n">isHWC</span><span class="o">(</span><span class="n">s1</span><span class="o">)){</span>
                    <span class="n">tmp</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
                    <span class="n">tmp</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">j</span><span class="o">);</span>
                    <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">tmp</span><span class="o">);</span>
                    
                <span class="o">}</span>
                <span class="k">if</span><span class="o">(</span><span class="n">isHWC</span><span class="o">(</span><span class="n">s2</span><span class="o">)){</span>
                    <span class="n">tmp2</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">j</span><span class="o">);</span>
                    <span class="n">tmp2</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
                    <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">tmp2</span><span class="o">);</span>
                <span class="o">}</span>  
            <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>         
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isHWC</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span><span class="n">j</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()-</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span><span class="n">j</span><span class="o">;){</span>
            <span class="k">if</span><span class="o">(!(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">)))</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>       
            <span class="n">i</span><span class="o">++;</span>
            <span class="n">j</span><span class="o">--;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="对暴力优化">对暴力优化</h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/HYCBlog/assets/img/leetcode/leetcode_回文对.png" alt="leetcode_回文对" /></p><h3 id="字典树解法">字典树解法</h3><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">ch</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">flag</span><span class="o">;</span>

        <span class="kd">public</span> <span class="nf">Node</span><span class="o">()</span> <span class="o">{</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">&gt;</span> <span class="n">tree</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">&gt;();</span>

    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">palindromePairs</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">words</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">tree</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">Node</span><span class="o">());</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">words</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">insert</span><span class="o">(</span><span class="n">words</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">ret</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">words</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">length</span><span class="o">();</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">isPalindrome</span><span class="o">(</span><span class="n">words</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">j</span><span class="o">,</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="o">))</span> <span class="o">{</span>
                    <span class="kt">int</span> <span class="n">leftId</span> <span class="o">=</span> <span class="n">findWord</span><span class="o">(</span><span class="n">words</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="mi">0</span><span class="o">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">leftId</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">leftId</span> <span class="o">!=</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">ret</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">leftId</span><span class="o">));</span>
                    <span class="o">}</span>
                <span class="o">}</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">j</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">isPalindrome</span><span class="o">(</span><span class="n">words</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="mi">0</span><span class="o">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">))</span> <span class="o">{</span>
                    <span class="kt">int</span> <span class="n">rightId</span> <span class="o">=</span> <span class="n">findWord</span><span class="o">(</span><span class="n">words</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">j</span><span class="o">,</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">rightId</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">rightId</span> <span class="o">!=</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">ret</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="n">rightId</span><span class="o">,</span> <span class="n">i</span><span class="o">));</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">ret</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">insert</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">(),</span> <span class="n">add</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">tree</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">add</span><span class="o">).</span><span class="na">ch</span><span class="o">[</span><span class="n">x</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">tree</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">Node</span><span class="o">());</span>
                <span class="n">tree</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">add</span><span class="o">).</span><span class="na">ch</span><span class="o">[</span><span class="n">x</span><span class="o">]</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">add</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">add</span><span class="o">).</span><span class="na">ch</span><span class="o">[</span><span class="n">x</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="n">tree</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">add</span><span class="o">).</span><span class="na">flag</span> <span class="o">=</span> <span class="n">id</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isPalindrome</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">i</span><span class="o">)</span> <span class="o">!=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">i</span><span class="o">))</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">findWord</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">add</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">right</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">left</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">tree</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">add</span><span class="o">).</span><span class="na">ch</span><span class="o">[</span><span class="n">x</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">add</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">add</span><span class="o">).</span><span class="na">ch</span><span class="o">[</span><span class="n">x</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">tree</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">add</span><span class="o">).</span><span class="na">flag</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="哈希表解法">哈希表解法</h3><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">wordsRev</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;();</span>
    <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">indices</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;();</span>

    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">palindromePairs</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">words</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">words</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="nl">word:</span> <span class="n">words</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">wordsRev</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">StringBuffer</span><span class="o">(</span><span class="n">word</span><span class="o">).</span><span class="na">reverse</span><span class="o">().</span><span class="na">toString</span><span class="o">());</span>
        <span class="o">}</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">indices</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">wordsRev</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">),</span> <span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">ret</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">String</span> <span class="n">word</span> <span class="o">=</span> <span class="n">words</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">words</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">length</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">m</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">isPalindrome</span><span class="o">(</span><span class="n">word</span><span class="o">,</span> <span class="n">j</span><span class="o">,</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="o">))</span> <span class="o">{</span>
                    <span class="kt">int</span> <span class="n">leftId</span> <span class="o">=</span> <span class="n">findWord</span><span class="o">(</span><span class="n">word</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">leftId</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">leftId</span> <span class="o">!=</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">ret</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">leftId</span><span class="o">));</span>
                    <span class="o">}</span>
                <span class="o">}</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">j</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">isPalindrome</span><span class="o">(</span><span class="n">word</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">))</span> <span class="o">{</span>
                    <span class="kt">int</span> <span class="n">rightId</span> <span class="o">=</span> <span class="n">findWord</span><span class="o">(</span><span class="n">word</span><span class="o">,</span> <span class="n">j</span><span class="o">,</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">rightId</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">rightId</span> <span class="o">!=</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">ret</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="n">rightId</span><span class="o">,</span> <span class="n">i</span><span class="o">));</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">ret</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isPalindrome</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">i</span><span class="o">)</span> <span class="o">!=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">i</span><span class="o">))</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">findWord</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">indices</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span> <span class="o">+</span> <span class="mi">1</span><span class="o">),</span> <span class="o">-</span><span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump344"></span></p><h2 id="344反转字符串">344.反转字符串</h2><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p><p>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="o">[</span><span class="s">"h"</span><span class="o">,</span><span class="s">"e"</span><span class="o">,</span><span class="s">"l"</span><span class="o">,</span><span class="s">"l"</span><span class="o">,</span><span class="s">"o"</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="o">[</span><span class="s">"o"</span><span class="o">,</span><span class="s">"l"</span><span class="o">,</span><span class="s">"l"</span><span class="o">,</span><span class="s">"e"</span><span class="o">,</span><span class="s">"h"</span><span class="o">]</span>
</pre></table></code></div></div><p>示例 2：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="o">[</span><span class="s">"H"</span><span class="o">,</span><span class="s">"a"</span><span class="o">,</span><span class="s">"n"</span><span class="o">,</span><span class="s">"n"</span><span class="o">,</span><span class="s">"a"</span><span class="o">,</span><span class="s">"h"</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="o">[</span><span class="s">"h"</span><span class="o">,</span><span class="s">"a"</span><span class="o">,</span><span class="s">"n"</span><span class="o">,</span><span class="s">"n"</span><span class="o">,</span><span class="s">"a"</span><span class="o">,</span><span class="s">"H"</span><span class="o">]</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">reverseString</span><span class="o">(</span><span class="kt">char</span><span class="o">[]</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">low</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">high</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">low</span> <span class="o">&lt;</span> <span class="n">high</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">s</span><span class="o">[</span><span class="n">low</span><span class="o">]</span> <span class="o">!=</span> <span class="n">s</span><span class="o">[</span><span class="n">high</span><span class="o">]){</span>
                <span class="kt">char</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">s</span><span class="o">[</span><span class="n">low</span><span class="o">];</span>
                <span class="n">s</span><span class="o">[</span><span class="n">low</span><span class="o">]</span> <span class="o">=</span> <span class="n">s</span><span class="o">[</span><span class="n">high</span><span class="o">];</span>
                <span class="n">s</span><span class="o">[</span><span class="n">high</span><span class="o">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="o">++</span><span class="n">low</span><span class="o">;</span>
            <span class="o">--</span><span class="n">high</span><span class="o">;</span>
        <span class="o">}</span>

    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump349"></span></p><h2 id="349两个数组的交集">349.两个数组的交集</h2><p>给定两个数组，编写一个函数来计算它们的交集。</p><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">nums1</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">],</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span>
</pre></table></code></div></div><p>示例 2：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">nums1</span> <span class="o">=</span> <span class="o">[</span><span class="mi">4</span><span class="o">,</span><span class="mi">9</span><span class="o">,</span><span class="mi">5</span><span class="o">],</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">[</span><span class="mi">9</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">9</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="mi">4</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="o">[</span><span class="mi">9</span><span class="o">,</span><span class="mi">4</span><span class="o">]</span>
</pre></table></code></div></div><p>说明：</p><ul><li>输出结果中的每个元素一定是唯一的。</li><li>我们可以不考虑输出结果的顺序。</li></ul><p>哈希表：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">intersection</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//哈希表</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums1</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">nums1</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
        <span class="o">}</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nums2</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">set</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">nums2</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">list</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">nums2</span><span class="o">[</span><span class="n">j</span><span class="o">])){</span>
                <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">nums2</span><span class="o">[</span><span class="n">j</span><span class="o">]);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">()];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">res</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>都放入set中，再遍历较小的set：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">intersection</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//哈希表</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">set1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums1</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">set1</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">nums1</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
        <span class="o">}</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">set2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums2</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">set2</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">nums2</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
        <span class="o">}</span>
        
        <span class="k">return</span> <span class="nf">compareSet</span><span class="o">(</span><span class="n">set1</span><span class="o">,</span> <span class="n">set2</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kt">int</span><span class="o">[]</span> <span class="nf">compareSet</span><span class="o">(</span><span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">set1</span><span class="o">,</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">set2</span><span class="o">){</span>
      	<span class="c1">//这个很有趣，可以避免重复代码</span>
        <span class="k">if</span><span class="o">(</span><span class="n">set1</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">set2</span><span class="o">.</span><span class="na">size</span><span class="o">()){</span>
            <span class="k">return</span> <span class="nf">compareSet</span><span class="o">(</span><span class="n">set2</span><span class="o">,</span><span class="n">set1</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">resSet</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span><span class="o">(</span><span class="nc">Integer</span> <span class="n">num</span> <span class="o">:</span> <span class="n">set1</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">set2</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">num</span><span class="o">)){</span>
                <span class="n">resSet</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">num</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="kt">int</span><span class="o">[]</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">resSet</span><span class="o">.</span><span class="na">size</span><span class="o">()];</span>

        <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="k">for</span><span class="o">(</span><span class="nc">Integer</span> <span class="n">num</span> <span class="o">:</span> <span class="n">resSet</span><span class="o">){</span>
            <span class="n">res</span><span class="o">[</span><span class="n">index</span><span class="o">++]</span> <span class="o">=</span> <span class="n">num</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>

    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump376"></span></p><h2 id="376-摆动序列">376. 摆动序列</h2><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。</p><p>例如， [1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。相反, [1,4,7,2,5] 和 [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</p><p>给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。</p><p>示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">9</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span>
<span class="nl">输出:</span> <span class="mi">6</span> 
<span class="nl">解释:</span> <span class="n">整个序列均为摆动序列</span><span class="err">。</span>
</pre></table></code></div></div><p>示例 2:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">17</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">10</span><span class="o">,</span><span class="mi">13</span><span class="o">,</span><span class="mi">15</span><span class="o">,</span><span class="mi">10</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">16</span><span class="o">,</span><span class="mi">8</span><span class="o">]</span>
<span class="nl">输出:</span> <span class="mi">7</span>
<span class="nl">解释:</span> <span class="n">这个序列包含几个长度为</span> <span class="mi">7</span> <span class="n">摆动序列</span><span class="err">，</span><span class="n">其中一个可为</span><span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">17</span><span class="o">,</span><span class="mi">10</span><span class="o">,</span><span class="mi">13</span><span class="o">,</span><span class="mi">10</span><span class="o">,</span><span class="mi">16</span><span class="o">,</span><span class="mi">8</span><span class="o">]</span><span class="err">。</span>
</pre></table></code></div></div><p>示例 3:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="mi">9</span><span class="o">]</span>
<span class="nl">输出:</span> <span class="mi">2</span>
</pre></table></code></div></div><p>进阶:</p><ul><li>你能否用 O(n) 时间复杂度完成此题?</li></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">wiggleMaxLength</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">)</span> <span class="k">return</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>

        <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">2</span><span class="o">){</span>
            <span class="k">return</span> <span class="n">nums</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">2</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="kt">int</span> <span class="n">pre</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="c1">//遍历序列，遇到连续上升序列时，保留峰值，遇到连续下降序列时，保留谷值</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
            <span class="k">if</span><span class="o">(</span><span class="n">cur</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span><span class="c1">//相邻两个数字相等，需要去掉一个</span>
                <span class="n">cnt</span><span class="o">--;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="k">if</span><span class="o">(</span><span class="n">pre</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
                    <span class="n">pre</span> <span class="o">=</span> <span class="n">cur</span><span class="o">;</span>
                <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">pre</span> <span class="o">*</span> <span class="n">cur</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span><span class="c1">//相邻两个差值同号，需要去掉一个数字</span>
                        <span class="n">cnt</span><span class="o">--;</span>
                    <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                        <span class="n">pre</span> <span class="o">=</span> <span class="n">cur</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">cnt</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="n">func</span> <span class="nf">wiggleMaxLength</span><span class="o">(</span><span class="n">nums</span> <span class="o">[]</span><span class="kt">int</span><span class="o">)</span> <span class="kt">int</span> <span class="o">{</span>
    <span class="n">n</span> <span class="o">:=</span> <span class="n">len</span><span class="o">(</span><span class="n">nums</span><span class="o">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">n</span>
    <span class="o">}</span>

    <span class="n">pre</span> <span class="o">:=</span> <span class="mi">0</span>
    <span class="n">cnt</span> <span class="o">:=</span> <span class="n">n</span>
    <span class="c1">//遍历序列，遇到连续上升序列时，保留峰值，遇到连续下降序列时，保留谷值</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++</span> <span class="o">{</span>
        <span class="n">cur</span> <span class="o">:=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span>
        <span class="k">if</span> <span class="n">cur</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">{</span><span class="c1">//相邻两个数字相等，需要去掉一个</span>
            <span class="n">cnt</span><span class="o">--</span>
        <span class="o">}</span><span class="k">else</span><span class="o">{</span>
            <span class="k">if</span> <span class="n">pre</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">{</span>
                <span class="n">pre</span> <span class="o">=</span> <span class="n">cur</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="k">if</span> <span class="n">pre</span> <span class="o">*</span> <span class="n">cur</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">{</span><span class="c1">//相邻两个差值同号，需要去掉一个数字</span>
                    <span class="n">cnt</span><span class="o">--</span>
                <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                    <span class="n">pre</span> <span class="o">=</span> <span class="n">cur</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">cnt</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump378"></span></p><h2 id="378-有序矩阵中第k小元素">378. 有序矩阵中第k小元素</h2><p>给定一个 <em><code class="language-plaintext highlighter-rouge">n x n</code></em> 矩阵，其中每行和每列元素均按升序排序，找到矩阵中第 <code class="language-plaintext highlighter-rouge">k</code> 小的元素。 请注意，它是排序后的第 <code class="language-plaintext highlighter-rouge">k</code> 小元素，而不是第 <code class="language-plaintext highlighter-rouge">k</code> 个不同的元素。</p><p><strong>示例：</strong></p><div class="language-markdown highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>matrix = [
   [ 1,  5,  9],
   [10, 11, 13],
   [12, 13, 15]
],
k = 8,

返回 13。
</pre></table></code></div></div><p><strong>提示：</strong> 你可以假设 k 的值永远是有效的，1 ≤ k ≤ n2 。</p><h3 id="直接排序">直接排序</h3><p>将这个二维数组另存为一维数组，并对该一维数组进行排序。最后返回第k个数，即为答案。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span><span class="o">{</span>
	<span class="kd">public</span> <span class="kt">int</span> <span class="nf">kthSmallest</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">matrix</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">v</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">matrix</span><span class="o">.</span><span class="na">length</span><span class="o">*</span><span class="n">matrix</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">matrix</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">matrix</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                <span class="n">v</span><span class="o">[</span><span class="n">c</span><span class="o">++]</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">v</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">v</span><span class="o">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>
    <span class="o">}</span> 
<span class="o">}</span>
</pre></table></code></div></div><h3 id="归并排序没看懂">归并排序(没看懂)</h3><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">kthSmallest</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">matrix</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">PriorityQueue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">pq</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PriorityQueue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;(</span><span class="k">new</span> <span class="nc">Comparator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;()</span> <span class="o">{</span>
            <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">a</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">-</span> <span class="n">b</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">});</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">pq</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">matrix</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">],</span> <span class="n">i</span><span class="o">,</span> <span class="mi">0</span><span class="o">});</span>
        <span class="o">}</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">int</span><span class="o">[]</span> <span class="n">now</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">now</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span> <span class="o">!=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">pq</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">matrix</span><span class="o">[</span><span class="n">now</span><span class="o">[</span><span class="mi">1</span><span class="o">]][</span><span class="n">now</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">],</span> <span class="n">now</span><span class="o">[</span><span class="mi">1</span><span class="o">],</span> <span class="n">now</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">});</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">pq</span><span class="o">.</span><span class="na">poll</span><span class="o">()[</span><span class="mi">0</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="二分查找还没看">二分查找(还没看)</h3><p>由题目给出的性质可知，这个矩阵内的元素是从左上到右下递增的（假设矩阵左上角为 matrix[0][0]<em>m<strong>a</strong>t<strong>r</strong>i**x</em>[0][0]）。以下图为例：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/HYCBlog/assets/img/leetcode/leetcode_有序矩阵中的第k小元素.png" alt="leetcode_有序矩阵中的第k小元素" /></p><p>我们知道整个二维数组中 <code class="language-plaintext highlighter-rouge">matrix[0][0]</code> 为最小值，<code class="language-plaintext highlighter-rouge">matrix[n−1][n−1]</code> 为最大值，现在我们将其分别记作<code class="language-plaintext highlighter-rouge"> l</code>和<code class="language-plaintext highlighter-rouge"> r</code>。</p><p>可以发现一个性质：任取一个数 <code class="language-plaintext highlighter-rouge">mid</code> 满足 <code class="language-plaintext highlighter-rouge">l≤mid≤r</code>，那么矩阵中不大于 <code class="language-plaintext highlighter-rouge">mid</code> 的数，肯定全部分布在矩阵的左上角。</p><p>例如上图，取 <code class="language-plaintext highlighter-rouge">mid=8</code>，我们可以看到，矩阵中大于 <code class="language-plaintext highlighter-rouge">mid</code> 的数就和不大于 <code class="language-plaintext highlighter-rouge">mid</code> 的数分别形成了两个板块，沿着一条锯齿线将这个矩形分开。其中左上角板块的大小即为矩阵中不大于 <code class="language-plaintext highlighter-rouge">mid</code> 的数的数量。</p><p>初始位置在 <code class="language-plaintext highlighter-rouge">matrix[n−1][0]</code>（即左下角）；</p><p>设当前位置为 <code class="language-plaintext highlighter-rouge">matrix[i][j]</code>。若<code class="language-plaintext highlighter-rouge">matrix[i][j]≤mid</code>，则将当前所在列的不大于 <code class="language-plaintext highlighter-rouge">mid</code> 的数的数量（即 <code class="language-plaintext highlighter-rouge">i+1</code>）累加到答案中，并向右移动，否则向上移动；</p><p>不断移动直到走出格子为止。</p><p>我们发现这样的走法时间复杂度为 O(n)，即我们可以线性计算对于任意一个 <code class="language-plaintext highlighter-rouge">mid</code>，矩阵中有多少数不大于它。这满足了二分查找的性质。</p><p>不妨假设答案为 <code class="language-plaintext highlighter-rouge">x</code>，那么可以知道<code class="language-plaintext highlighter-rouge">l≤x≤r</code>，这样就确定了二分查找的上下界。</p><p>每次对于「猜测」的答案<code class="language-plaintext highlighter-rouge"> mid</code>，计算矩阵中有多少数不大于 <code class="language-plaintext highlighter-rouge">mid</code> ：</p><p>如果数量不少于 <code class="language-plaintext highlighter-rouge">k</code>，那么说明最终答案 <code class="language-plaintext highlighter-rouge">x</code> 不大于 <code class="language-plaintext highlighter-rouge">mid</code>； 如果数量少于 <code class="language-plaintext highlighter-rouge">k</code>，那么说明最终答案 <code class="language-plaintext highlighter-rouge">x</code> 大于<code class="language-plaintext highlighter-rouge">mid</code>。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">kthSmallest</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">matrix</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="o">((</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="o">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">check</span><span class="o">(</span><span class="n">matrix</span><span class="o">,</span> <span class="n">mid</span><span class="o">,</span> <span class="n">k</span><span class="o">,</span> <span class="n">n</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">left</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">check</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">matrix</span><span class="o">,</span> <span class="kt">int</span> <span class="n">mid</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">matrix</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">mid</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">num</span> <span class="o">+=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
                <span class="n">j</span><span class="o">++;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">i</span><span class="o">--;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">num</span> <span class="o">&gt;=</span> <span class="n">k</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump381"></span></p><h2 id="381o1-时间插入删除和获取随机元素---允许重复">381.O(1) 时间插入、删除和获取随机元素 - 允许重复</h2><p>设计一个支持在平均 时间复杂度 O(1) 下， 执行以下操作的数据结构。</p><p>注意: 允许出现重复元素。</p><ul><li>insert(val)：向集合中插入元素 val。</li><li>remove(val)：当 val 存在时，从集合中移除一个 val。</li><li>getRandom：从现有集合中随机获取一个元素。每个元素被返回的概率应该与其在集合中的数量呈线性相关。</li></ul><p>示例:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="c1">// 初始化一个空的集合。</span>
<span class="nc">RandomizedCollection</span> <span class="n">collection</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">RandomizedCollection</span><span class="o">();</span>

<span class="c1">// 向集合中插入 1 。返回 true 表示集合不包含 1 。</span>
<span class="n">collection</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>

<span class="c1">// 向集合中插入另一个 1 。返回 false 表示集合包含 1 。集合现在包含 [1,1] 。</span>
<span class="n">collection</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>

<span class="c1">// 向集合中插入 2 ，返回 true 。集合现在包含 [1,1,2] 。</span>
<span class="n">collection</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>

<span class="c1">// getRandom 应当有 2/3 的概率返回 1 ，1/3 的概率返回 2 。</span>
<span class="n">collection</span><span class="o">.</span><span class="na">getRandom</span><span class="o">();</span>

<span class="c1">// 从集合中删除 1 ，返回 true 。集合现在包含 [1,2] 。</span>
<span class="n">collection</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>

<span class="c1">// getRandom 应有相同概率返回 1 和 2 。</span>
<span class="n">collection</span><span class="o">.</span><span class="na">getRandom</span><span class="o">();</span>
</pre></table></code></div></div><p>用一个列表存放元素，再用一个map存放元素与下标的对应。</p><p>插入时，直接将元素插入到列表的最后，然后在map中更新元素索引。</p><p>删除时，从map中取出对应元素的索引，再在列表中将此元素与列表最后一个元素交换，最后删除列表最后一个元素即可。</p><p>需要注意的是：此元素可能与列表最后一个元素相等，那么就需要同步更新set和hashMap。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">RandomizedCollection</span> <span class="o">{</span>

    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">nums</span><span class="o">;</span>
    <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">hashIndex</span><span class="o">;</span>
    <span class="cm">/** Initialize your data structure here. */</span>
    <span class="kd">public</span> <span class="nf">RandomizedCollection</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">nums</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="n">hashIndex</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
    <span class="o">}</span>
    
    <span class="cm">/** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">insert</span><span class="o">(</span><span class="kt">int</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">nums</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">val</span><span class="o">);</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="n">hashIndex</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">val</span><span class="o">,</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;());</span>
        <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
        <span class="n">hashIndex</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">val</span><span class="o">,</span> <span class="n">set</span><span class="o">);</span>
        <span class="c1">//size==1说明当前插入的元素是唯一的，没有重复</span>
        <span class="k">return</span> <span class="n">set</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="mi">1</span><span class="o">;</span>

    <span class="o">}</span>
    
    <span class="cm">/** Removes a value from the collection. Returns true if the collection contained the specified element. */</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">remove</span><span class="o">(</span><span class="kt">int</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="n">hashIndex</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">val</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">set</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="c1">//根据迭代器获取val在set中的索引</span>
        <span class="nc">Iterator</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">itr</span> <span class="o">=</span> <span class="n">set</span><span class="o">.</span><span class="na">iterator</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">itr</span><span class="o">.</span><span class="na">hasNext</span><span class="o">()){</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">itr</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">lastSet</span> <span class="o">=</span> <span class="n">hashIndex</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">));</span>
      	<span class="c1">//当需要删除的元素和列表最后一个元素不相等时，才需要分别更新两个集合</span>
      	<span class="c1">//因为从set中删除一个元素，需要更新索引</span>
      	<span class="c1">//从lastSet中删除并插入一个元素，需要更新索引</span>
        <span class="k">if</span><span class="o">(</span><span class="n">set</span> <span class="o">!=</span> <span class="n">lastSet</span><span class="o">){</span>
            <span class="n">lastSet</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
            <span class="n">lastSet</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">idx</span><span class="o">);</span>
            <span class="n">set</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">idx</span><span class="o">);</span>
        <span class="o">}</span><span class="k">else</span><span class="o">{</span>
          	<span class="c1">//如果是同一个元素，那么直接删除set最后一个的值即可</span>
            <span class="n">set</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>
      	<span class="c1">//当set为空时，就清出map</span>
        <span class="k">if</span><span class="o">(</span><span class="n">set</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">hashIndex</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">val</span><span class="o">);</span>
        <span class="c1">//最后处理列表：将找到的索引与最后一个元素交换，然后删除</span>
        <span class="n">nums</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">idx</span><span class="o">,</span> <span class="n">nums</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">));</span>
        <span class="n">nums</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="cm">/** Get a random element from the collection. */</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getRandom</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">Random</span> <span class="n">random</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Random</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="na">nextInt</span><span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">size</span><span class="o">());</span>
        <span class="k">return</span> <span class="n">nums</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">idx</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump387"></span></p><h2 id="387-字符串中的第一个唯一字符">387. 字符串中的第一个唯一字符</h2><p>给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。</p><p>示例：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">s</span> <span class="o">=</span> <span class="s">"leetcode"</span>
<span class="n">返回</span> <span class="mi">0</span>

<span class="n">s</span> <span class="o">=</span> <span class="s">"loveleetcode"</span>
<span class="n">返回</span> <span class="mi">2</span>
</pre></table></code></div></div><p>提示：你可以假定该字符串只包含小写字母。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">firstUniqChar</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">count</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span>

        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">count</span><span class="o">[</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]++;</span>
        <span class="o">}</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">count</span><span class="o">[</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]</span> <span class="o">==</span> <span class="mi">1</span><span class="o">){</span>
                <span class="k">return</span> <span class="n">i</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump389"></span></p><h2 id="389-找不同">389. 找不同</h2><p>给定两个字符串 s 和 t，它们只包含小写字母。</p><p>字符串 t 由字符串 s 随机重排，然后在随机位置添加一个字母。</p><p>请找出在 t 中被添加的字母。</p><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">s</span> <span class="o">=</span> <span class="s">"abcd"</span><span class="o">,</span> <span class="n">t</span> <span class="o">=</span> <span class="s">"abcde"</span>
<span class="n">输出</span><span class="err">：</span><span class="s">"e"</span>
<span class="n">解释</span><span class="err">：</span><span class="sc">'e'</span> <span class="n">是那个被添加的字母</span><span class="err">。</span>
</pre></table></code></div></div><p>示例 2：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">s</span> <span class="o">=</span> <span class="s">""</span><span class="o">,</span> <span class="n">t</span> <span class="o">=</span> <span class="s">"y"</span>
<span class="n">输出</span><span class="err">：</span><span class="s">"y"</span>
</pre></table></code></div></div><p>示例 3：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">s</span> <span class="o">=</span> <span class="s">"a"</span><span class="o">,</span> <span class="n">t</span> <span class="o">=</span> <span class="s">"aa"</span>
<span class="n">输出</span><span class="err">：</span><span class="s">"a"</span>
</pre></table></code></div></div><p>示例 4：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">s</span> <span class="o">=</span> <span class="s">"ae"</span><span class="o">,</span> <span class="n">t</span> <span class="o">=</span> <span class="s">"aea"</span>
<span class="n">输出</span><span class="err">：</span><span class="s">"a"</span>
</pre></table></code></div></div><p>提示：</p><ul><li>0 &lt;= s.length &lt;= 1000</li><li>t.length == s.length + 1</li><li>s 和 t 只包含小写字母</li></ul><p>位运算：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">char</span> <span class="nf">findTheDifference</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="nc">String</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>        
        <span class="kt">char</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">sl</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">tl</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sl</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">res</span> <span class="o">^=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tl</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">res</span> <span class="o">^=</span> <span class="n">t</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-go highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="k">func</span> <span class="n">findTheDifference</span><span class="p">(</span><span class="n">s</span> <span class="kt">string</span><span class="p">,</span> <span class="n">t</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">byte</span> <span class="p">{</span>
    <span class="nb">len</span><span class="p">,</span> <span class="n">ch</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">t</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="n">ch</span> <span class="o">^=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">ch</span> <span class="o">^=</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">ch</span>
<span class="p">}</span>
</pre></table></code></div></div><p><span id="jump402"></span></p><h2 id="402移掉k位数字">402.移掉K位数字</h2><p>给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。</p><p>注意:</p><ul><li>num 的长度小于 10002 且 ≥ k。</li><li>num 不会包含任何前导零。</li></ul><p>示例 1 :</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="n">num</span> <span class="o">=</span> <span class="s">"1432219"</span><span class="o">,</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">3</span>
<span class="nl">输出:</span> <span class="s">"1219"</span>
<span class="nl">解释:</span> <span class="n">移除掉三个数字</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="n">和</span> <span class="mi">2</span> <span class="n">形成一个新的最小的数字</span> <span class="mi">1219</span><span class="err">。</span>
</pre></table></code></div></div><p>示例 2 :</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="n">num</span> <span class="o">=</span> <span class="s">"10200"</span><span class="o">,</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span>
<span class="nl">输出:</span> <span class="s">"200"</span>
<span class="nl">解释:</span> <span class="n">移掉首位的</span> <span class="mi">1</span> <span class="n">剩下的数字为</span> <span class="mi">200</span><span class="o">.</span> <span class="n">注意输出不能有任何前导零</span><span class="err">。</span>
</pre></table></code></div></div><p>示例 3 :</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="n">num</span> <span class="o">=</span> <span class="s">"10"</span><span class="o">,</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">2</span>
<span class="nl">输出:</span> <span class="s">"0"</span>
<span class="nl">解释:</span> <span class="n">从原数字移除所有的数字</span><span class="err">，</span><span class="n">剩余为空就是0</span><span class="err">。</span>
</pre></table></code></div></div><p>逐个删除数字期望开头的数字越小越好。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">removeKdigits</span><span class="o">(</span><span class="nc">String</span> <span class="n">num</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">num</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="o">)</span> <span class="k">return</span> <span class="s">"0"</span><span class="o">;</span>
        <span class="c1">//双端队列</span>
        <span class="nc">Deque</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">&gt;</span> <span class="n">deque</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="c1">//将所有元素依次入栈</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">num</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="c1">//当当前元素比栈顶元素小时，且k&gt;0时，将栈顶弹出</span>
            <span class="k">while</span><span class="o">(!</span><span class="n">deque</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">deque</span><span class="o">.</span><span class="na">peekLast</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">c</span><span class="o">){</span>
                <span class="n">deque</span><span class="o">.</span><span class="na">pollLast</span><span class="o">();</span>
                <span class="n">k</span><span class="o">--;</span>
            <span class="o">}</span>
            <span class="n">deque</span><span class="o">.</span><span class="na">offerLast</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="c1">//若序列都已经单调不降了，但是还有没删干净的数字，那么就将最后几个数字删了</span>
        <span class="k">while</span><span class="o">(</span><span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span>
            <span class="n">deque</span><span class="o">.</span><span class="na">pollLast</span><span class="o">();</span>
            <span class="n">k</span><span class="o">--;</span>
        <span class="o">}</span>
        <span class="c1">//去除前导0</span>
        <span class="k">while</span><span class="o">(</span><span class="n">deque</span><span class="o">.</span><span class="na">peekFirst</span><span class="o">()</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">deque</span><span class="o">.</span><span class="na">peekFirst</span><span class="o">()</span> <span class="o">==</span> <span class="sc">'0'</span><span class="o">){</span>
            <span class="n">deque</span><span class="o">.</span><span class="na">pollFirst</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="c1">//读取数字</span>
        <span class="nc">StringBuffer</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuffer</span><span class="o">();</span>
        <span class="k">while</span><span class="o">(!</span><span class="n">deque</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
            <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">deque</span><span class="o">.</span><span class="na">pollFirst</span><span class="o">());</span>
        <span class="o">}</span>
        <span class="c1">//队列为空，就返回0</span>
        <span class="k">if</span><span class="o">(</span><span class="n">sb</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
            <span class="k">return</span> <span class="s">"0"</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump404"></span></p><h2 id="404左叶子之和">404.左叶子之和</h2><p>计算给定二叉树的所有左叶子之和。</p><p>示例：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>		<span class="mi">3</span>
   <span class="o">/</span> <span class="err">\</span>
  <span class="mi">9</span>  <span class="mi">20</span>
    <span class="o">/</span>  <span class="err">\</span>
   <span class="mi">15</span>   <span class="mi">7</span>
</pre></table></code></div></div><p>递归即可，当访问左子树时，做一次标记，这样可以在访问到左叶子的时候计算和。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">sum</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">sumOfLeftLeaves</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>    <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="n">traversal</span><span class="o">(</span><span class="n">root</span><span class="o">,</span><span class="kc">false</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">sum</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">traversal</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">isLeft</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">isLeft</span><span class="o">){</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>   <span class="n">traversal</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>  <span class="n">traversal</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">,</span><span class="kc">false</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump435"></span></p><h2 id="435-无重叠区间">435. 无重叠区间</h2><p>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p><p>注意:</p><p>可以认为区间的终点总是大于它的起点。 区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。 示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="o">[</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">],</span> <span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">],</span> <span class="o">[</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">],</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span> <span class="o">]</span>

<span class="nl">输出:</span> <span class="mi">1</span>

<span class="nl">解释:</span> <span class="n">移除</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span> <span class="n">后</span><span class="err">，</span><span class="n">剩下的区间没有重叠</span><span class="err">。</span>
</pre></table></code></div></div><p>示例 2:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="o">[</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">],</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">],</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">]</span> <span class="o">]</span>

<span class="nl">输出:</span> <span class="mi">2</span>

<span class="nl">解释:</span> <span class="n">你需要移除两个</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">]</span> <span class="n">来使剩下的区间没有重叠</span><span class="err">。</span>
</pre></table></code></div></div><p>示例 3:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="o">[</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">],</span> <span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span> <span class="o">]</span>

<span class="nl">输出:</span> <span class="mi">0</span>

<span class="nl">解释:</span> <span class="n">你不需要移除任何区间</span><span class="err">，</span><span class="n">因为它们已经是无重叠的了</span><span class="err">。</span>
</pre></table></code></div></div><p>贪心：</p><ul><li>区间相交，就把后一个区间删除</li><li>区间重合，就把前一个区间删除</li></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">eraseOverlapIntervals</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">intervals</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">intervals</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>   <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">intervals</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="c1">//按区间的开始位置排序</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">intervals</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">b</span><span class="o">[</span><span class="mi">0</span><span class="o">]){</span>
                <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">==</span> <span class="n">b</span><span class="o">[</span><span class="mi">0</span><span class="o">]){</span>
                <span class="k">return</span> <span class="n">a</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="n">b</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">});</span>
        <span class="c1">//需要删除的区间个数</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">//遍历区间</span>
        <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="n">intervals</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">0</span><span class="o">],</span> <span class="n">r</span> <span class="o">=</span> <span class="n">intervals</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="c1">//如果当前区间和前一个区间无重叠， 就更新l和r</span>
            <span class="k">if</span><span class="o">(</span><span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">r</span><span class="o">){</span>
                <span class="n">l</span> <span class="o">=</span> <span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>
            <span class="o">}</span><span class="c1">//如果当前区间被前一个区间包裹住了，那就把前一个区间删除</span>
            <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="o">){</span>
                <span class="n">l</span> <span class="o">=</span> <span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>
                <span class="n">res</span><span class="o">++;</span>

            <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">r</span><span class="o">){</span><span class="c1">//如果两个区间只是相交，那就把后一个区间删除</span>
                <span class="n">res</span><span class="o">++;</span>
            <span class="o">}</span>

        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">eraseOverlapIntervals</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">intervals</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">intervals</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>   <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">intervals</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="c1">//按区间的结束位置排序</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">intervals</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">a</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="n">b</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
        <span class="o">});</span>
        <span class="c1">//可留下的区间个数</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="c1">//遍历区间</span>
        <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">intervals</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="c1">//如果当前区间和前一个区间无重叠， 就更新r</span>
            <span class="k">if</span><span class="o">(</span><span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">r</span><span class="o">){</span>
                <span class="n">res</span><span class="o">++;</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>
            <span class="o">}</span>
        

        <span class="o">}</span>
        <span class="k">return</span> <span class="n">n</span> <span class="o">-</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump437"></span></p><h2 id="437路径总和-iii">437.路径总和 III</h2><p>给定一个二叉树，它的每个结点都存放着一个整数值。</p><p>找出路径和等于给定数值的路径总数。</p><p>路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p><p>二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。</p><p>示例：</p><p>root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre>      10
     /  \
    5   -3
   / \    \
  3   2   11
 / \   \
3  -2   1

返回 3。和等于 8 的路径有:

 5 -&gt; 3
 5 -&gt; 2 -&gt; 1
-3 -&gt; 11
</pre></table></code></div></div><p>和第560题类似，只不过这里是多个数组。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">pathSum</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">,</span> <span class="kt">int</span> <span class="n">sum</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//统计每个节点的前缀和pre，放入哈希表中</span>
        <span class="c1">//再遍历每条路径，统计pre - sum出现的个数</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">);</span>
        <span class="n">preOrder</span><span class="o">(</span><span class="n">map</span><span class="o">,</span> <span class="n">root</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span> <span class="n">sum</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">cnt</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">preOrder</span><span class="o">(</span><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">map</span><span class="o">,</span> <span class="nc">TreeNode</span> <span class="n">root</span><span class="o">,</span> <span class="kt">int</span> <span class="n">pre</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="n">pre</span> <span class="o">+=</span> <span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">pre</span> <span class="o">-</span> <span class="n">k</span><span class="o">)){</span>
                <span class="n">cnt</span> <span class="o">+=</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">pre</span> <span class="o">-</span> <span class="n">k</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">pre</span><span class="o">,</span> <span class="n">map</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">pre</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
            <span class="n">preOrder</span><span class="o">(</span><span class="n">map</span><span class="o">,</span> <span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">pre</span><span class="o">,</span> <span class="n">k</span><span class="o">);</span>
            <span class="n">preOrder</span><span class="o">(</span><span class="n">map</span><span class="o">,</span> <span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">pre</span><span class="o">,</span> <span class="n">k</span><span class="o">);</span>
            <span class="c1">//回溯，这样在每个时刻，map中的节点都是同一条路径上的</span>
            <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">pre</span><span class="o">,</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">pre</span><span class="o">)</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump438"></span></p><h2 id="438找到字符串中所有字母异位词">438.找到字符串中所有字母异位词</h2><p>给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。</p><p>字符串只包含小写英文字母，并且字符串 s 和 p 的长度都不超过 20100。</p><p>说明：</p><p>字母异位词指字母相同，但排列不同的字符串。 不考虑答案输出的顺序。 示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="nl">输入:</span>
<span class="nl">s:</span> <span class="s">"cbaebabacd"</span> <span class="nl">p:</span> <span class="s">"abc"</span>
<span class="nl">输出:</span>
<span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="mi">6</span><span class="o">]</span>

<span class="nl">解释:</span>
<span class="n">起始索引等于</span> <span class="mi">0</span> <span class="n">的子串是</span> <span class="s">"cba"</span><span class="o">,</span> <span class="n">它是</span> <span class="s">"abc"</span> <span class="n">的字母异位词</span><span class="err">。</span>
<span class="n">起始索引等于</span> <span class="mi">6</span> <span class="n">的子串是</span> <span class="s">"bac"</span><span class="o">,</span> <span class="n">它是</span> <span class="s">"abc"</span> <span class="n">的字母异位词</span><span class="err">。</span>
</pre></table></code></div></div><p>示例 2:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="nl">输入:</span>
<span class="nl">s:</span> <span class="s">"abab"</span> <span class="nl">p:</span> <span class="s">"ab"</span>

<span class="nl">输出:</span>
<span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">]</span>

<span class="nl">解释:</span>
<span class="n">起始索引等于</span> <span class="mi">0</span> <span class="n">的子串是</span> <span class="s">"ab"</span><span class="o">,</span> <span class="n">它是</span> <span class="s">"ab"</span> <span class="n">的字母异位词</span><span class="err">。</span>
<span class="n">起始索引等于</span> <span class="mi">1</span> <span class="n">的子串是</span> <span class="s">"ba"</span><span class="o">,</span> <span class="n">它是</span> <span class="s">"ab"</span> <span class="n">的字母异位词</span><span class="err">。</span>
<span class="n">起始索引等于</span> <span class="mi">2</span> <span class="n">的子串是</span> <span class="s">"ab"</span><span class="o">,</span> <span class="n">它是</span> <span class="s">"ab"</span> <span class="n">的字母异位词</span><span class="err">。</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="nf">findAnagrams</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="nc">String</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">np</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">ns</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">if</span><span class="o">(</span><span class="n">np</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">ns</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>  <span class="k">return</span>  <span class="n">res</span><span class="o">;</span>

        <span class="c1">//现将p中的字符打到表中</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">table</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">table</span><span class="o">[</span><span class="n">p</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]++;</span>
        <span class="o">}</span>

        <span class="c1">//初始化滑动窗口，窗口大小为np</span>
        <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">char</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>

        <span class="c1">//记录窗口状态的表</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">cur</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span>
        <span class="k">while</span><span class="o">(</span><span class="n">l</span> <span class="o">&lt;=</span> <span class="o">(</span><span class="n">ns</span><span class="o">-</span><span class="n">np</span><span class="o">)){</span>
            <span class="c1">//窗口增长期</span>
            <span class="k">if</span><span class="o">(</span><span class="n">r</span> <span class="o">==</span> <span class="n">l</span><span class="o">){</span>
                <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">cur</span><span class="o">,</span><span class="mi">0</span><span class="o">);</span>
                <span class="kt">boolean</span> <span class="n">tag</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">l</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">l</span><span class="o">+</span><span class="n">np</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
                    <span class="c1">//table表中没有这个字符</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">table</span><span class="o">[</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
                        <span class="n">l</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
                        <span class="n">tag</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                        <span class="k">break</span><span class="o">;</span>
                    <span class="o">}</span>
                    <span class="c1">//table表中有这个字符</span>

                    <span class="c1">//这个字符出现的次数超过了table表</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">table</span><span class="o">[</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">cur</span><span class="o">[</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]+</span><span class="mi">1</span><span class="o">){</span>
                        <span class="n">l</span><span class="o">++;</span>
                        <span class="n">tag</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                        <span class="k">break</span><span class="o">;</span>
                    <span class="o">}</span>
                    <span class="n">cur</span><span class="o">[</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]++;</span>
                <span class="o">}</span>
                <span class="c1">//是由于异常才结束循环的</span>
                <span class="k">if</span><span class="o">(</span><span class="n">tag</span> <span class="o">==</span> <span class="kc">false</span><span class="o">){</span>
                    <span class="n">r</span> <span class="o">=</span> <span class="n">l</span><span class="o">;</span>
                    <span class="k">continue</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="c1">//正常结束循环，说明全部比较完毕了，都没有出现异常</span>
                <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">l</span><span class="o">);</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">l</span> <span class="o">+</span> <span class="n">np</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="c1">//窗口滑动期</span>
                <span class="c1">//指针l和r同时向右滑动一个单位</span>
                <span class="n">r</span><span class="o">++;</span>
                <span class="c1">//超出了边界</span>
                <span class="k">if</span><span class="o">(</span><span class="n">r</span><span class="o">-</span><span class="mi">1</span> <span class="o">==</span> <span class="n">ns</span><span class="o">){</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="c1">//新加入的字符和移出去的字符相同</span>
                <span class="k">if</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">r</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="n">arr</span><span class="o">[</span><span class="n">l</span><span class="o">]){</span>
                    <span class="n">l</span><span class="o">++;</span>
                    <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">l</span><span class="o">);</span>
                <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                    <span class="c1">//回到窗口增长期</span>
                    <span class="n">l</span><span class="o">++;</span>
                    <span class="n">r</span> <span class="o">=</span> <span class="n">l</span><span class="o">;</span>
                <span class="o">}</span>

            <span class="o">}</span>


        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>

    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump452"></span></p><h2 id="452用最少数量的箭引爆气球">452.用最少数量的箭引爆气球</h2><p>在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。</p><p>一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足 xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。</p><p>给你一个数组 points ，其中 points [i] = [xstart,xend] ，返回引爆所有气球所必须射出的最小弓箭数。</p><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">points</span> <span class="o">=</span> <span class="o">[[</span><span class="mi">10</span><span class="o">,</span><span class="mi">16</span><span class="o">],[</span><span class="mi">2</span><span class="o">,</span><span class="mi">8</span><span class="o">],[</span><span class="mi">1</span><span class="o">,</span><span class="mi">6</span><span class="o">],[</span><span class="mi">7</span><span class="o">,</span><span class="mi">12</span><span class="o">]]</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">2</span>
<span class="n">解释</span><span class="err">：</span><span class="n">对于该样例</span><span class="err">，</span><span class="n">x</span> <span class="o">=</span> <span class="mi">6</span> <span class="n">可以射爆</span> <span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">8</span><span class="o">],[</span><span class="mi">1</span><span class="o">,</span><span class="mi">6</span><span class="o">]</span> <span class="n">两个气球</span><span class="err">，</span><span class="n">以及</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">11</span> <span class="n">射爆另外两个气球</span>
</pre></table></code></div></div><p>示例 2：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">points</span> <span class="o">=</span> <span class="o">[[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">],[</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">],[</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">],[</span><span class="mi">7</span><span class="o">,</span><span class="mi">8</span><span class="o">]]</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">4</span>
</pre></table></code></div></div><p>示例 3：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">points</span> <span class="o">=</span> <span class="o">[[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">],[</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">],[</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">],[</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">]]</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">2</span>
</pre></table></code></div></div><p>示例 4：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">points</span> <span class="o">=</span> <span class="o">[[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">]]</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">1</span>
</pre></table></code></div></div><p>示例 5：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">points</span> <span class="o">=</span> <span class="o">[[</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">],[</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]]</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">1</span>
</pre></table></code></div></div><p>提示：</p><ul><li>0 &lt;= points.length &lt;= 104</li><li>points[i].length == 2</li><li>-231 &lt;= xstart &lt; xend &lt;= 231 - 1</li></ul><p>贪心左端点排序：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">findMinArrowShots</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">points</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">points</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>  <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">//区间排序：先按开始坐标升序排序，再按结束坐标升序排序</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">points</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">)-&gt;{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">b</span><span class="o">[</span><span class="mi">0</span><span class="o">]){</span>
                <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">==</span> <span class="n">b</span><span class="o">[</span><span class="mi">0</span><span class="o">]){</span>
                <span class="k">return</span> <span class="n">a</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="n">b</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">});</span>

        <span class="kt">int</span><span class="o">[]</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">points</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">//贪心地覆盖一个区间，使其包括后序与此区间相交区间，并更新此区间为二者的交集</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">points</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="c1">//cur的结束大于等于下一个区间的开始，说明可以一起戳破</span>
            <span class="k">if</span><span class="o">(</span><span class="n">cur</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">points</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]){</span>
                <span class="c1">//更新cur</span>
                <span class="n">cur</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">cur</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">points</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]);</span>
                <span class="n">cur</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">cur</span><span class="o">[</span><span class="mi">1</span><span class="o">],</span> <span class="n">points</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">]);</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="c1">//cur的结束小于下一个区间的开始，说明没办法一起戳破了</span>
                <span class="c1">//弓箭数+1，移动cur</span>
                <span class="n">res</span><span class="o">++;</span>
                <span class="n">cur</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">points</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>
                <span class="n">cur</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">points</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">res</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>贪心右端点排序，只需要知道最远可射到的位置即可</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">findMinArrowShots</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">points</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">points</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>  <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">//区间排序：先按开始坐标升序排序，再按结束坐标升序排序</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">points</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">)-&gt;{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">b</span><span class="o">[</span><span class="mi">1</span><span class="o">]){</span>
                <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">});</span>

        <span class="kt">int</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">points</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">//贪心地覆盖一个区间，使其包括后序与此区间相交区间，并更新此区间为二者的交集</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">points</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="c1">//cur的结束大于等于下一个区间的开始，说明可以一起戳破</span>
            <span class="k">if</span><span class="o">(</span><span class="n">cur</span> <span class="o">&lt;</span> <span class="n">points</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]){</span>
                <span class="n">res</span><span class="o">++;</span>
                <span class="n">cur</span> <span class="o">=</span> <span class="n">points</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">res</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump455"></span></p><h2 id="455-分发饼干">455. 分发饼干</h2><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p><p>对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p><p>示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="n">g</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">],</span> <span class="n">s</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">]</span>
<span class="nl">输出:</span> <span class="mi">1</span>
<span class="nl">解释:</span> 
<span class="n">你有三个孩子和两块小饼干</span><span class="err">，</span><span class="mi">3</span><span class="n">个孩子的胃口值分别是</span><span class="err">：</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="err">。</span>
<span class="n">虽然你有两块小饼干</span><span class="err">，</span><span class="n">由于他们的尺寸都是1</span><span class="err">，</span><span class="n">你只能让胃口值是1的孩子满足</span><span class="err">。</span>
<span class="n">所以你应该输出1</span><span class="err">。</span>
</pre></table></code></div></div><p>示例 2:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="n">g</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">],</span> <span class="n">s</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span>
<span class="nl">输出:</span> <span class="mi">2</span>
<span class="nl">解释:</span> 
<span class="n">你有两个孩子和三块小饼干</span><span class="err">，</span><span class="mi">2</span><span class="n">个孩子的胃口值分别是1</span><span class="o">,</span><span class="mi">2</span><span class="err">。</span>
<span class="n">你拥有的饼干数量和尺寸都足以让所有孩子满足</span><span class="err">。</span>
<span class="n">所以你应该输出2</span><span class="o">.</span>
</pre></table></code></div></div><p>提示：</p><ul><li>1 &lt;= g.length &lt;= 3 * 104</li><li>0 &lt;= s.length &lt;= 3 * 104</li><li>1 &lt;= g[i], s[j] &lt;= 231 - 1</li></ul><p>排序+双指针</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">findContentChildren</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">g</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>

        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">g</span><span class="o">);</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
        
        <span class="kt">int</span> <span class="n">p1</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">p2</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">p1</span> <span class="o">&lt;</span> <span class="n">g</span><span class="o">.</span><span class="na">length</span> <span class="o">&amp;&amp;</span> <span class="n">p2</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">g</span><span class="o">[</span><span class="n">p1</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">s</span><span class="o">[</span><span class="n">p2</span><span class="o">]){</span>
                <span class="n">res</span><span class="o">++;</span>
                <span class="n">p1</span><span class="o">++;</span>
                <span class="n">p2</span><span class="o">++;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="n">p2</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump459"></span></p><h2 id="459重复的子字符串">459.重复的子字符串</h2><p>给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。</p><p>示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="s">"abab"</span>
<span class="nl">输出:</span> <span class="nc">True</span>
<span class="nl">解释:</span> <span class="n">可由子字符串</span> <span class="s">"ab"</span> <span class="n">重复两次构成</span><span class="err">。</span>
</pre></table></code></div></div><p>示例 2:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="s">"aba"</span>
<span class="nl">输出:</span> <span class="nc">False</span>
</pre></table></code></div></div><p>示例 3:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="s">"abcabcabcabc"</span>
<span class="nl">输出:</span> <span class="nc">True</span>
<span class="nl">解释:</span> <span class="n">可由子字符串</span> <span class="s">"abc"</span> <span class="n">重复四次构成</span><span class="err">。</span> <span class="o">(</span><span class="n">或者子字符串</span> <span class="s">"abcabc"</span> <span class="n">重复两次构成</span><span class="err">。</span><span class="o">)</span>
</pre></table></code></div></div><h3 id="枚举法">枚举法</h3><p>若存在这种形式的字符串，那么必有：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">sub</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">*</span> <span class="n">k</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span>	<span class="o">(</span><span class="n">k</span><span class="o">!=</span><span class="mi">1</span><span class="o">)</span>
</pre></table></code></div></div><p>循环添加sub k-1次，最终结果若与s相等，则返回true。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">repeatedSubstringPattern</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()/</span><span class="mi">2</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">%</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>   <span class="k">continue</span><span class="o">;</span>
            <span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">/</span> <span class="n">i</span><span class="o">;</span>
            <span class="nc">String</span> <span class="n">res</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="n">i</span><span class="o">);</span>
            <span class="nc">String</span> <span class="n">subS</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="n">i</span><span class="o">);</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">p</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                <span class="n">res</span><span class="o">+=</span><span class="n">subS</span><span class="o">;</span>
                <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">res</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="n">i</span><span class="o">*</span><span class="n">j</span><span class="o">)))</span>
                    <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">if</span><span class="o">(</span><span class="n">res</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">s</span><span class="o">))</span>
                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="字符串匹配">字符串匹配</h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/HYCBlog/assets/img/leetcode/leetcode_repeated_substring_pattern.png" alt="leetcode_repeated_substring_pattern" /></p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">repeatedSubstringPattern</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="o">(</span><span class="n">s</span> <span class="o">+</span> <span class="n">s</span><span class="o">).</span><span class="na">indexOf</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span> <span class="o">!=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="n">作者</span><span class="err">：</span><span class="nc">LeetCode</span><span class="o">-</span><span class="nc">Solution</span>
<span class="n">链接</span><span class="err">：</span><span class="nl">https:</span><span class="c1">//leetcode-cn.com/problems/repeated-substring-pattern/solution/zhong-fu-de-zi-zi-fu-chuan-by-leetcode-solution/</span>
</pre></table></code></div></div><h3 id="kmp算法">KMP算法</h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/HYCBlog/assets/img/leetcode/leetcode_repeated_substring_pattern_KMP_1.png" alt="leetcode_重复的子字符串_字符串匹配_KMP_1" /></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/HYCBlog/assets/img/leetcode/leetcode_repeated_substring_pattern_KMP_2.png" alt="leetcode_重复的子字符串_字符串匹配_KMP_2" /></p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">repeatedSubstringPattern</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">kmp</span><span class="o">(</span><span class="n">s</span> <span class="o">+</span> <span class="n">s</span><span class="o">,</span> <span class="n">s</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">kmp</span><span class="o">(</span><span class="nc">String</span> <span class="n">query</span><span class="o">,</span> <span class="nc">String</span> <span class="n">pattern</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">pattern</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">fail</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">m</span><span class="o">];</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">fail</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">fail</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">j</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">pattern</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">!=</span> <span class="n">pattern</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">fail</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">pattern</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">==</span> <span class="n">pattern</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">fail</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="kt">int</span> <span class="n">match</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">match</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">pattern</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">match</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">!=</span> <span class="n">query</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">match</span> <span class="o">=</span> <span class="n">fail</span><span class="o">[</span><span class="n">match</span><span class="o">];</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">pattern</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">match</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">==</span> <span class="n">query</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">))</span> <span class="o">{</span>
                <span class="o">++</span><span class="n">match</span><span class="o">;</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">match</span> <span class="o">==</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="n">作者</span><span class="err">：</span><span class="nc">LeetCode</span><span class="o">-</span><span class="nc">Solution</span>
<span class="n">链接</span><span class="err">：</span><span class="nl">https:</span><span class="c1">//leetcode-cn.com/problems/repeated-substring-pattern/solution/zhong-fu-de-zi-zi-fu-chuan-by-leetcode-solution/</span>
</pre></table></code></div></div><p><span id="jump463"></span></p><h2 id="463岛屿的周长">463.岛屿的周长</h2><p>给定一个包含 0 和 1 的二维网格地图，其中 1 表示陆地 0 表示水域。</p><p>网格中的格子水平和垂直方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。</p><p>岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。</p><p>示例 :</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="nl">输入:</span>
<span class="o">[[</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">],</span>
 <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">],</span>
 <span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">],</span>
 <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">]]</span>

<span class="nl">输出:</span> <span class="mi">16</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">islandPerimeter</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">grid</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">grid</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>    <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">grid</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">grid</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="n">grid</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">?</span> <span class="mi">4</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">grid</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">grid</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">continue</span><span class="o">;</span>
                <span class="c1">//只有一行</span>
                <span class="k">if</span><span class="o">(</span><span class="n">grid</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">1</span><span class="o">){</span>
                    <span class="c1">//左边界</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
                        <span class="n">res</span> <span class="o">+=</span> <span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
                        <span class="n">res</span> <span class="o">+=</span> <span class="mi">3</span><span class="o">;</span>
                    <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">grid</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">){</span>
                        <span class="n">res</span> <span class="o">+=</span> <span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
                        <span class="n">res</span> <span class="o">+=</span> <span class="mi">3</span><span class="o">;</span>
                    <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                        <span class="n">res</span> <span class="o">+=</span> <span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
                        <span class="n">res</span> <span class="o">+=</span> <span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
                        <span class="n">res</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">;</span>
                    <span class="o">}</span>
                    <span class="k">continue</span><span class="o">;</span>
                <span class="c1">//只有一列</span>
                <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">grid</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span> <span class="o">==</span> <span class="mi">1</span><span class="o">){</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
                        <span class="n">res</span> <span class="o">+=</span> <span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
                        <span class="n">res</span> <span class="o">+=</span> <span class="mi">3</span><span class="o">;</span>
                    <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">grid</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">){</span>
                        <span class="n">res</span> <span class="o">+=</span> <span class="n">grid</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
                        <span class="n">res</span> <span class="o">+=</span> <span class="mi">3</span><span class="o">;</span>
                    <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                        <span class="n">res</span> <span class="o">+=</span> <span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
                        <span class="n">res</span> <span class="o">+=</span> <span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
                        <span class="n">res</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">;</span>
                    <span class="o">}</span>
                    <span class="k">continue</span><span class="o">;</span>
                <span class="o">}</span>


                <span class="c1">//边界和四个对角特别判断</span>

                <span class="c1">//1.在上边界</span>
                <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
                    <span class="c1">//在左上角</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
                        <span class="n">res</span> <span class="o">+=</span> <span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
                        <span class="n">res</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">;</span>
                    <span class="c1">//在右上角</span>
                    <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">grid</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">){</span>
                        <span class="n">res</span> <span class="o">+=</span> <span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
                        <span class="n">res</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">;</span>
                    <span class="c1">//上边界的边上，不包含角</span>
                    <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                        <span class="n">res</span> <span class="o">+=</span> <span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
                        <span class="n">res</span> <span class="o">+=</span> <span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
                        <span class="n">res</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">;</span>
                    <span class="o">}</span>
                    <span class="n">res</span> <span class="o">+=</span> <span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
                <span class="c1">//2.在下边界</span>
                <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span> <span class="n">i</span> <span class="o">==</span> <span class="n">grid</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">){</span>
                    <span class="c1">//在左下角</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
                        <span class="n">res</span> <span class="o">+=</span> <span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
                        <span class="n">res</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">;</span>
                    <span class="c1">//在右下角</span>
                    <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">grid</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">){</span>
                        <span class="n">res</span> <span class="o">+=</span> <span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
                        <span class="n">res</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">;</span>
                    <span class="c1">//下边界的边上，不包含角</span>
                    <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                        <span class="n">res</span> <span class="o">+=</span> <span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
                        <span class="n">res</span> <span class="o">+=</span> <span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
                        <span class="n">res</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">;</span>
                    <span class="o">}</span>
                    <span class="n">res</span> <span class="o">+=</span> <span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
                <span class="c1">//3.在左边界，不包含角</span>
                <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">j</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">grid</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">){</span>
                    <span class="n">res</span> <span class="o">+=</span> <span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
                    <span class="n">res</span> <span class="o">+=</span> <span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
                    <span class="n">res</span> <span class="o">+=</span> <span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
                    <span class="n">res</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">;</span>
                <span class="c1">//4.在右边界，不包含角</span>
                <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">grid</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">grid</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">){</span>
                    <span class="n">res</span> <span class="o">+=</span> <span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
                    <span class="n">res</span> <span class="o">+=</span> <span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
                    <span class="n">res</span> <span class="o">+=</span> <span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
                    <span class="n">res</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">;</span>
                <span class="c1">//5.其他情况</span>
                <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">)</span>  <span class="n">res</span> <span class="o">+=</span> <span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">grid</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="n">res</span> <span class="o">+=</span> <span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">)</span>  <span class="n">res</span> <span class="o">+=</span> <span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">grid</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">)</span> <span class="n">res</span> <span class="o">+=</span> <span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
                <span class="o">}</span>

            <span class="o">}</span>
            
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">dx</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">};</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">dy</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">};</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">islandPerimeter</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">grid</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="na">length</span><span class="o">,</span> <span class="n">m</span> <span class="o">=</span> <span class="n">grid</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                    <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> 
                    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="o">;</span> <span class="o">++</span><span class="n">k</span><span class="o">)</span> <span class="o">{</span>
                        <span class="kt">int</span> <span class="n">tx</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">dx</span><span class="o">[</span><span class="n">k</span><span class="o">];</span>
                        <span class="kt">int</span> <span class="n">ty</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="n">dy</span><span class="o">[</span><span class="n">k</span><span class="o">];</span>
                        <span class="k">if</span> <span class="o">(</span><span class="n">tx</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">tx</span> <span class="o">&gt;=</span> <span class="n">n</span> <span class="o">||</span> <span class="n">ty</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">ty</span> <span class="o">&gt;=</span> <span class="n">m</span> <span class="o">||</span> <span class="n">grid</span><span class="o">[</span><span class="n">tx</span><span class="o">][</span><span class="n">ty</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                            <span class="n">cnt</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">;</span>
                        <span class="o">}</span>
                    <span class="o">}</span>
                    <span class="n">ans</span> <span class="o">+=</span> <span class="n">cnt</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

</pre></table></code></div></div><p><span id="jump486"></span></p><h2 id="486预测赢家">486.预测赢家</h2><p>给定一个表示分数的非负整数数组。 玩家 1 从数组任意一端拿取一个分数，随后玩家 2 继续从剩余数组任意一端拿取分数，然后玩家 1 拿，…… 。每次一个玩家只能拿取一个分数，分数被拿取之后不再可取。直到没有剩余分数可取时游戏结束。最终获得分数总和最多的玩家获胜。</p><p>给定一个表示分数的数组，预测玩家1是否会成为赢家。你可以假设每个玩家的玩法都会使他的分数最大化。</p><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">2</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="nc">False</span>
<span class="n">解释</span><span class="err">：</span><span class="n">一开始</span><span class="err">，</span><span class="n">玩家1可以从1和2中进行选择</span><span class="err">。</span>
<span class="n">如果他选择</span> <span class="mi">2</span><span class="err">（</span><span class="n">或者</span> <span class="mi">1</span> <span class="err">），</span><span class="n">那么玩家</span> <span class="mi">2</span> <span class="n">可以从</span> <span class="mi">1</span><span class="err">（</span><span class="n">或者</span> <span class="mi">2</span> <span class="err">）</span><span class="n">和</span> <span class="mi">5</span> <span class="n">中进行选择</span><span class="err">。</span><span class="n">如果玩家</span> <span class="mi">2</span> <span class="n">选择了</span> <span class="mi">5</span> <span class="err">，</span><span class="n">那么玩家</span> <span class="mi">1</span> <span class="n">则只剩下</span> <span class="mi">1</span><span class="err">（</span><span class="n">或者</span> <span class="mi">2</span> <span class="err">）</span><span class="n">可选</span><span class="err">。</span>
<span class="n">所以</span><span class="err">，</span><span class="n">玩家</span> <span class="mi">1</span> <span class="n">的最终分数为</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">=</span> <span class="mi">3</span><span class="err">，</span><span class="n">而玩家</span> <span class="mi">2</span> <span class="n">为</span> <span class="mi">5</span> <span class="err">。</span>
<span class="n">因此</span><span class="err">，</span><span class="n">玩家</span> <span class="mi">1</span> <span class="n">永远不会成为赢家</span><span class="err">，</span><span class="n">返回</span> <span class="nc">False</span> <span class="err">。</span>
</pre></table></code></div></div><p>示例 2：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">233</span><span class="o">,</span> <span class="mi">7</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="nc">True</span>
<span class="n">解释</span><span class="err">：</span><span class="n">玩家</span> <span class="mi">1</span> <span class="n">一开始选择</span> <span class="mi">1</span> <span class="err">。</span><span class="n">然后玩家</span> <span class="mi">2</span> <span class="n">必须从</span> <span class="mi">5</span> <span class="n">和</span> <span class="mi">7</span> <span class="n">中进行选择</span><span class="err">。</span><span class="n">无论玩家</span> <span class="mi">2</span> <span class="n">选择了哪个</span><span class="err">，</span><span class="n">玩家</span> <span class="mi">1</span> <span class="n">都可以选择</span> <span class="mi">233</span> <span class="err">。</span>
<span class="n">最终</span><span class="err">，</span><span class="n">玩家</span> <span class="mi">1</span><span class="err">（</span><span class="mi">234</span> <span class="n">分</span><span class="err">）</span><span class="n">比玩家</span> <span class="mi">2</span><span class="err">（</span><span class="mi">12</span> <span class="n">分</span><span class="err">）</span><span class="n">获得更多的分数</span><span class="err">，</span><span class="n">所以返回</span> <span class="nc">True</span><span class="err">，</span><span class="n">表示玩家</span> <span class="mi">1</span> <span class="n">可以成为赢家</span><span class="err">。</span>
</pre></table></code></div></div><p>提示：</p><ul><li>1 &lt;= 给定的数组长度 &lt;= 20.</li><li>数组里所有分数都为非负数且不会大于 10000000 。</li><li>如果最终两个玩家的分数相等，那么玩家 1 仍为赢家。</li></ul><h3 id="动态规划-1">动态规划</h3><p>对于偶数个数字的数组，玩家1一定获胜。因为如果玩家1选择拿法A，玩家2选择拿法B，玩家1输了。则玩家1换一种拿法选择拿法B，因为玩家1是先手，所以玩家1一定可以获胜。</p><p>对于奇数个数字的数组，利用动态规划（dynamic programming）计算。 首先证明最优子结构性质。对于数组<code class="language-plaintext highlighter-rouge">[1..n]</code>中的子数组<code class="language-plaintext highlighter-rouge">[i..j]</code>，假设玩家1在子数组<code class="language-plaintext highlighter-rouge">[i..j]</code>中的拿法是最优的，即拿的分数比玩家2多出最多。假设玩家1拿了<code class="language-plaintext highlighter-rouge">i</code>，则<code class="language-plaintext highlighter-rouge">[i+1..j]</code>中玩家1拿的方法也一定是最优的。利用反证法证明：如果玩家1在<code class="language-plaintext highlighter-rouge">[i+1..j]</code>中有更优的拿法，即玩家1在<code class="language-plaintext highlighter-rouge">[i+1...j]</code>可以拿到更多的分数，则玩家在<code class="language-plaintext highlighter-rouge">[i..j]</code>中拿到的分数就会比假设的最优拿法拿到的分数更多，显然矛盾。如果玩家1拿了j，同理可证矛盾。 所以当前问题的最优解包含的子问题的解一定也是子问题的最优解。</p><p>对于只有一个数字的子数组,即<code class="language-plaintext highlighter-rouge">i=j，dp[i][i] = num[i]</code>，因为玩家1先手拿了这一个分数，玩家2就没得拿了，所以是最优拿法。 对于两个数字的子数组,即<code class="language-plaintext highlighter-rouge">j-i=1，dp[i][j]=abs(num[i]-num[j])</code>,玩家1先手拿两个数中大的一个，所以玩家1一定比玩家2多两个数字差的绝对值，为最优拿法。 对于<code class="language-plaintext highlighter-rouge">j-i&gt;1</code>的子数组，如果玩家1先手拿了<code class="language-plaintext highlighter-rouge">i</code>，则玩家1手里有<code class="language-plaintext highlighter-rouge">num[i]</code>分，则玩家2一定会按照<code class="language-plaintext highlighter-rouge">[i+1..j]</code>这个子数组中的最优拿法去拿，于是玩家2此时手里相当于有<code class="language-plaintext highlighter-rouge">dp[i+1][j]</code>分，于是玩家1比玩家2多<code class="language-plaintext highlighter-rouge">num[i]-dp[i+1][j]</code>分。如果玩家1先手拿了<code class="language-plaintext highlighter-rouge">j</code>，则玩家1手里有<code class="language-plaintext highlighter-rouge">num[j]</code>分，则玩家2一定会按照<code class="language-plaintext highlighter-rouge">[i..j-1]</code>这个子数组中的最优拿法去拿，于是玩家2此时手里相当于有<code class="language-plaintext highlighter-rouge">dp[i][j-1]</code>分，于是玩家1比玩家2多<code class="language-plaintext highlighter-rouge">num[j]-dp[i][j-1]</code>分。数组的填充方向是从下往上，从左到右，最后填充的是<code class="language-plaintext highlighter-rouge">dp[1][n]</code>。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">player1</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">player2</span><span class="o">;</span>
    <span class="kt">boolean</span> <span class="n">flag</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">PredictTheWinner</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">][</span><span class="n">n</span><span class="o">];</span>
      	<span class="c1">//先填充对角线</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="o">}</span>
     <span class="c1">//从对角线开始迭代，从下往上，因为最小的子结构为i=j，最终的结果是[0,n]，所以dp的结果是dp[0][n-1]</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="o">--</span><span class="n">i</span><span class="o">){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
              	<span class="c1">//记录得分差，若当前玩家选择了i，那么下一个玩家肯定会选择[i+1,j]的最优拿法</span>
                <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">],</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">-</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">]);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span>

    <span class="o">}</span>

    
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump493"></span></p><h2 id="493翻转对">493.翻转对</h2><p>给定一个数组 nums ，如果 i &lt; j 且 nums[i] &gt; 2*nums[j] 我们就将 (i, j) 称作一个重要翻转对。</p><p>你需要返回给定数组中的重要翻转对的数量。</p><p>示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">1</span><span class="o">]</span>
<span class="nl">输出:</span> <span class="mi">2</span>
</pre></table></code></div></div><p>示例 2:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">1</span><span class="o">]</span>
<span class="nl">输出:</span> <span class="mi">3</span>
</pre></table></code></div></div><p>注意:</p><ul><li>给定数组的长度不会超过50000。</li><li>输入数组中的所有数字都在32位整数的表示范围内。</li></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="c1">//归并排序，对于数组nums[l...r]</span>
    <span class="c1">//我们已经分别求出了子数组nums[l...m]与nums[m+1...r]的翻转对数量</span>
    <span class="c1">//并已经将两个子数组分别排好序(归并排序的特点)</span>
    <span class="c1">//则nums[l...r]中的翻转对数量就是两个子数组翻转对数量之和</span>
    <span class="c1">//加上左右端点分别位于两个子数组的翻转对数量</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">reversePairs</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>    <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">return</span> <span class="nf">reversePair</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">reversePair</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">left</span> <span class="o">==</span> <span class="n">right</span><span class="o">){</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>
        
        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="o">(</span><span class="n">right</span> <span class="o">+</span> <span class="n">left</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">n1</span> <span class="o">=</span> <span class="n">reversePair</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">mid</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">n2</span> <span class="o">=</span> <span class="n">reversePair</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">right</span><span class="o">);</span>

        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">n1</span> <span class="o">+</span> <span class="n">n2</span><span class="o">;</span>

        <span class="c1">//统计下标对的数量</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">left</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>

        <span class="c1">//遍历每一个i</span>
        <span class="k">while</span><span class="o">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">mid</span><span class="o">){</span>
            <span class="c1">//移动j,直到找到nums[i] &lt;= 2 * nums[j]的位置，那么后续的nums[j]就没必要遍历了</span>
            <span class="k">while</span><span class="o">(</span><span class="n">j</span> <span class="o">&lt;=</span> <span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="kt">long</span><span class="o">)</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="o">(</span><span class="kt">long</span><span class="o">)</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]){</span>
                <span class="o">++</span><span class="n">j</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="c1">//记录符合要求的下标对</span>
            <span class="n">res</span> <span class="o">+=</span> <span class="n">j</span> <span class="o">-</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
            <span class="n">i</span><span class="o">++;</span>
        <span class="o">}</span>

        <span class="c1">//合并数组</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">sorted</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">p1</span> <span class="o">=</span> <span class="n">left</span><span class="o">,</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="k">while</span><span class="o">(</span><span class="n">p1</span> <span class="o">&lt;=</span> <span class="n">mid</span> <span class="o">||</span> <span class="n">p2</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">p1</span> <span class="o">&gt;</span> <span class="n">mid</span><span class="o">){</span>
                <span class="n">sorted</span><span class="o">[</span><span class="n">p</span><span class="o">++]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">p2</span><span class="o">++];</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">p2</span> <span class="o">&gt;</span> <span class="n">right</span><span class="o">){</span>
                <span class="n">sorted</span><span class="o">[</span><span class="n">p</span><span class="o">++]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">p1</span><span class="o">++];</span>
            <span class="o">}</span>
            <span class="k">else</span><span class="o">{</span>
                <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">p1</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">p2</span><span class="o">]){</span>
                    <span class="n">sorted</span><span class="o">[</span><span class="n">p</span><span class="o">++]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">p1</span><span class="o">++];</span>
                <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                    <span class="n">sorted</span><span class="o">[</span><span class="n">p</span><span class="o">++]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">p2</span><span class="o">++];</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">sorted</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">k</span><span class="o">){</span>
            <span class="n">nums</span><span class="o">[</span><span class="n">left</span> <span class="o">+</span> <span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">sorted</span><span class="o">[</span><span class="n">k</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/HYCBlog/categories/blogging/'>Blogging</a>, <a href='/HYCBlog/categories/leetcode/'>leetcode</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/HYCBlog/tags/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/" class="post-tag no-text-decoration" >算法题解</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><!-- Post sharing snippet v2.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2019 Cotes Chung Published under the MIT License --><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Leetcode题解:200~500 - 黄玉才的博客&url=www.yucaihuang.com/HYCBlog/posts/leetcode-solution_200_500/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Leetcode题解:200~500 - 黄玉才的博客&u=www.yucaihuang.com/HYCBlog/posts/leetcode-solution_200_500/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Leetcode题解:200~500 - 黄玉才的博客&url=www.yucaihuang.com/HYCBlog/posts/leetcode-solution_200_500/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><!-- The Pannel on right side (Desktop views) v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"><h3 data-toc-skip>Recent Update</h3><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/HYCBlog/posts/leetcode-solution_200_500/">Leetcode题解:200~500</a></li><li><a href="/HYCBlog/posts/leetcode-solution_101_200/">Leetcode题解:101~200</a></li><li><a href="/HYCBlog/posts/leetcode-solution_hot_100/">Leetcode题解:Hot 100!</a></li><li><a href="/HYCBlog/posts/point-to-offers/">剑指offer题解</a></li></ul></div><div id="access-tags"><h3 data-toc-skip>Trending Tags</h3><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/HYCBlog/tags/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/">算法题解</a> <a class="post-tag" href="/HYCBlog/tags/java%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/">Java源码学习</a> <a class="post-tag" href="/HYCBlog/tags/jvm/">jvm</a> <a class="post-tag" href="/HYCBlog/tags/java/">java</a> <a class="post-tag" href="/HYCBlog/tags/algorithms/">Algorithms</a> <a class="post-tag" href="/HYCBlog/tags/web/">web</a> <a class="post-tag" href="/HYCBlog/tags/security/">security</a> <a class="post-tag" href="/HYCBlog/tags/redis/">redis</a> <a class="post-tag" href="/HYCBlog/tags/concurrency/">concurrency</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><h3 data-toc-skip class="pl-3 pt-2 mb-2">Contents</h3><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"> <!-- Recommend the other 3 posts according to the tags and categories of the current post, if the number is not enough, use the other latest posts to supplement. v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2019 Cotes Chung Published under the MIT License --><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/HYCBlog/posts/leetcode-solutions/"><div class="card-body"> <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <span class="timeago small" > Sep 23, 2020 <i class="unloaded">2020-09-23T08:29:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Leetcode题解:1~500</h3><div class="text-muted small"><p> 目录 5.最长回文子串 16.最接近三数之和 17.电话号码的字母组合 18.四数之和 19.删除链表的倒数第N个节点 24.两两交换链表中的节点 37.解数独 39.组合总和1 40.组合总和2 43.字符串相乘 47.全排列 50.Pow(x, n) 51.N 皇后 52.N皇后 II[tag] 57.插入区间 60.第k个排列[tag] 62.不同路径...</p></div></div></a></div><div class="card"> <a href="/HYCBlog/posts/leetcode-solution_hot_100/"><div class="card-body"> <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <span class="timeago small" > Oct 23, 2020 <i class="unloaded">2020-10-23T13:51:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Leetcode题解:Hot 100!</h3><div class="text-muted small"><p> 目录 1.两数之和 2.两数相加 4. 寻找两个正序数组的中位数 5.最长回文子串 10. 正则表达式匹配 11.盛最多水的容器 15.三数之和 17.电话号码的字母组合 19.删除链表的倒数第N个节点 20.有效的括号 21.合并两个有序链表 22.括号生成 31.下一个排列 32. 最长有效括号 33.搜索旋转排序数组 34.[重要]在排序数组中查找元素的...</p></div></div></a></div><div class="card"> <a href="/HYCBlog/posts/leetcode-solutions-500-1000/"><div class="card-body"> <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <span class="timeago small" > Aug 23, 2020 <i class="unloaded">2020-08-23T20:44:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Leetcode题解:500-1000</h3><div class="text-muted small"><p> 目录 501.二叉搜索树中的众数 509. 斐波那契数 514.自由之路 529.扫雷游戏 530.二叉搜索树的最小绝对差 538.将二叉搜索树转换为累加树 543.二叉树的直径 546.移除盒子 557.反转字符串中的单词 III 605. 种花问题 617.合并二叉树 621.任务调度器 637.二叉树的层平均值 647.回文子串 649. Dota2 参议...</p></div></div></a></div></div></div><!-- Navigation buttons at the bottom of the post. v2.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --><div class="post-navigation d-flex justify-content-between"> <a href="/HYCBlog/posts/leetcode-solution_101_200/" class="btn btn-outline-primary"><p>Leetcode题解:101~200</p></a> <a href="/HYCBlog/posts/leetcode-solutions/" class="btn btn-outline-primary"><p>Leetcode题解:1~500</p></a></div></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('#post-wrapper img'); const observer = lozad(imgs); observer.observe(); </script> <!-- The Footer v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><footer class="d-flex w-100 justify-content-center"><p class="footer-center"> © 2021 <a href="">Yucai Huang</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span> <br> <a href="https://beian.miit.gov.cn/" target="_blank">浙ICP备2020032055号-1</a></p></footer></div><!-- The Search results v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-xl-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/HYCBlog/tags/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/">算法题解</a> <a class="post-tag" href="/HYCBlog/tags/java%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/">Java源码学习</a> <a class="post-tag" href="/HYCBlog/tags/jvm/">jvm</a> <a class="post-tag" href="/HYCBlog/tags/java/">java</a> <a class="post-tag" href="/HYCBlog/tags/algorithms/">Algorithms</a> <a class="post-tag" href="/HYCBlog/tags/web/">web</a> <a class="post-tag" href="/HYCBlog/tags/security/">security</a> <a class="post-tag" href="/HYCBlog/tags/redis/">redis</a> <a class="post-tag" href="/HYCBlog/tags/concurrency/">concurrency</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <!-- The GA snippet v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','https://www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-176388509-1', 'auto'); ga('send', 'pageview'); </script> <script> (function(e,t,n,i,s,a,c){e[n]=e[n]||function(){(e[n].q=e[n].q||[]).push(arguments)} ;a=t.createElement(i);c=t.getElementsByTagName(i)[0];a.async=true;a.src=s ;c.parentNode.insertBefore(a,c) })(window,document,"galite","script","https://cdn.jsdelivr.net/npm/ga-lite@2/dist/ga-lite.min.js"); galite('create', '{"id"=>"UA-176388509-1", "pv"=>{"enabled"=>false, "proxy_url"=>"", "proxy_endpoint"=>"", "cache"=>true}}', 'auto'); galite('send', 'pageview'); </script> <!-- Jekyll Simple Search loader v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/HYCBlog/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="www.yucaihuang.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"><div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>{categories}</div><div><i class="fa fa-tag fa-fw"></i>{tags}</div></div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>' }); </script>
