---
title: 数据库：脏读、幻读和不可重复读
author: Kol Huang
date: 2020-09-06 09:36:00 +0800
categories: [Blogging, database]
tags: [web]
comments: true
math: true
---



### 数据库事务的特征

> A Atomicity 原子性

事务是一个原子性质的操作单元，事务里面对数据库的操作要么都执行，要么都不执行。

> C Consistent 一致性

在事务开始之前和完成之后，数据库都必须保持一致状态，必须保证数据库的完整性。拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。

> I Isolation 隔离性

数据库允许多个并发事务同时对数据进行操作，隔离性保证各个事务相互独立，一个事务处理的中间状态对其他事务是不可见的。

> D Durable 持久性

一个食物处理结束后，其对数据库的修改是永久性的，即使系统故障也不会丢失。在提交事务方法后，提示用户事务操作完成，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。



### 脏读

指的是一个事务中访问到了另外一个事务未提交的数据。

```markdown
假设有两个事务并发执行，事务A首先更新了属性X的值，然后事务B读取了属性X的值，那么事务B获得了更新后的属性X，这
与期望不符。更过分的情况是，事务B在事务A读取属性X之后，执行了rollback，使得事务A获得的数据是一个无效的数据。
```



### 幻读

一个事务读取两次，得到的结果不一致。

```markdown
假设有两个事务并发执行，事务A首先查询了某个表的记录条数，结果为n。然后事务B紧接着在该表中插入了一条新记录，然
后执行了Commit。事务A再次查询了这个表的记录条数，结果为n+1。导致前后结果不一致。
```



### 不可重复读

一个事务读取同一条记录两次，得到的结果不一致。

```markdown
假设有两个事务并发执行，事务A首先查询了某个表的某一条记录。然后事务B紧接着修改了这一条记录，然后执行了Commit。事务A再次查询了该表的这条记录，导致前后结果不一致。
```





### 如何解决上述情况？

> 未授权读取

Read Uncommitted：允许脏读取，但不允许更新丢失。如果一个事务已经开始写数据，则另外一个事务则不允许同时进行写操作，但允许其他事务读此行数据。该隔离级别可以通过“排他写锁”实现。



> 授权读取

Read Committed：允许不可重复读取，但不允许脏读取。这可以通过“瞬间共享读锁”和“排他写锁”实现。读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行。



> 可重复读取

Repeatable Read：禁止不可重复读取和脏读取，但是有时可能出现幻读数据。这可以通过“共享读锁”和“排他写锁”实现。读取数据的事务将会禁止写事务（但允许读事务），写事务则禁止任何其他事务。



> 序列化

Serializable：提供严格的事务隔离。它要求事务序列化执行，事务只能一个接着一个地执行，不能并发执行。仅仅通过“行级锁”是无法实现事务序列化的，必须通过其他机制保证新插入的数据不会被刚执行查询操作的事务访问到。



对于多数应用程序，可以优先考虑把数据库系统的隔离级别设为Read Committed。它能够避免脏读取，而且具有较好的并发性能。尽管它会导致不可重复读、幻读和第二类丢失更新这些并发问题，在可能出现这类问题的个别场合，可以由应用程序采用悲观锁或乐观锁来控制。

